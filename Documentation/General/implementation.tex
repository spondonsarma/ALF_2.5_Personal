% !TEX root = Doc.tex
\section{Implementation of the model} \label{sec:imp}
 In the code, the module \texttt{Hamiltonian} defines the model Hamiltonian,  the lattice under consideration and the desired observables (table~\ref{table:hamiltonian}).
The respective file name is \texttt{Hamiltonian\_\textit{<Model Name>}.f90}: for example, \texttt{Hamiltonian\_Hub.f90} defines the plain Hubbard model on the two-dimensional square lattice. To implement a user-defined model, therefore only the module \texttt{Hamil}-\texttt{tonian} has to be set up. Accordingly, this documentation focusses almost entirely  on this module and the subprograms it includes. 
The remaining parts of the code may be treated as as a black box.

%
\begin{table}[h]
   \begin{tabular}{l l l}
    Name of &  &  \\
    subprogram & Description & Section \\\hline
    \texttt{Ham\_Set}  & Reads in model and lattice parameters from the file \texttt{parameters}. \\
                       & And it sets the Hamiltonian by calling \texttt{Ham\_latt}, \texttt{Ham\_hop}, and \texttt{Ham\_V}. & \\
    \texttt{Ham\_hop}  & Sets the hopping term  $\hat{\mathcal{H}}_{T}$ by calling \texttt{Op\_make} and \texttt{Op\_set}. & \ref{sec:op}, \ref{sec:specific}\\
    \texttt{Ham\_V}    & Sets the interaction terms  $\hat{\mathcal{H}}_{V}$ and $\hat{\mathcal{H}}_{I}$ 
                         by calling \texttt{Op\_make} and \texttt{Op\_set}.& \ref{sec:op}, \ref{sec:specific}\\  
    \texttt{Ham\_Latt} & Sets the lattice by calling \texttt{Make\_Lattice}.& \ref{sec:latt}\\
    \texttt{S0}        & A function which returns an update ratio for the Ising term $\hat{\mathcal{H}}_{I,0}$. 
    & \ref{sec:s0} \\
    \texttt{Alloc\_obs} & Asigns memory storage to the observables & \\
    \texttt{Init\_obs}  & Initializes the observables to zero. & \\
    \texttt{Obser}      & Computes the scalar observables and equal-time correlation functions. & \ref{sec:obs} \\
    \texttt{OBSERT}     & Computes time-displaced correlation functions. & \ref{sec:obs}\\
    \texttt{Pr\_obs}    & Writes the observables to the disk by calling \texttt{Print\_bin}.   
    
   \end{tabular}
   \caption{   Overview of the subprograms of the  module \texttt{Hamiltonian} to define the Hamiltonian, the lattice and the observables.
    \label{table:hamiltonian}}
\end{table}
%

\subsection{The \texttt{Operator} type}\label{sec:op}
The fundamental data structure in the code is the derived data type \texttt{Operator}. This type is used to define the Hamiltonian (\ref{eqn:general_ham}). 
In general, the matrices ${\bf T}^{(ks)}$, ${\bf V}^{(ks)}$  and   ${\bf I}^{(ks)}$are sparse Hermitian matrices.   
Consider the  matrix   ${\bm X}$ of dimension  $N_{\mathrm{dim}} \times N_{\mathrm{dim}}$, as an representative of each of the above three matrices .  Let us  denote  with  $ \left\{z_{1},\cdots,  z_{N}  \right\}$  a subset  of $N$ indices,  
for which
\begin{equation}
X_{x,y}  =
\left\{\begin{matrix}  X_{x,y}  &  \text{ if }   x,  y  \in \left\{ z_1, \cdots z_N \right\}\\ 
                                  0         &  \text{ otherwise } 
      \end{matrix}\right.
\end{equation}
 We define the $N \times N_{\mathrm{dim}}$ matrices $\mathbf{P}$  as
\begin{equation}
P_{i,x}=\delta_{z_{i},x}\;,
\end{equation}
where $i \in [1,\cdots, N ]$ and $ x  \in [1,\cdots, N_{\mathrm{dim}}]$. The matrix  $\bm{P}$ picks out the non-vanishing entries of $\bm{X}$, 
which are contained in the rank-$N$  matrix $\bm{O}$.  Thereby: 
\begin{equation}
\bm{X} =\bm{P}^{T} \bm{O} \bm{P}\;,
\end{equation}
such that:
\begin{equation}
X_{x,y} = \sum\limits_{i,j}^{N}  P_{i,x}  O_{i,j} P_{j,y}=\sum\limits_{i,j}^{N} \delta_{z_{i},x}  O_{ij} \delta_{z_{j},y} \;.
\end{equation}
Since  the  $\bm{P}$ matrices have only one non-vanishing entry per column,  they can be stored as a vector $\vec{P}$:
\begin{equation}
     P_i = z_i.
\end{equation}  
There are  many useful  identities which emerge from this  structure. For example: 
\begin{equation}
	e^{\bm{X}} =  e^{\bm{P}^{T} \bm{O} \bm{P}}   = \sum_{n=0}^{\infty}  \frac{\left( \bm{P}^{T} \bm{O} \bm{P} \right)^n}{n!} =  \bm{P}^{T} e^{ \bm{O} } \bm{P}
\end{equation}
since 
\begin{equation} 
	 \bm{P} \bm{P}^{T}= 1_{N\times N}.
\end{equation}

In the code, we define a structure called \texttt{Operator} to capture the above. 
This type \texttt{Operator} bundles several components that are needed to define and use an operator matrix in the program.  

\subsubsection{Specification of the model}\label{sec:specific}
%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of variable in the code & Description \\\hline
    \hl{\texttt{Op\_X\%N}}            &  effective dimension $N$ \\
    \hl{\texttt{Op\_X\%O}}            &  matrix  $\mathbf{O}$  of dimension $N \times N$\\
    \hl{\texttt{Op\_X\%P}}            &  projection matrix $\mathbf{P}$  encoded as a vector of dimension $N$.\\
    \hl{\texttt{Op\_X\%g}}            &  coupling strength $g$ \\  
    \hl{\texttt{Op\_X\%alpha}}      &  constant $\alpha$ \\
    \hl{\texttt{Op\_X\%type}}        &  integer parameter to set the type of 
                                             HS transformation\\
                                &  (1 = Ising, 2 = Discrete HS, for perfect square)  \\ 
    \texttt{Op\_X\%U}            &  matrix containing the eigenvectors of $\mathbf{O}$  \\
    \texttt{Op\_X\%E}            &  eigenvalues of $\mathbf{O}$ \\
    \texttt{Op\_X\%N\_non\_zero} &  number of non-vanishing eigenvalues of $\mathbf{O}$ 
   \end{tabular}
   \caption{Components of the \texttt{Operator}  type. 
   In the left column, the letter \texttt{X} is a placeholder for the letters \texttt{T} and \texttt{V}, 
   indicating hopping and interaction operators, respectively.
   The highlighted variables have to be specified by the user.
  %  One will have to specify $N$, $O$, $P$, $g$, $\alpha$ and the type.  The other variables will be automatically generated in the routine \texttt{Op\_Set}.  
    \label{table:operator}}
\end{table}
%
In order to specify the  Hamiltonian (\ref{eqn:general_ham}), we will  need several arrays of  structure variables \texttt{Operator}. Its components are listed in Table~\ref{table:operator}.  
Since the implementation exploits the $SU(N_{\mathrm{col}})$ invariance of the Hamiltonian, we have dropped the color index $\sigma$ in the following.
\begin{itemize}
\item Hopping Hamiltonian (\ref{eqn:general_ham_t}): 
In this case $\bm{X}=\bm{T}^{(k,s)}$. The corresponding array of structure variables \texttt{Op\_T} is  \texttt{Op\_T(M$_T$,N$_{fl}$)} . 
Precisely, a single variable  \texttt{Op\_T}  describes the operator matrix:
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x T_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{T}]$ and $s=[1, N_{\mathrm{fl}}]$.
We have $g=-\Delta \tau$, $\alpha = 0$, and the type variable $\texttt{Op\_T\%type}$  is irrelevant. 



\item Interaction Hamiltonian (\ref{eqn:general_ham_v}):
If the interaction is of perfect-square type, we set  ${\bm X}  = \bm{V}^{(k,s)}$ 
and  define the corresponding structure variables \texttt{Op\_V}  using the array \texttt{Op\_V(M\_V,N\_{fl})}.
A single variable  \texttt{Op\_V}  describes the operator matrix:
\begin{equation}
             \left[ \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x V_{x,y}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right) - \alpha_{ks} \right]  \;,
\end{equation} 
where $k=[1, M_{V}]$ and $s=[1, N_{\mathrm{fl}}]$. For the perfect-square interaction, $\alpha = \alpha_{ks}$ and $g = \sqrt{\Delta \tau  U_k}$. 
The discrete Hubbard-Stratonovich decomposition is selected by setting the type variable to $\texttt{Op\_V\%type}=2$.

\item Ising interaction Hamiltonian (\ref{eqn:general_ham_i}):
In this case, $\bm{X}  = \bm{I}^{(k,s)} $ and we define the array\\ \texttt{Op\_V(M\_I,N\_{fl})}.  
A single variable  \texttt{Op\_V} then  describes the operator matrix:
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x I_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{I}]$ and $s=[1, N_{\mathrm{fl}}]$.
The Ising interaction is specified by setting the type variable  $\texttt{Op\_V\%type=1}$, $\alpha = 0$ and $g = -\Delta \tau$.  

\item In case of a full interaction [perfect-square term (\ref{eqn:general_ham_v}) and Ising term (\ref{eqn:general_ham_i})], we  define  the corresponding doubled array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) }) and set the variables separately for both ranges of the array according to the above.  

\end{itemize}
  %      There is another array   which defines the full interaction,  Ising as well as perfect square terms. For this  we define  the array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) }). In this context the variable \texttt{Op\_V\%type} specifies the interaction: Ising or  a perfect square.  If the interaction is of Ising type, then  $\bm{V}  = \bm{I}^{(k,s)} $, $\alpha = 0$ and $g = -\Delta \tau$.  
%   If the interaction is a perfect square type, then  $\bm{V}  = \bm{V}^{(k,s)} $, $\alpha = \alpha_{k,s}$ and $g = \sqrt{\Delta \tau  U_k}$.  

%The variable $\texttt{Op\_V\%type}  $  in the operator structure  is required to specify  the following. If the operator  correspond to an interaction part of the Hamiltonian  then for 
%$\texttt{Op\_V\%type} =1 $   the operator referes to an Ising  operator $ \bm{I}^{k,s}$ and for  $\texttt{Op\_V\%type} =2 $  to $\bm{V}^{ks} $
%\begin{itemize}
%\item the projector ${\bm P}$, encoded as the vector $\vec{P}$,
%\item the matrix ${\bm O}$ of dimension $N \times N$  
%\item the effective dimension $N$,
%\item and a couple of auxiliary matrices and scalars.
%\end{itemize}
%The precise definition of the Operator type reads:




\subsection{The Lattice}\label{sec:latt}

We have a lattice module  which  generate  a two dimensional Bravais lattice.  The user has to specify unit vectors $\vec{a}_1$ and $\vec{a}_2$ as well as   the size of the  lattice. The size is  characterized by  two vectors $\vec{L}_1$ and $\vec{L}_2$   and  the lattice is placed on a torus: 
\begin{equation}
	\hat{c}_{\vec{i} + \vec{L}_1 }  = \hat{c}_{\vec{i} + \vec{L}_2 }  = \hat{c}_{\vec{i}}
\end{equation}
The call 
\texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt )} will generate the lattice   \texttt{Latt} of type \texttt{Lattice}.   Note that  the structure of the unit cell has to be provided by the user. 
%
\mycomment{
\begin{itemize}
\item The modules \texttt{lattice\_v3} is for a general square lattice. 
\item what about additional orbitals? 
\item other dimensions?
\item mention the pre-defined lattices
\end{itemize}
}
% 
%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of variable in the code & Description \\\hline
    \texttt{Latt\%N}, \texttt{Latt\%Ns} &  number of lattice points, $N_{unit\,cell}$ \mycomment{why N and Ns} \\
    \texttt{Latt\%list}       &  maps each lattice point $i=1,\cdots N_{unit\,cell}$ to a real space vector\\
                              & \texttt{list(i,1)} $\vec{a}_1$ +  \texttt{list(i,2)} $\vec{a}_2$ \\
    \texttt{Latt\%invlist}    &  maps each real space vector to the corresponding lattice point $i$ \\
    \texttt{Latt\%nnlist}     &  maps each lattice point to its four nearest neighbors \\
    \texttt{Latt\%listk}      &  maps each reciprocal lattice point $k=1,\cdots N_{unit\,cell}$\\
                              & to a reciprocal space vector\\
                              & \texttt{listk(k,1)} $\vec{b}_1$ +  \texttt{listk(k,2)} $\vec{b}_2$ \\
    \texttt{Latt\%invlistk}   &  maps each reciprocal space vector to the corresponding \\
                              & reciprocal lattice  point $k$ \\
    \texttt{Latt\%imj}        &  \mycomment{ between two lattice site vectors} \\
    \hl{\texttt{Latt\%a1\_p}, \texttt{Latt\%a2\_p}}   & unit vectors $\vec{a}_1$,  $\vec{a}_2$ \\
    \texttt{Latt\%b1\_p}, \texttt{Latt\%b1\_p}   & unit vectors $\vec{b}_1$, $\vec{b}_2$ of the reciprocal lattice \\
    \texttt{Latt\%BZ1\_p}, \texttt{Latt\%BZ2\_p}  & vectors that span the Brillouin zone\\
    \hl{\texttt{Latt\%L1\_p}, \texttt{Latt\%L2\_p}}   & vectors $\vec{L}_1$, $\vec{L}_2$ that span the real space lattice \\
    \texttt{Latt\%b1\_perp\_p}, \texttt{Latt\%b2\_perp\_p}  & \mycomment{vectors} 
   \end{tabular}
   \caption{Components of the \texttt{Lattice} type for two-dimensional lattices using as example the default lattice name \texttt{Latt}.
   The highlighted variables have to be specified by the user.
    \label{table:lattice}}
\end{table}
%

\subsection{The Observables}\label{sec:obs}

% We have three types of observables. 
% \begin{itemize}
% \item Scalar observables such as the energy
% \item Equal time correlation functions.  Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
% from the unit cell.   The program will compute: 
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \item  Time displaced correlation functions. This has a very similar structure than above but now with an additional time index.
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \end{itemize}


We have three types of observables: scalar observables, equal-time correlation functions, and imaginary time-displaced correlation functions.


\mycomment{mention bins, sweeps}
\mycomment{We have to add some  more details.}
\subsubsection{Scalar observables}
Several scalar observables are measured and accumulated in the array \texttt{Obs\_scal} during the simulation (see table \ref{table:obs}).
%
\begin{table}[h]
   \begin{tabular}{l l l}
    Name of variable in the code & Definition & Description \\\hline
\texttt{Obs\_scal(1)} & 
$\rho=\sum\limits_{k=1}^{M_T}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{x}^{N_{\mathrm{dim}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}   \rangle$ &
electronic density\\
\texttt{Obs\_scal(2)} & 
$E_{\mathrm{kin}}=\sum\limits_{k=1}^{M_T}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} T_{xy}^{(k s)} \hat{c}^{\phantom\dagger}_{y \sigma s}   \rangle$ &
kinetic energy\\
\texttt{Obs\_scal(3)} & 
$E_{\mathrm{pot}}=\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\prod\limits_{s=1}^{N_{\mathrm{fl}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}  
\rangle$ &
potential energy \mycomment{need input here} \\
\texttt{Obs\_scal(4)} & 
$E_{\mathrm{tot}}=E_{\mathrm{kin}}+E_{\mathrm{pot}}$ &
total energy\\
\texttt{Obs\_scal(5)} & 
$\langle \mathrm{phase} \rangle$ &
phase of MC update probability
   \end{tabular}
   \caption{Scalar observables that are stored in the array \texttt{Obs\_scal}.
   \mycomment{$E_{pot}$ is for $U_{spin}(1)$ symmetric Hubbard; we would need the general expresssion for $E_{pot}$ , if possible. 
   It is not the expectation value of the perfect-square term, right? The $\alpha$'s are missing.}
    \label{table:obs}}
\end{table}
%



\subsubsection{Equal-time correlation functions}

Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
from the unit cell.   The program will compute: 
\begin{equation}
	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
\end{equation}

\subsubsection{Time-displaced correlation functions}

This has a very similar structure than above but now with an additional time index.
\begin{equation}
	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
\end{equation}

%To set the  interaction part, we therefore have to specify the following:
%\begin{itemize}
%\item the matrix elements $\left[O_{V}^{(k)}\right]_{ij}$
%\item the set $[z_{1}^{(k)},\cdots  z_{N_{eff}^{(k)}}^{(k)}]$ 
%\item the interaction strenghts $U_{k}$
%\item the numbers  $\alpha_{k}$.
%\end{itemize}
%\mycomment{Be more specific here what really has to specified in the actual code.}%
%The same logic also applies to the implementation of the hopping interaction \mycomment{be more specific}.






%\begin{itemize}
%\item in the coupling $g$ in the \texttt{Operator} structure (see Sec.~\ref{}).
%\item as normalization constant in the definition of observables (see Sec.~\ref{})
%\item as exponent in the calculation of the phase factor and the Monte Carlo update ratio.
%\end{itemize}
%\subsection{Structure of the hopping matrix  ${\bf T}$ and the interaction matrices ${\bf V}^{(k)}$}


%\subsection{The Hubbard-Stratonovich decomposition} 
%Consider a single-particle (in other words bilinear) operator $O_{i}$.
%One obtains an approximation to the evolution operator by the following series expansion \cite{AssaadBook08}
%\begin{equation}
%\label{eqn_2_HS}
%e^{-\Delta\tau O^{2}_{i} } = \sum\limits_{s=\pm1,\pm2} \gamma(s) e^{i \sqrt{\Delta\tau}\eta(s)O_{i}} + \mathcal{O}(\Delta\tau^{4})\;,
%\end{equation}
%with 
%
%\begin{eqnarray}
%\gamma(\pm 1) = (1+\sqrt{6}/3)/4\;,\;\gamma(\pm 2) = (1-\sqrt{6}/3)/4\;,\nonumber\\
%\eta(\pm 1) =\pm \sqrt{2(3-\sqrt{6})}\;,\;\eta(\pm 2) =\pm \sqrt{2(3+\sqrt{6})}\;.
%\end{eqnarray}
%
%Eq.~(\ref{eqn_2_HS}) can be easily proven by expanding its right hand side  to eighth order in $O_{i}$. 
%The transformation introduces therefore two Ising fields $s$ per lattice site $i$, taking the values $\pm 1$ and $\pm 2$.
%\mycomment{same label as the flavor index}
