% !TEX root = Doc.tex
\section{Implementation of the model} \label{sec:imp}
In the code, the module \texttt{Hamiltonian} defines the model Hamiltonian, the lattice under consideration and the desired observables (Table~\ref{table:hamiltonian}).
The respective file name is \texttt{Hamiltonian\_\textit{<Model Name>}.f90}: for example, \texttt{Hamiltonian\_Hub.f90} defines the plain Hubbard model on the two-dimensional square lattice. To implement a user-defined model, therefore only the module \texttt{Hamil}-\texttt{tonian} has to be set up. Accordingly, this documentation focusses almost entirely  on this module and the subprograms it includes. 
The remaining parts of the code may be treated as as a black box.  

To specify the Hamiltonian, one needs  an  \texttt{Operator},  \texttt{Lattice}   and  observable types. These three data structures will be described in the following. 

%
\begin{table}[h]
   \begin{tabular}{l l l}
    Name of &  &  \\
    subprogram & Description & Section \\\hline
    \texttt{Ham\_Set}  & Reads in model and lattice parameters from the file \texttt{parameters}. \\
                       & And it sets the Hamiltonian by calling \texttt{Ham\_latt}, \texttt{Ham\_hop}, and \texttt{Ham\_V}. & \\
    \texttt{Ham\_hop}  & Sets the hopping term  $\hat{\mathcal{H}}_{T}$ by calling \texttt{Op\_make} and \texttt{Op\_set}. & \ref{sec:op}, \ref{sec:specific}\\
    \texttt{Ham\_V}    & Sets the interaction terms  $\hat{\mathcal{H}}_{V}$ and $\hat{\mathcal{H}}_{I}$ 
                         by calling \texttt{Op\_make} and \texttt{Op\_set}.& \ref{sec:op}, \ref{sec:specific}\\  
    \texttt{Ham\_Latt} & Sets the lattice by calling \texttt{Make\_Lattice}.& \ref{sec:latt}\\
    \texttt{S0}        & A function which returns an update ratio for the Ising term $\hat{\mathcal{H}}_{I,0}$. 
    & \ref{sec:s0} \\
    \texttt{Alloc\_obs} & Asigns memory storage to the observables & \\
    \texttt{Init\_obs}  & Initializes the observables to zero. & \\
    \texttt{Obser}      & Computes the scalar observables and equal-time correlation functions. & \ref{sec:obs} \\
    \texttt{ObserT}     & Computes time-displaced correlation functions. & \ref{sec:obs}\\
    \texttt{Pr\_obs}    & Writes the observables to the disk by calling \texttt{Print\_bin}.   
    
   \end{tabular}
   \caption{   Overview of the subprograms of the  module \texttt{Hamiltonian} to define the Hamiltonian, the lattice and the observables.
    \label{table:hamiltonian}}
\end{table}
%

\subsection{The \texttt{Operator} type}\label{sec:op}
The fundamental data structure in the code is the derived data type \texttt{Operator}. 
This type is used to define the Hamiltonian (\ref{eqn:general_ham}).
In general, the matrices ${\bf T}^{(ks)}$, ${\bf V}^{(ks)}$ and ${\bf I}^{(ks)}$ are sparse Hermitian matrices.
Consider the  matrix   ${\bm X}$ of dimension  $N_{\mathrm{dim}} \times N_{\mathrm{dim}}$, as an representative of each of the above three matrices .  Let us  denote  with  $ \left\{z_{1},\cdots,  z_{N}  \right\}$  a subset  of $N$ indices,  
for which
\begin{equation}
X_{x,y}  =
\left\{\begin{matrix}  X_{x,y}  &  \text{ if }   x,  y  \in \left\{ z_1, \cdots z_N \right\}\\ 
                                  0         &  \text{ otherwise } 
      \end{matrix}\right.
\end{equation}
 We define the $N \times N_{\mathrm{dim}}$ matrices $\mathbf{P}$  as
\begin{equation}
P_{i,x}=\delta_{z_{i},x}\;,
\end{equation}
where $i \in [1,\cdots, N ]$ and $ x  \in [1,\cdots, N_{\mathrm{dim}}]$. The matrix  $\bm{P}$ picks out the non-vanishing entries of $\bm{X}$, 
which are contained in the rank-$N$  matrix $\bm{O}$.  Thereby: 
\begin{equation}
\bm{X} =\bm{P}^{T} \bm{O} \bm{P}\;,
\end{equation}
such that:
\begin{equation}
X_{x,y} = \sum\limits_{i,j}^{N}  P_{i,x}  O_{i,j} P_{j,y}=\sum\limits_{i,j}^{N} \delta_{z_{i},x}  O_{ij} \delta_{z_{j},y} \;.
\end{equation}
Since  the  $\bm{P}$ matrices have only one non-vanishing entry per column,  they can be stored as a vector $\vec{P}$:
\begin{equation}
     P_i = z_i.
\end{equation}  
There are  many useful  identities which emerge from this  structure. For example: 
\begin{equation}
	e^{\bm{X}} =  e^{\bm{P}^{T} \bm{O} \bm{P}}   = \sum_{n=0}^{\infty}  \frac{\left( \bm{P}^{T} \bm{O} \bm{P} \right)^n}{n!} =  \bm{P}^{T} e^{ \bm{O} } \bm{P}
\end{equation}
since 
\begin{equation} 
	 \bm{P} \bm{P}^{T}= 1_{N\times N}.
\end{equation}

In the code, we define a structure called \texttt{Operator} to capture the above. 
This type \texttt{Operator} bundles several components that are needed to define and use an operator matrix in the program.  

\subsubsection{Specification of the model}\label{sec:specific}
%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of variable in the code & Description \\\hline
    \hl{\texttt{Op\_X\%N}}            &  effective dimension $N$ \\
    \hl{\texttt{Op\_X\%O}}            &  matrix  $\mathbf{O}$  of dimension $N \times N$\\
    \hl{\texttt{Op\_X\%P}}            &  projection matrix $\mathbf{P}$  encoded as a vector of dimension $N$.\\
    \hl{\texttt{Op\_X\%g}}            &  coupling strength $g$ \\  
    \hl{\texttt{Op\_X\%alpha}}      &  constant $\alpha$ \\
    \hl{\texttt{Op\_X\%type}}        &  integer parameter to set the type of 
                                             HS transformation\\
                                &  (1 = Ising, 2 = Discrete HS, for perfect square)  \\ 
    \texttt{Op\_X\%U}            &  matrix containing the eigenvectors of $\mathbf{O}$  \\
    \texttt{Op\_X\%E}            &  eigenvalues of $\mathbf{O}$ \\
    \texttt{Op\_X\%N\_non\_zero} &  number of non-vanishing eigenvalues of $\mathbf{O}$ 
   \end{tabular}
   \caption{Components of the \texttt{Operator}  type. 
   In the left column, the letter \texttt{X} is a placeholder for the letters \texttt{T} and \texttt{V}, 
   indicating hopping and interaction operators, respectively.
   The highlighted variables have to be specified by the user.
  %  One will have to specify $N$, $O$, $P$, $g$, $\alpha$ and the type.  The other variables will be automatically generated in the routine \texttt{Op\_Set}.  
    \label{table:operator}}
\end{table}
%
In order to specify the  Hamiltonian (\ref{eqn:general_ham}), we will  need several arrays of  structure variables \texttt{Operator}. Its components are listed in Table~\ref{table:operator}.  
Since the implementation exploits the $SU(N_{\mathrm{col}})$ invariance of the Hamiltonian, we have dropped the color index $\sigma$ in the following.
\begin{itemize}
\item Hopping Hamiltonian (\ref{eqn:general_ham_t}): 
In this case $\bm{X}=\bm{T}^{(k,s)}$. The corresponding array of structure variables \texttt{Op\_T} is  \texttt{Op\_T(M$_T$,N$_{fl}$)} . 
Precisely, a single variable  \texttt{Op\_T}  describes the operator matrix:
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x T_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{T}]$ and $s=[1, N_{\mathrm{fl}}]$.
We have $g=-\Delta \tau$, $\alpha = 0$, and the type variable $\texttt{Op\_T\%type}$  is irrelevant. 



\item Interaction Hamiltonian (\ref{eqn:general_ham_v}):
If the interaction is of perfect-square type, we set  ${\bm X}  = \bm{V}^{(k,s)}$ 
and  define the corresponding structure variables \texttt{Op\_V}  using the array \texttt{Op\_V(M\_V,N\_{fl})}.
A single variable  \texttt{Op\_V}  describes the operator matrix:
\begin{equation}
             \left[ \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x V_{x,y}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right) - \alpha_{ks} \right]  \;,
\end{equation} 
where $k=[1, M_{V}]$ and $s=[1, N_{\mathrm{fl}}]$. For the perfect-square interaction, $\alpha = \alpha_{ks}$ and $g = \sqrt{\Delta \tau  U_k}$. 
The discrete Hubbard-Stratonovich decomposition is selected by setting the type variable to $\texttt{Op\_V\%type}=2$.

\item Ising interaction Hamiltonian (\ref{eqn:general_ham_i}):
In this case, $\bm{X}  = \bm{I}^{(k,s)} $ and we define the array\\ \texttt{Op\_V(M\_I,N\_{fl})}.  
A single variable  \texttt{Op\_V} then  describes the operator matrix:
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x I_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{I}]$ and $s=[1, N_{\mathrm{fl}}]$.
The Ising interaction is specified by setting the type variable  $\texttt{Op\_V\%type=1}$, $\alpha = 0$ and $g = -\Delta \tau$.  

\item In case of a full interaction [perfect-square term (\ref{eqn:general_ham_v}) and Ising term (\ref{eqn:general_ham_i})], we  define  the corresponding doubled array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) } and set the variables separately for both ranges of the array according to the above.  

\end{itemize}
  %      There is another array   which defines the full interaction,  Ising as well as perfect square terms. For this  we define  the array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) }). In this context the variable \texttt{Op\_V\%type} specifies the interaction: Ising or  a perfect square.  If the interaction is of Ising type, then  $\bm{V}  = \bm{I}^{(k,s)} $, $\alpha = 0$ and $g = -\Delta \tau$.  
%   If the interaction is a perfect square type, then  $\bm{V}  = \bm{V}^{(k,s)} $, $\alpha = \alpha_{k,s}$ and $g = \sqrt{\Delta \tau  U_k}$.  

%The variable $\texttt{Op\_V\%type}  $  in the operator structure  is required to specify  the following. If the operator  correspond to an interaction part of the Hamiltonian  then for 
%$\texttt{Op\_V\%type} =1 $   the operator referes to an Ising  operator $ \bm{I}^{k,s}$ and for  $\texttt{Op\_V\%type} =2 $  to $\bm{V}^{ks} $
%\begin{itemize}
%\item the projector ${\bm P}$, encoded as the vector $\vec{P}$,
%\item the matrix ${\bm O}$ of dimension $N \times N$  
%\item the effective dimension $N$,
%\item and a couple of auxiliary matrices and scalars.
%\end{itemize}
%The precise definition of the Operator type reads:




\subsection{The Lattice tpye}\label{sec:latt}

We have a lattice module  which  generate   one and two dimensional dimensional Bravais lattices.   Note that the  orbital structure of each unit cell, has to be specified by the user  in the  Hamiltonian module. 
 The user has to specify unit vectors $\vec{a}_1$ and $\vec{a}_2$ as well as   the size of the  lattice. The size is  characterized by  two vectors $\vec{L}_1$ and $\vec{L}_2$   and  the lattice is placed on a torus: 
\begin{equation}
	\hat{c}_{\vec{i} + \vec{L}_1 }  = \hat{c}_{\vec{i} + \vec{L}_2 }  = \hat{c}_{\vec{i}}
\end{equation}
The call 
\texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt )} will generate the lattice   \texttt{Latt} of type \texttt{Lattice}.   Note that  the structure of the unit cell has to be provided by the user.    The reciprocal lattice vectors are defined by: 
\begin{equation}
\label{Latt.G.eq}
	\vec{a}_i  \cdot \vec{g}_i = 2 \pi \delta_{i,j}, 
\end{equation}
and the Brillouin zone corresponds to the Wigner Seitz cell of the lattice. 
With $\vec{k} = \sum_{i} \alpha_i  \vec{g}_i $, the  k-space quantization follows from: 
\begin{equation}
\begin{bmatrix}
	\vec{L}_1 \cdot \vec{g}_1  &  \vec{L}_1 \cdot \vec{g}_2  \\
	\vec{L}_2  \cdot \vec{g_1} & \vec{L}_2 \cdot  \vec{g}_2  
\end{bmatrix}
\begin{bmatrix}
   \alpha_1 \\
   \alpha_2
\end{bmatrix}
=
2 \pi 
\begin{bmatrix}
   n \\
   m
\end{bmatrix}
\end{equation}
such that 
\begin{eqnarray}
\label{k.quant.eq}
     \vec{k} =  n \vec{b}_1  + m \vec{b}_2 \text{  with  }   & &   \vec{b}_1 = \frac{2 \pi}{ (\vec{L}_1 \cdot \vec{g}_1)  (\vec{L}_2 \cdot  \vec{g}_2 )  - (\vec{L}_1 \cdot \vec{g}_2) (\vec{L}_2  \cdot \vec{g_1} ) }   \left[  (\vec{L}_2 \cdot  \vec{g}_2) \vec{g}_1 -   (\vec{L}_2  \cdot \vec{g_1} ) \vec{g}_2 \right] \text{   and  } \nonumber \\ 
        & & \vec{b}_2 = \frac{2 \pi}{ (\vec{L}_1 \cdot \vec{g}_1)  (\vec{L}_2 \cdot  \vec{g}_2 )  - (\vec{L}_1 \cdot \vec{g}_2) (\vec{L}_2  \cdot \vec{g_1} ) }   
           \left[  (\vec{L}_1 \cdot  \vec{g}_1) \vec{g}_2 -   (\vec{L}_1  \cdot \vec{g_2} ) \vec{g}_1 \right] 
\end{eqnarray}
\mycomment{Check that the above algebra is correct!  Just checked. Seems to be OK.}
\mycomment{

}
% 
%
\begin{table}[h]
   \begin{tabular}{l l l}
    Name of variable  & Type & Description \\\hline
     \hl{\texttt{Latt\%a1\_p}, \texttt{Latt\%a2\_p}}   & Real     & Unit vectors $\vec{a}_1$,  $\vec{a}_2$ \\ 
     \hl{\texttt{Latt\%L1\_p}, \texttt{Latt\%L2\_p}}   & Real     & Vectors $\vec{L}_1$, $\vec{L}_2$ that define the topology of the  lattice. \\
     									  &              &  Tilted lattices are  thereby possible to implement.  \\
    \texttt{Latt\%N}                                                 &   Integer &  Number of lattice points, $N_{unit\,cell}$   \\
    \texttt{Latt\%list}                                               & Integer &  maps each lattice point $i=1,\cdots, N_{unit\,cell}$ to a real space vector\\ 
                                                                             &   &  denoting the position of the unit cell: \\
                                                                             &   & $\vec{R}_i$ = \texttt{list(i,1)} $\vec{a}_1$ +  \texttt{list(i,2)} $\vec{a}_2$  $  \equiv i_1  \vec{a}_1 + i_2  \vec{a}_2 $ \\
    \texttt{Latt\%invlist}                                        &  Integer &   \texttt{Invlist}$(i_1,i_2) = i $ \\
    \texttt{Latt\%nnlist}                                         &  Integer &   $j = \texttt{nnlist} (i, n_1, n_2) $,  $n_1, n_2 \in [-1,1] $ \\
                                                                           &              &    $\vec{R}_j = \vec{R}_i + n_1 \vec{a}_1  + n_2 \vec{a}_2 $ \\
   \texttt{Latt\%imj}                                             &   Integer  &  $ \vec{R}_{imj(i,j)}  =  \vec{R}_i -  \vec{R}_j$.        $imj, i, j \in  1,\cdots, N_{unit\,cell}$\\
    \texttt{Latt\%BZ1\_p}, \texttt{Latt\%BZ2\_p}  &   Real     & Reciprocal space vectors $\vec{g}_i$   (See Eq.~\ref{Latt.G.eq})\\
    \texttt{Latt\%b1\_p}, \texttt{Latt\%b1\_p}       &   Real     &  k-quantization (See Eq.~\ref{k.quant.eq}) \\
    \texttt{Latt\%listk}                                           &  Integer &  maps each reciprocal lattice point $k=1,\cdots, N_{unit\,cell}$\\
                                                                          &    & to a reciprocal space vector\\
                                                                          &     & $\vec{k}_k= \texttt{listk(k,1)} \vec{b}_1 +  \texttt{listk(k,2)} \vec{b}_2  \equiv k_1  \vec{b}_1 +   k_2  \vec{b}_2 $\\
    \texttt{Latt\%invlistk}                                     &    Integer    &   \texttt{Invlistk}$(k_1,k_2) = k $ \\
   \texttt{Latt\%b1\_perp\_p},  \\ 
   \texttt{Latt\%b2\_perp\_p}                             &    Real         &  Orthonormal vectors to $\vec{b}_i$.  For internal use. 
   \end{tabular}
   \caption{Components of the \texttt{Lattice} type for two-dimensional lattices using as example the default lattice name \texttt{Latt}.
   The highlighted variables have to be specified by the user.  Other components of the Lattice will be generated  when calling: \texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt )}.  
    \label{table:lattice}}
\end{table}
%
The \texttt{Lattice}  module equally handles  the Fourier transformation.  For example  the  subroutine  \texttt{Fourier\_R\_to\_K}   carries out the  transformation: 
\begin{equation}
	S(\vec{k}, :,:,:) =  \frac{1}{N_{unit \,cell}}  \sum_{\vec{i},\vec{j} \;\text{\mycomment{change to $\vec{i}-\vec{j}$}}}   e^{-i \vec{k} \cdot \left( \vec{i}-\vec{j} \right)} S(\vec{i}  - \vec{j}, :,:,:)
\end{equation}

and  \texttt{Fourier\_K\_to\_R}  the  inverse Fourier transform 
 \begin{equation}
	S(\vec{r}, :,:,:) =  \frac{1}{N_{unit \,cell}}  \sum_{\vec{k} \in BZ }   e^{ i \vec{k} \cdot \vec{r}} S(\vec{k}, :,:,:).
\end{equation}
In the above,   the unspecified dimensions of   structure factor can refer  to imaginary time,  and orbital indices. 


\subsection{The Observable type}\label{sec:obs}

Our definition  of the model includes observables. We have defined two observable types: \texttt{Obser\_vec}  for a array of scalar observables
such as the energy and  \texttt{Obser\_Latt}   for correlation functions that have the lattice symmetry. In the latter case, translation symmetry can be used to provide improved estimators and to reduce the size of the I/O.   In general, the user will define bins, each bins having a given amount of sweeps. Within a sweep we run sequentially trough the HS and Ising fields from   time slice 1 to $L_{\text{Trotter}}$ and back.  The results of each bin is written  in a file  and analyzed at the end of the run.     

\subsubsection{Scalar observables}
This data type  is described in Table  \ref{table:Obser_vec} and  is useful to compute an array of  scalar observables.   Consider  a variable \texttt{Obs} of type  \texttt{Obser\_vec}.  At the beginning of each bin,  a call to  \texttt{Obser\_Vec\_Init} in the module \texttt{observables\_mod.f90}  will  set   \texttt{Obs\%N=0},   \texttt{Obs\%Phase =0}  and  \texttt{Obs\%Obs\_vec(:)=0}.  Each time the main  program calls the routine \texttt{Obser}  in the  \texttt{Hamiltonian} module,  the counter \texttt{Obs\%N}   is incremented by unity,   the sign  (see Eq.~\ref{Sign.eq}) is cumulated in the  variable \texttt{Obs\%phase},  and the desired  the observables (multiplied by the sign and   $\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}$, see Sec.~\ref{Observables.General})  are cumulated in the vector \texttt{Obs\%Obs\_vec}.  
\begin{table}[h]
   \begin{tabular}{l ll }
    Name of variable  &  Type      &  Description \\\hline
    \texttt{Obs\%N}                       &  Integer        &   Number of measurements  \\
    \texttt{Obs\%Phase}               &  Complex     &    Cumulated sign (See Eq.~\ref{Sign.eq})  \\
    \texttt{Obs\%Obs\_vec(:)}        & Complex      &    Cumulated vector of observables. 
           $ \langle \langle \hat{O}(:) \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]} \text{ sign }(C) $ \\
     \texttt{Obs\%File\_Vec}           &  Character    &    Filename  in which the bins are written  
   \end{tabular}
   \caption{Components of the \texttt{Obser\_vec}  type.  The table lists the data included in a variable  \texttt{Obs}  of type \texttt{Obser\_vec}.  
\mycomment{I think you do not  use the vector character of the member \texttt{Obser\_vec\%Obs}. For the observables like energy you have created an array of type variables \texttt{Obser\_vec} 
but within the type variable, the vector is of size $1$. And each scalar observable gets its own type variable \texttt{Obs}. This is a detail but it puzzled me first. Do we have an example where the vector would be larger than $1$?}
      \label{table:Obser_vec}}
\end{table}
At the end of the bin, a call to  \texttt{Print\_bin\_Vec}   in  module \texttt{observables\_mod.f90}  will  append the result of the bin in the file  \texttt{File\_Vec}\_scal.  Note that this subroutine will automatically append the suffix  \_scal 
to the the filename \texttt{File\_Vec}.    This suffix  is important to allow automatic analysis of the data at the end of the run. 

\subsubsection{ Equal time and time displaced correlation functions}

\begin{table}[h]
   \begin{tabular}{l ll }
    Name of variable  &  Type      &  Description \\\hline
    \texttt{Obs\%N}                       &  Integer        &   Number of measurements  \\
    \texttt{Obs\%Phase}               &  Complex     &    Cumulated sign (See Eq.~\ref{Sign.eq})  \\
    \texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},\tau,\alpha,\beta$)}        & Complex      &    Cumulated   correlation function  $ \langle \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle \rangle_{C} \; \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{sign}(C) $ \\
     \texttt{Obs\%Obs\_latt0($\alpha$)}        & Complex      &    Cumulated    $ \langle \langle \hat{O}_{\vec{i},\alpha} \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{ sign }(C) $ \\
     \texttt{Obs\%File\_Latt}           &  Character    &    Filename  in which the bins are written  
   \end{tabular}
   \caption{Components of the \texttt{Obser\_latt}  type.  The table lists the data included in a variable  \texttt{Obs}  of type \texttt{Obser\_latt}  
      \label{table:Obser_vec}}
\end{table}

This data type is useful so as to deal with  imaginary time displaced as well as equal time correlation functions of the form: 
\begin{equation}
	S_{\alpha,\beta}(\vec{k},\tau) =   \frac{1}{N_{unit\, cell }} \sum_{\vec{i},\vec{j}}  e^{- \vec{k} \cdot \left( \vec{i}-\vec{j}\right) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle  - 
	  \langle \hat{O}_{\vec{i},\alpha} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right).
\end{equation}
Here,  translation symmetry of the Bravais lattice is explicitly taken into account. Note that this symmetry is broken  for a given  configuration $C$ but is restored by the Monte Carlo sampling. 
\mycomment{MB tries to fit this in here:}
The correlation function splits in a correlated part $S_{\alpha,\beta}^{\mathrm{(corr)}}(\vec{k},\tau)$ and an background part $S_{\alpha,\beta}^{\mathrm{(back)}}(\vec{k},\tau)$:
\begin{eqnarray}
  S_{\alpha,\beta}^{\mathrm{(corr)}}(\vec{k},\tau)
  &=&
   \frac{1}{N_{unit\, cell }} \sum_{\vec{i},\vec{j}}  e^{- i\vec{k} \cdot \left( \vec{i}-\vec{j}\right) }  \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle\;,\\
   S_{\alpha,\beta}^{\mathrm{(back)}}(\vec{k},\tau)
  &=&
   \frac{1}{N_{unit\, cell }} \sum_{\vec{i},\vec{j}}  e^{- i\vec{k} \cdot \left( \vec{i}-\vec{j}\right) }  \langle \hat{O}_{\vec{i},\alpha} (\tau)\rangle \langle \hat{O}_{\vec{j},\beta} \rangle\\\nonumber
  &=& 
   \frac{1}{N_{unit\, cell }} \sum_{\vec{i}}  e^{- i\vec{k} \cdot \vec{i} }  \langle \hat{O}_{\vec{i},\alpha}\rangle
   \sum_{\vec{j}}    e^{i\vec{k} \cdot  \vec{j} }    \langle \hat{O}_{\vec{j},\beta} \rangle\;,
\end{eqnarray}
where we used translation invariance in imaginary-time to drop the $\tau$ dependency in the last line. 

\mycomment{In the code, the phase factors $e^{\vec{k}\cdot \vec{i}}$ are not 
included in the output for the background. 
The output is simply $\frac{1}{N_{unit\,cell}}\sum\limits_{\vec{i}}\langle \hat{O}_{\vec{i},\alpha}\rangle$.
Is the motivation to first say $\langle \hat{O}_{\vec{i},\alpha} (\tau)\rangle=\langle \hat{O}_{\alpha}\rangle$,
use $\frac{1}{N}\sum\limits_{\vec{i}}e^{i \vec{k}\cdot\vec{i}} = \delta(\vec{i})$ 
and the use the improved estimator $\langle \hat{O}_{\alpha} \rangle=\frac{1}{N}\sum\limits_{\vec{i}}\langle \hat{O}_{\vec{i},\alpha}\rangle$?}

Consider a variable  \texttt{Obs} of type  \texttt{Obser\_latt}. At the beginning of each bin a call to  \texttt{Obser\_Latt\_Init} in the module \texttt{observables\_mod.f90}  will  initialize  the elements of \texttt{Obs} to zero.    Each time the main program calls the   \texttt{Obser} or  \texttt{ObserT} routines one  cumulates $ \langle \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle \rangle_{C} \; \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{sign}(C) $    in  \texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},\tau,\alpha,\beta$)}   
and $ \langle \langle \hat{O}_{\vec{i},\alpha}= \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{ sign }(C) $  in \texttt{Obs\%Obs\_latt0($\alpha$)}.   At the end of each bin, a call to \texttt{Print\_bin\_Latt} in the module  \texttt{observables\_mod.f90}   will append the result of the bin in the specified  file \texttt{Obs\%File\_Latt}.   Note that the routine  \texttt{Print\_bin\_Latt}  carries out the Fourier transformation and prints the results in k-space. We have adopted the following name convention.  For    equal time observables , that is  the second  dimension  of the array  \texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},\tau,\alpha,\beta$)}    is equal to unity,  the routine \texttt{Print\_bin\_Latt}  attaches the suffix \_eq to \texttt{Obs\%File\_Latt}.  For  time displaced correlation functions we use the suffix \_tau. 

% We have three types of observables. 
% \begin{itemize}
% \item Scalar observables such as the energy
% \item Equal time correlation functions.  Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
% from the unit cell.   The program will compute: 
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \item  Time displaced correlation functions. This has a very similar structure than above but now with an additional time index.
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \end{itemize}

%\mycomment{mention bins, sweeps}
%\mycomment{We have to add some  more details.}
%\subsubsection{Scalar observables}
%Several scalar observables are measured and accumulated in the array \texttt{Obs\_scal} during the simulation (see table \ref{table:obs}).
%%
%\begin{table}[h]
%   \begin{tabular}{l l l}
%    Name of variable in the code & Definition & Description \\\hline
%\texttt{Obs\_scal(1)} & 
%$\rho=\sum\limits_{k=1}^{M_T}
%\sum\limits_{s=1}^{N_{\mathrm{fl}}}
%\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
%\sum\limits_{x}^{N_{\mathrm{dim}}}
%\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}   \rangle$ &
%electronic density\\
%\texttt{Obs\_scal(2)} & 
%$E_{\mathrm{kin}}=\sum\limits_{k=1}^{M_T}
%\sum\limits_{s=1}^{N_{\mathrm{fl}}}
%\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
%\sum\limits_{x,y}^{N_{\mathrm{dim}}}
%\langle \hat{c}^{\dagger}_{x \sigma   s} T_{xy}^{(k s)} \hat{c}^{\phantom\dagger}_{y \sigma s}   \rangle$ &
%kinetic energy\\
%\texttt{Obs\_scal(3)} & 
%$E_{\mathrm{pot}}=\sum\limits_{x,y}^{N_{\mathrm{dim}}}
%\prod\limits_{s=1}^{N_{\mathrm{fl}}}
%\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}  
%\rangle$ &
%potential energy \mycomment{need input here} \\
%\texttt{Obs\_scal(4)} & 
%$E_{\mathrm{tot}}=E_{\mathrm{kin}}+E_{\mathrm{pot}}$ &
%total energy\\
%\texttt{Obs\_scal(5)} & 
%$\langle \mathrm{phase} \rangle$ &
%phase of MC update probability
%   \end{tabular}
%   \caption{Scalar observables that are stored in the array \texttt{Obs\_scal}.
%       \label{table:obs}}
%\end{table}
%%
%
%
%
%\subsubsection{Equal-time correlation functions}
%
%Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
%from the unit cell.   The program will compute: 
%\begin{equation}
%	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
%	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
%\end{equation}
%\mycomment{Should it not be
%}
%
%\subsubsection{Time-displaced correlation functions}
%
%This has a very similar structure than above but now with an additional time index.
%\begin{equation}
%	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
%	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
%\end{equation}
%
%To set the  interaction part, we therefore have to specify the following:
%\begin{itemize}
%\item the matrix elements $\left[O_{V}^{(k)}\right]_{ij}$
%\item the set $[z_{1}^{(k)},\cdots  z_{N_{eff}^{(k)}}^{(k)}]$ 
%\item the interaction strenghts $U_{k}$
%\item the numbers  $\alpha_{k}$.
%\end{itemize}
%\mycomment{Be more specific here what really has to specified in the actual code.}%
%The same logic also applies to the implementation of the hopping interaction \mycomment{be more specific}.






%\begin{itemize}
%\item in the coupling $g$ in the \texttt{Operator} structure (see Sec.~\ref{}).
%\item as normalization constant in the definition of observables (see Sec.~\ref{})
%\item as exponent in the calculation of the phase factor and the Monte Carlo update ratio.
%\end{itemize}
%\subsection{Structure of the hopping matrix  ${\bf T}$ and the interaction matrices ${\bf V}^{(k)}$}


%\subsection{The Hubbard-Stratonovich decomposition} 
%Consider a single-particle (in other words bilinear) operator $O_{i}$.
%One obtains an approximation to the evolution operator by the following series expansion \cite{AssaadBook08}
%\begin{equation}
%\label{eqn_2_HS}
%e^{-\Delta\tau O^{2}_{i} } = \sum\limits_{s=\pm1,\pm2} \gamma(s) e^{i \sqrt{\Delta\tau}\eta(s)O_{i}} + \mathcal{O}(\Delta\tau^{4})\;,
%\end{equation}
%with 
%
%\begin{eqnarray}
%\gamma(\pm 1) = (1+\sqrt{6}/3)/4\;,\;\gamma(\pm 2) = (1-\sqrt{6}/3)/4\;,\nonumber\\
%\eta(\pm 1) =\pm \sqrt{2(3-\sqrt{6})}\;,\;\eta(\pm 2) =\pm \sqrt{2(3+\sqrt{6})}\;.
%\end{eqnarray}
%
%Eq.~(\ref{eqn_2_HS}) can be easily proven by expanding its right hand side  to eighth order in $O_{i}$. 
%The transformation introduces therefore two Ising fields $s$ per lattice site $i$, taking the values $\pm 1$ and $\pm 2$.
%\mycomment{same label as the flavor index}
