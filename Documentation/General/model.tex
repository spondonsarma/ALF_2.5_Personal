
% !TEX root = Doc.tex
\section{Definition of the model Hamiltonian}\label{sec:def}

%\mycomment{Notation: Hats for second quantized operators, bold for matrices. \\
%  Structure:  \\ 1) We first want to define the model.  \\ 
 %                     2)  implementation of the QMC.  \\ 
 %                  3) Data structure  \\ 
%                   4) Practical implementation and some  simple test cases. }

 
The class of solvable models includes  Hamiltonians $\hat{\mathcal{H}}$ that have the following general form:
\begin{eqnarray}
\hat{\mathcal{H}}&=&\hat{\mathcal{H}}_{T}+\hat{\mathcal{H}}_{V} +  \hat{\mathcal{H}}_{I} +   \hat{\mathcal{H}}_{0,I}\;,\mathrm{where}
\label{eqn:general_ham}\\
\hat{\mathcal{H}}_{T}
&=&
\sum\limits_{k=1}^{M_T}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma   s}T_{xy}^{(k s)} \hat{c}^{\phantom\dagger}_{y \sigma s}  \equiv  \sum\limits_{k=1}^{M_T} \hat{T}^{(k)}
\label{eqn:general_ham_t}\\
\hat{\mathcal{H}}_{V}
&=&
-
\sum\limits_{k=1}^{M_V}U_{k}
\left\{
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\left[
\left(
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma s}V_{xy}^{(k s)}\hat{c}^{\phantom\dagger}_{y \sigma s}
\right)
-\alpha_{k s} 
\right]
\right\}^{2}  \equiv   -
\sum\limits_{k=1}^{M_V}U_{k}   \left(\hat{V}{(k)} \right)^2
\label{eqn:general_ham_v}\\
\hat{\mathcal{H}}_{I}  & = &
\sum\limits_{k=1}^{M_I} \hat{Z}_{k} 
\left\{
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\left[
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma s} I_{xy}^{(k s)}\hat{c}^{\phantom\dagger}_{y \sigma s}
\right]
\right\} \equiv \sum\limits_{k=1}^{M_I} \hat{Z}_{k}    \hat{I}^{(k)} 
\;.\label{eqn:general_ham_i}
\end{eqnarray}
The indices have the following meaning:
\begin{itemize}
\item The number of fermion \textit{flavors} is set by $N_{\mathrm{fl}}$.  After the Hubbard-Stratonovich transformation, the action will be block diagonal in the flavor index. 
\item The number of fermion \textit{colors} is set by $N_{\mathrm{col}}$.    The Hamiltonian is invariant under  SU($N_{\mathrm{col}}$)  rotations. Note that  in the code $ N_{\mathrm{col}} \equiv N_{sun} $. 
%\mycomment{ Does it set the symmetry group of the fermions, namely 
%the dimension of the special unitary group $SU(N_{sun})$?}
\item The indices $x,y$ label lattice sites where $x,y=1,\cdots, N_{\mathrm{dim}}$. 
$N_{\mathrm{dim}}$ is the total number of spacial vertices: $N_{\mathrm{dim}}=N_{unit\;cell} N_{orbital}$, where $N_{unit\;cell}$ is the number of unit cells of the underlying Bravais lattice and $N_{orbital}$ is the number of (spacial) orbitals per unit cell \mycomment{Check the definition of $N_{orbital}$ in the code.} 
\item Therefore, the  matrices $\bm{T}^{(k s)}$, $\bm{V}^{(ks)}$  and $\bm{I}^{(ks)}$ are  of dimension $N_{\mathrm{dim}}\times N_{\mathrm{dim}}$
\item The number of interaction terms  is labelled by $M_V$   and $M_I$.   $M_T> 1 $ would allow for a checkerboard decomposition. 
\item $\hat{Z}_k$ is an Ising spin operator which corresponds to the Pauli matrix $\hat{\sigma}_{z}$. It couples to a general one-body term. 
\item  $\mathcal{H}_{0,I}$  gives the dynamics of the Ising spins. 
This term has to be specified by the user and is only relevant when the Monte Carlo update probability is computed in the code (see Sec.~\ref{}).
%\mycomment{Be more general here and sreak of correlated blocks?}
\end{itemize}
Note that the matrices  $\bm{T}^{(ks)}$,  $\bm{V}^{(ks)}$ and  $\bm{I}^{(ks)}$ explicitly depend on the flavor index $s$ but not on the color index $\sigma$. 
The color index $\sigma$ only appears in  the  second quantized operators such that the Hamiltonian is manifestly SU($N_{\mathrm{col}}$)    symmetric.  We also require
the matrices $\bm{T}^{(ks)}$,  $\bm{V}^{(ks)}$ and  $\bm{I}^{(ks)}$  to be  hermitian. 

In the code, the module \texttt{Hamiltonian} defines the model Hamiltonian,  the lattice under consideration and the desired observables. 
The respective file name is \texttt{Hamiltonian\_\textit{<Model Name>}.f90}: for example, \texttt{Hamiltonian\_Hub.f90} defines the plain Hubbard model on the two-dimensional square lattice. To implement a user-defined model, therefore only the module \texttt{Hamiltonian} has to be set up. Accordingly, this documentation focusses almost entirely  on the module \texttt{Hamiltonian} and the structures it includes. 
The remaining parts of the code may be treated as as a black box.

%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of subprogram & Description \\\hline
    \texttt{Ham\_Set}  & Reads in model and lattice parameters from the file \texttt{parameters}. \\
                       & And it sets the Hamiltonian by calling \texttt{Ham\_latt}, \texttt{Ham\_hop}, and \texttt{Ham\_V}.\\
    \texttt{Ham\_Latt} & Sets the lattice by calling \texttt{Make\_Lattice}.\\
    \texttt{Ham\_hop}  & Sets the hopping term  $\hat{\mathcal{H}}_{T}$ by calling \texttt{Op\_make} and \texttt{Op\_set}.\\
    \texttt{Ham\_V}    & Sets the interaction terms  $\hat{\mathcal{H}}_{V}$ and $\hat{\mathcal{H}}_{I}$ 
                         by calling \texttt{Op\_make} and \texttt{Op\_set}.\\  
    \texttt{S0}        & A function which returns an update ratio for the Ising term $\hat{\mathcal{H}}_{I,0}$.\\
    \texttt{Alloc\_obs} & Asigns memory storage to the observables \\
    \texttt{Init\_obs}  & Initializes the observables to zero. \\
    \texttt{Obser}      & Computes the scalar observables and equal-time correlation functions.\\
    \texttt{OBSERT}     & Computes time-displaced correlation functions. \\
    \texttt{Pr\_obs}    & Writes the observables to the disk by calling \texttt{Print\_bin}.   
    
   \end{tabular}
   \caption{   Overview of the subprograms of the  module \texttt{Hamiltonian} to define the Hamiltonian, the lattice and the observables.
    \label{table:hamiltonian}}
\end{table}
%

\subsection{Formulation of the QMC}  
The formulation of the  Monte Carlo simulation is based on the following.
\begin{itemize}
\item  We will discretize the imaginary time propagation: $\beta = \Delta \tau L_{\text{Trotter}} $
\item  We will use  the   discrete Hubbard-Stratonovich transformation:
\begin{equation}
\label{HS_squares}
        e^{\Delta \tau  \lambda  \hat{A}^2 } =
        \sum_{ l = \pm 1, \pm 2}  \gamma(l)
e^{ \sqrt{\Delta \tau \lambda }
       \eta(l)  \hat{A} }
                + {\cal O} (\Delta \tau ^4)\;,
\end{equation}
where the fields $\eta$ and $\gamma$ take the values:
\begin{eqnarray}
 \gamma(\pm 1)  = 1 + \sqrt{6}/3, \quad  \eta(\pm 1 ) = \pm \sqrt{2 \left(3 - \sqrt{6} \right)}\;,\\\nonumber
  \gamma(\pm 2) = 1 - \sqrt{6}/3, \quad  \eta(\pm 2 ) = \pm \sqrt{2 \left(3 + \sqrt{6} \right)}\;.
\nonumber
\end{eqnarray}
\item  We will work in  a basis  where  $\hat{Z}_k$ is diagonal: $\hat{Z}_{k}|s_{j}\rangle = s_{k}\delta_{kj}|s_{k}\rangle$, where $s_{k}=\pm 1$.
\item From the above it follows that the  Monte Carlo configuration space $C$  
is given by the combined spaces of Ising spin configurations  and of Hubbard-Stratonovich discrete field configurations:
\begin{equation}
	C = \left\{   s_{i,\tau} ,  l_{j,\tau}  \text{ with }  i=1\cdots M_I,\;  j = 1\cdots M_V,\; \tau=1\cdots L_{\mathrm{Trotter}}  \right\}
\end{equation}
Here, the Ising spins take the values  $s_{i,\tau} = \pm 1$ and  the Hubbard-Stratonovich fields take the values  $l_{j,\tau}  = \pm 2, \pm 1 $.
\end{itemize}
With the above, the partition function of the model (\ref{eqn:general_ham}) can be written as follows.
\begin{eqnarray}
Z &=& \Tr{\left(e^{-\beta \hat{\mathcal{H}} }\right)}\nonumber\\
  &=&   \Tr{  \left[ e^{-\Delta \tau \hat{\mathcal{H}}_{0,I}}   \prod_{k=1}^{M_T}   e^{-\Delta \tau \hat{T}^{(k)}}  
    \prod_{k=1}^{M_V}   e^{  \Delta \tau  U_k \left(  \hat{V}^{(k)} \right)^2}   \prod_{k=1}^{M_I}   e^{  -\Delta \tau  \hat{\sigma}_{k}  \hat{I}^{(k)}} 
   \right]^{L_{\text{Trotter}}}}  \nonumber \\
   &=&
   \sum_{C} \left( \prod_{j=1}^{M_V} \prod_{\tau=1}^{L_{\mathrm{Trotter}}} \gamma_{j,\tau} \right) e^{-S_{0,I} \left( \left\{ s_{i,\tau} \right\}  \right) }\times \nonumber\\
   &\quad&
    \Trf{ \left\{  \prod_{\tau=1}^{L_{\mathrm{Trotter}}} \left[   \prod_{k=1}^{M_T}   e^{-\Delta \tau \hat{T}^{(k)}}  
    \prod_{k=1}^{M_V}   e^{  \sqrt{ \Delta \tau  U_k} \eta_{k,\tau} \hat{V}^{(k)} }   \prod_{k=1}^{M_I}   e^{  -\Delta \tau s_{k,\tau}  \hat{I}^{(k)}}  \right]\right\} }
\end{eqnarray}
In the above,  the trace $\mathrm{Tr} $  runs over the Ising spins as well as over the fermionic degrees of freedom, and $ \mathrm{Tr}_{\mathrm{F}}  $ only over the  fermionc Fock space. 
$S_{0,I} \left( \left\{ s_{i,\tau} \right\}  \right)  $ is the action  corresponding to the Ising Hamiltonian,  and is only dependent on the Ising spins so that  it can be pulled out of the fermionic trace.
At this point,  and  since for a given configuration $C$  we are dealing with a free propagation, we can integrate out the fermions to obtain a determinant: 
\begin{eqnarray}
 &\quad&\Trf{ \left\{  \prod_{\tau=1}^{L_{\mathrm{Trotter}}} \left[   \prod_{k=1}^{M_T}   e^{-\Delta \tau \hat{T}^{(k)}}  
    \prod_{k=1}^{M_V}   e^{  \sqrt{ \Delta \tau  U_k} \eta_{k,\tau} \hat{V}^{(k)} }   \prod_{k=1}^{M_I}   e^{  -\Delta \tau s_{k,\tau}  \hat{I}^{(k)}}  \right] \right\}} = \nonumber\\
&\quad& \quad\prod\limits_{s=1}^{N_{\mathrm{fl}}} \left[  e^{- \sum_{k=1}^{M_V} \sum_{\tau = 1}^{L_{\mathrm{Trotter}}}\sqrt{\Delta \tau U_k}  \alpha_{k,s} \eta_{k,\tau} }
   \right]^{N_{\mathrm{col}}}\times
\nonumber\\
&\quad&\quad   \prod\limits_{s=1}^{N_{\mathrm{fl}}} 
   \left[
    \det\left(  1 + 
     \prod_{\tau=1}^{L_{\mathrm{Trotter}}}   \prod_{k=1}^{M_T}   e^{-\Delta \tau {\bf T}^{(ks)}}  
    \prod_{k=1}^{M_V}   e^{  \sqrt{ \Delta \tau  U_k} \eta_{k,\tau} {\bm V}^{(ks)} }   \prod_{k=1}^{M_I}   e^{  -\Delta \tau s_{k,\tau}  {\bm I}^{(ks)}}  
     \right) \right]^{N_{\mathrm{col}}}\;.
\end{eqnarray}
All in all,   the partition function is given by:
\begin{eqnarray}
    Z &=& \Tr{  \left( e^{-\beta \hat{\mathcal{H}} }\right) }\nonumber\\
    &=&   \sum_{C}   e^{-S_{0,I} \left( \left\{ s_{i,\tau} \right\}  \right) }     \left[ \prod_{k=1}^{M_V} \prod_{\tau=1}^{L_{\mathrm{Trotter}}} \gamma_{k,\tau} \right] 
    e^{- N_{\mathrm{col}}\sum_{s=1}^{N_{\mathrm{fl}}} \sum_{k=1}^{M_V} \sum_{\tau = 1}^{L_{\mathrm{Trotter}}}\sqrt{\Delta \tau U_k}  \alpha_{k,s} \eta_{k,\tau} } 
  \times   \nonumber \\
  &\quad&
      \prod_{s=1}^{N_{\mathrm{fl}}}\left[\det\left(  1 + 
     \prod_{\tau=1}^{L_{\mathrm{Trotter}}}   \prod_{k=1}^{M_T}   e^{-\Delta \tau {\bm T}^{(ks)}}  
    \prod_{k=1}^{M_V}   e^{  \sqrt{ \Delta \tau  U_k} \eta_{k,\tau} {\bm V}^{(ks)} }   \prod_{k=1}^{M_I}   e^{  -\Delta \tau s_{k,\tau}  {\bm I}^{(ks)}}  
     \right) \right]^{N_{\mathrm{col}}} \;.
\end{eqnarray}

In the above, one notices that the weight factorizes in  the flavor index. The color index raises the determinant to the power $N_{\mathrm{col}}$. This corresponds to  an explicit $SU(N_{\mathrm{col}})$ symmetry   for each  configuration. This symmetry is manifest in the fact that the single particle  Green functions, again for a given  configuration C are color independent. 


 

\subsection{The \texttt{Operator} type}
The fundamental data structure in the code is the derived data type \texttt{Operator}. This type is used to define the Hamiltonian (\ref{eqn:general_ham}). 
In general, the matrices ${\bf T}^{(ks)}$, ${\bf V}^{(ks)}$  and   ${\bf I}^{(ks)}$are sparse Hermitian matrices.   
Consider the  matrix   ${\bm M}$ of dimension  $N_{\mathrm{dim}} \times N_{\mathrm{dim}}$, as an representative of each of the above three matrices .  Let us  denote  with  $ \left\{z_{1},\cdots,  z_{N}  \right\}$  a subset  of $N$ indices,  
for which
\begin{equation}
M_{x,y}  =
\left\{\begin{matrix}  M_{x,y}  &  \text{ if }   x,  y  \in \left\{ z_1, \cdots z_N \right\}\\ 
                                  0         &  \text{ otherwise } 
      \end{matrix}\right.
\end{equation}
 We define the $N \times N_{\mathrm{dim}}$ matrices $\mathbf{P}$  as
\begin{equation}
P_{i,x}=\delta_{z_{i},x}\;,
\end{equation}
where $i \in [1,\cdots, N ]$ and $ x  \in [1,\cdots, N_{\mathrm{dim}}]$. The matrix  $\bm{P}$ picks out the non-vanishing entries of $\bm{M}$, 
which are contained in the rank-$N$  matrix $\bm{O}$.  Thereby: 
\begin{equation}
\bm{M} =\bm{P}^{T} \bm{O} \bm{P}\;,
\end{equation}
such that:
\begin{equation}
M_{x,y} = \sum\limits_{i,j}^{N}  P_{i,x}  O_{i,j} P_{j,y}=\sum\limits_{i,j}^{N} \delta_{z_{i},x}  O_{ij} \delta_{z_{j},y} \;.
\end{equation}
Since  the  $\bm{P}$ matrices have only one non-vanishing entry per column,  they can be stored as a vector $\vec{P}$:
\begin{equation}
     P_i = z_i.
\end{equation}  
There are  many useful  identities which emerge from this  structure. For example: 
\begin{equation}
	e^{\bm{M}} =  e^{\bm{P}^{T} \bm{O} \bm{P}}   = \sum_{n=0}^{\infty}  \frac{\left( \bm{P}^{T} \bm{O} \bm{P} \right)^n}{n!} =  \bm{P}^{T} e^{ \bm{O} } \bm{P}
\end{equation}
since 
\begin{equation} 
	 \bm{P} \bm{P}^{T}= 1_{N\times N}.
\end{equation}

In the code, we define a structure called \texttt{Operator} to capture the above. 
This type \texttt{Operator} bundles several components that are needed to define and use an operator matrix in the program.  

\subsubsection{Specification of the model}
In general, we will not only have one structure variable \texttt{Operator}, but a whole  array of these structures, which defines the very Hamiltonian (\ref{eqn:general_ham}). 
%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of variable in the code & Description \\\hline
    \hl{\texttt{Op\_V\%N}}            &  effective dimension $N$ \\
    \hl{\texttt{Op\_V\%O}}            &  matrix  $\mathbf{O}$  of dimension $N \times N$\\
    \hl{\texttt{Op\_V\%P}}            &  projection matrix $\mathbf{P}$  encoded as a vector of dimension $N$.\\
    \hl{\texttt{Op\_V\%g}}            &  coupling strength $g$ \\  
    \hl{\texttt{Op\_V\%alpha}}      &  constant $\alpha$ \\
    \hl{\texttt{Op\_V\%type}}        &  integer parameter to set the type of 
                                             HS transformation\\
                                &  (1 = Ising, 2 = Discrete HS, for perfect square)  \\ 
    \texttt{Op\_V\%U}            &  matrix containing the eigenvectors of $\mathbf{O}$  \\
    \texttt{Op\_V\%E}            &  eigenvalues of $\mathbf{O}$ \\
    \texttt{Op\_V\%N\_non\_zero} &  number of non-vanishing eigenvalues of $\mathbf{O}$ 
   \end{tabular}
   \caption{Components of the \texttt{Operator}  type, using the example of the variable name \texttt{Op\_V} 
   which describes the interaction terms of the Hamiltonian. The highlighted variables have to be specified by the user.
  %  One will have to specify $N$, $O$, $P$, $g$, $\alpha$ and the type.  The other variables will be automatically generated in the routine \texttt{Op\_Set}.  
    \label{table:operator}}
\end{table}
%
The implementation is as follows:
\begin{itemize}
\item Interaction Hamiltonian (\ref{eqn:general_ham_v}):
If the interaction is of perfect-square type, we set  ${\bm M}  = \bm{V}^{(k,s)}$ 
and  define the corresponding structure variables \texttt{Op\_V}  using the array \texttt{Op\_V(M\_V,N\_{fl})}.
Precisely, a single variable  \texttt{Op\_V}  describes the operator matrix:
\begin{equation}
             \left[ \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x V_{x,y} \hat{c}^{\phantom{\dagger}}_{y}  \right) - \alpha \right]  \;.
\end{equation} 
Its components are listed in the table \ref{table:operator}. For the perfect-square interaction, $\alpha = \alpha_{k,s}$ and $g = \sqrt{\Delta \tau  U_k}$. 
The discrete Hubbard-Stratonovich decomposition is selected by setting the type variable to $\texttt{Op\_V\%type}=2$.
\item Hopping Hamiltonian (\ref{eqn:general_ham_t}): 
In this case $\bm{M}=\bm{T}^{(k,s)}$. The corresponding array of structure variables \texttt{Op\_T} is  \texttt{Op\_T(M$_T$,N$_{fl}$)} . 
We have $g=-\Delta \tau$, $\alpha = 0$, and the type variable $\texttt{Op\_T\%type}$  is irrelevant. 

\item Ising interaction Hamiltonian (\ref{eqn:general_ham_i}):
In this case, $\bm{M}  = \bm{I}^{(k,s)} $ and we define the array\\ \texttt{Op\_V(M\_I,N\_{fl})}. 
The Ising interaction is specified by setting the type variable  $\texttt{Op\_V\%type=1}$, $\alpha = 0$ and $g = -\Delta \tau$.  

\item In case of a full interaction [perfect-square term (\ref{eqn:general_ham_v}) and Ising term (\ref{eqn:general_ham_i})], we  define  the array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) }) and set 
the individual variables according to the above.  

\end{itemize}
  %      There is another array   which defines the full interaction,  Ising as well as perfect square terms. For this  we define  the array \texttt{Op\_V(M$_V$+M$_I$,N$_{fl}$) }). In this context the variable \texttt{Op\_V\%type} specifies the interaction: Ising or  a perfect square.  If the interaction is of Ising type, then  $\bm{V}  = \bm{I}^{(k,s)} $, $\alpha = 0$ and $g = -\Delta \tau$.  
%   If the interaction is a perfect square type, then  $\bm{V}  = \bm{V}^{(k,s)} $, $\alpha = \alpha_{k,s}$ and $g = \sqrt{\Delta \tau  U_k}$.  

%The variable $\texttt{Op\_V\%type}  $  in the operator structure  is required to specify  the following. If the operator  correspond to an interaction part of the Hamiltonian  then for 
%$\texttt{Op\_V\%type} =1 $   the operator referes to an Ising  operator $ \bm{I}^{k,s}$ and for  $\texttt{Op\_V\%type} =2 $  to $\bm{V}^{ks} $
%\begin{itemize}
%\item the projector ${\bm P}$, encoded as the vector $\vec{P}$,
%\item the matrix ${\bm O}$ of dimension $N \times N$  
%\item the effective dimension $N$,
%\item and a couple of auxiliary matrices and scalars.
%\end{itemize}
%The precise definition of the Operator type reads:




\subsection{The Lattice}

We have a lattice module  which  generate  a two dimensional Bravais lattice.  The user has to specify unit vectors $\vec{a}_1$ and $\vec{a}_2$ as well as   the size of the  lattice. The size is  characterized by  two vectors $\vec{L}_1$ and $\vec{L}_2$   and  the lattice is placed on a torus: 
\begin{equation}
	\hat{c}_{\vec{i} + \vec{L}_1 }  = \hat{c}_{\vec{i} + \vec{L}_2 }  = \hat{c}_{\vec{i}}
\end{equation}
The call 
\texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt )} will generate the lattice   \texttt{Latt} of type \texttt{Lattice}.   Note that  the structure of the unit cell has to be provided by the user. 
%
\mycomment{
\begin{itemize}
\item The modules \texttt{lattice\_v3} is for a general square lattice. 
\item what about additional orbitals? 
\item other dimensions?
\item mention the pre-defined lattices
\end{itemize}
}
% 
%
\begin{table}[h]
   \begin{tabular}{l l}
    Name of variable in the code & Description \\\hline
    \texttt{Latt\%N}, \texttt{Latt\%Ns} &  number of lattice points, $N_{unit\,cell}$ \mycomment{why N and Ns} \\
    \texttt{Latt\%list}       &  maps each lattice point $i=1,\cdots N_{unit\,cell}$ to a real space vector\\
                              & \texttt{list(i,1)} $\vec{a}_1$ +  \texttt{list(i,2)} $\vec{a}_2$ \\
    \texttt{Latt\%invlist}    &  maps each real space vector to the corresponding lattice point $i$ \\
    \texttt{Latt\%nnlist}     &  maps each lattice point to its four nearest neighbors \\
    \texttt{Latt\%listk}      &  maps each reciprocal lattice point $k=1,\cdots N_{unit\,cell}$\\
                              & to a reciprocal space vector\\
                              & \texttt{listk(k,1)} $\vec{b}_1$ +  \texttt{listk(k,2)} $\vec{b}_2$ \\
    \texttt{Latt\%invlistk}   &  maps each reciprocal space vector to the corresponding \\
                              & reciprocal lattice  point $k$ \\
    \texttt{Latt\%imj}        &  \mycomment{ between two lattice site vectors} \\
    \hl{\texttt{Latt\%a1\_p}, \texttt{Latt\%a2\_p}}   & unit vectors $\vec{a}_1$,  $\vec{a}_2$ \\
    \texttt{Latt\%b1\_p}, \texttt{Latt\%b1\_p}   & unit vectors $\vec{b}_1$, $\vec{b}_2$ of the reciprocal lattice \\
    \texttt{Latt\%BZ1\_p}, \texttt{Latt\%BZ2\_p}  & vectors that span the Brillouin zone\\
    \hl{\texttt{Latt\%L1\_p}, \texttt{Latt\%L2\_p}}   & vectors $\vec{L}_1$, $\vec{L}_2$ that span the real space lattice \\
    \texttt{Latt\%b1\_perp\_p}, \texttt{Latt\%b2\_perp\_p}  & \mycomment{vectors} 
   \end{tabular}
   \caption{Components of the \texttt{Lattice} type for two-dimensional lattices using as example the default lattice name \texttt{Latt}.
   The highlighted variables have to be specified by the user.
    \label{table:lattice}}
\end{table}
%

\subsection{The Observables}

% We have three types of observables. 
% \begin{itemize}
% \item Scalar observables such as the energy
% \item Equal time correlation functions.  Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
% from the unit cell.   The program will compute: 
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \item  Time displaced correlation functions. This has a very similar structure than above but now with an additional time index.
% \begin{equation}
% 	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
% 	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
% \end{equation}
% \end{itemize}


We have three types of observables: scalar observables, equal-time correlation functions, and imaginary time-displaced correlation functions.


\mycomment{mention bins, sweeps}
\mycomment{We have to add some  more details.}
\subsubsection{Scalar observables}
Several scalar observables are measured and accumulated in the array \texttt{Obs\_scal} during the simulation (see table \ref{table:obs}).
%
\begin{table}[h]
   \begin{tabular}{l l l}
    Name of variable in the code & Definition & Description \\\hline
\texttt{Obs\_scal(1)} & 
$\rho=\sum\limits_{k=1}^{M_T}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{x}^{N_{\mathrm{dim}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}   \rangle$ &
electronic density\\
\texttt{Obs\_scal(2)} & 
$E_{\mathrm{kin}}=\sum\limits_{k=1}^{M_T}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} T_{xy}^{(k s)} \hat{c}^{\phantom\dagger}_{y \sigma s}   \rangle$ &
kinetic energy\\
\texttt{Obs\_scal(3)} & 
$E_{\mathrm{pot}}=\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\prod\limits_{s=1}^{N_{\mathrm{fl}}}
\langle \hat{c}^{\dagger}_{x \sigma   s} \hat{c}^{\phantom\dagger}_{x \sigma s}  
\rangle$ &
potential energy \mycomment{need input here} \\
\texttt{Obs\_scal(4)} & 
$E_{\mathrm{tot}}=E_{\mathrm{kin}}+E_{\mathrm{pot}}$ &
total energy\\
\texttt{Obs\_scal(5)} & 
$\langle \mathrm{phase} \rangle$ &
phase of MC update probability
   \end{tabular}
   \caption{Scalar observables that are stored in the array \texttt{Obs\_scal}.
   \mycomment{$E_{pot}$ is for $U_{spin}(1)$ symmetric Hubbard; we would need the general expresssion for $E_{pot}$ , if possible. 
   It is not the expectation value of the perfect-square term, right? The $\alpha$'s are missing.}
    \label{table:obs}}
\end{table}
%



\subsubsection{Equal-time correlation functions}

Let $\hat{O}_{\vec{i},\alpha} $ be a local observable,  with $\vec{i}$ labelling the unit cell and $\alpha$ labelling the orbital or bone emanating 
from the unit cell.   The program will compute: 
\begin{equation}
	S_{\alpha,\beta}(\vec{k}) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha}  \hat{O}_{\vec{j},\alpha} \rangle  - 
	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
\end{equation}

\subsubsection{Time-displaced correlation functions}

This has a very similar structure than above but now with an additional time index.
\begin{equation}
	S_{\alpha,\beta}(\vec{k},\tau) = \frac{1}{N_{unit \;  cells}} \sum_{\vec{i},\vec{j}} e^{i \vec{k}\cdot (\vec{i} -  \vec{j} ) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\alpha} \rangle  - 
	  \langle \hat{O}_{\vec{i},\beta} \rangle \langle   \hat{O}_{\vec{i},\beta}  \rangle \right) 
\end{equation}

%To set the  interaction part, we therefore have to specify the following:
%\begin{itemize}
%\item the matrix elements $\left[O_{V}^{(k)}\right]_{ij}$
%\item the set $[z_{1}^{(k)},\cdots  z_{N_{eff}^{(k)}}^{(k)}]$ 
%\item the interaction strenghts $U_{k}$
%\item the numbers  $\alpha_{k}$.
%\end{itemize}
%\mycomment{Be more specific here what really has to specified in the actual code.}%
%The same logic also applies to the implementation of the hopping interaction \mycomment{be more specific}.






%\begin{itemize}
%\item in the coupling $g$ in the \texttt{Operator} structure (see Sec.~\ref{}).
%\item as normalization constant in the definition of observables (see Sec.~\ref{})
%\item as exponent in the calculation of the phase factor and the Monte Carlo update ratio.
%\end{itemize}
%\subsection{Structure of the hopping matrix  ${\bf T}$ and the interaction matrices ${\bf V}^{(k)}$}


%\subsection{The Hubbard-Stratonovich decomposition} 
%Consider a single-particle (in other words bilinear) operator $O_{i}$.
%One obtains an approximation to the evolution operator by the following series expansion \cite{AssaadBook08}
%\begin{equation}
%\label{eqn_2_HS}
%e^{-\Delta\tau O^{2}_{i} } = \sum\limits_{s=\pm1,\pm2} \gamma(s) e^{i \sqrt{\Delta\tau}\eta(s)O_{i}} + \mathcal{O}(\Delta\tau^{4})\;,
%\end{equation}
%with 
%
%\begin{eqnarray}
%\gamma(\pm 1) = (1+\sqrt{6}/3)/4\;,\;\gamma(\pm 2) = (1-\sqrt{6}/3)/4\;,\nonumber\\
%\eta(\pm 1) =\pm \sqrt{2(3-\sqrt{6})}\;,\;\eta(\pm 2) =\pm \sqrt{2(3+\sqrt{6})}\;.
%\end{eqnarray}
%
%Eq.~(\ref{eqn_2_HS}) can be easily proven by expanding its right hand side  to eighth order in $O_{i}$. 
%The transformation introduces therefore two Ising fields $s$ per lattice site $i$, taking the values $\pm 1$ and $\pm 2$.
%\mycomment{same label as the flavor index}
