% Copyright (c) 2016-2020 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex
%------------------------------------------------------------
\subsection{Implementation of the Hamiltonian and the lattice} 
\label{sec:hamiltonian}
%------------------------------------------------------------

The module \path{Hamiltonian} defines the model Hamiltonian, the lattice under consideration and the desired observables (Table~\ref{table:hamiltonian}). This module can be found in the file \path{Hamiltonian_Examples_mod.F90}, which also contains a number of example Hamiltonians, lattices and observables.  The examples are described in Sec.~\ref{sec:ex}.
In order to implement a user-defined model, only the module \path{Hamiltonian} has to be set up. Accordingly, this documentation focuses almost entirely  on this module and the subprograms it includes.
The remaining parts of the code may hence be treated as a black box.  

In order to specify the Hamiltonian, one needs  an  \path{Operator} and a \path{Lattice} types, as well as a type for the observables. These three data structures are described in the following sections.

%
\begin{table}[h]
	\begin{center}
    \begin{tabular}{@{} l l l @{}}\toprule
    Subprogram & Description & Section \\\midrule
    \hl{\texttt{Ham\_Set}}  & Reads in model and lattice parameters from the file \texttt{parameters}; \\
                       & sets the Hamiltonian calling the necessary subprograms. & \ref{sec:hamiltonian}\\
    %\hl{\texttt{Ham\_hop}}  & Sets the hopping term  $\hat{\mathcal{H}}_{T}$ by calling \texttt{Op\_make} and \texttt{Op\_set}. & \ref{sec:op}, \ref{sec:specific}\\
    \hl{\texttt{Ham\_V}}    & Sets the interaction term $\hat{\mathcal{H}}_{V}$ (i.e., operator \texttt{Op\_V}, Sec.~\ref{sec:op}). & \ref{sec:specific}\\
    %\hl{\texttt{Ham\_Latt}} & Sets the lattice by calling \texttt{Make\_Lattice}.& \ref{sec:latt}\\
    \hl{\texttt{S0}}        & Returns an update ratio for the Ising term $\hat{\mathcal{H}}_{I,0}$. 
    & \ref{sec:S0} \\
    \hl{\texttt{Setup\_Ising\_action}}    & Sets bonds and median lattice for the Ising bond fields. & \ref{sec:walk2}\\
    \hl{\texttt{Global\_move}} & Generates a global move and returns \texttt{T0\_Proposal\_ratio}. 
    & \ref{sec:global_space} \\
    \hl{\texttt{Delta\_S0\_global}} & Computes the ratio $e^{-S_0(C')}/e^{-S_0(C)}$. 
    & \ref{sec:global_space} \\
    \hl{\texttt{Global\_move\_tau}} & Generates a global move on a given time slice $\tau$ and returns\\ & \texttt{T0\_Proposal\_ratio} (see Eq.~\eqref{T0_ratio}). 
    & \ref{sec:global_slice} \\
    \hl{\texttt{Alloc\_obs}} & Assigns memory storage to the observables. & \\
    \hl{\texttt{Obser}}      & Computes the scalar and equal-time observables. & \ref{sec:obs} \\
    \hl{\texttt{ObserT}}     & Computes time-displaced correlation functions. & \ref{sec:obs}\\
    \texttt{Hamiltonian\_set\_} & & \\
    \texttt{nsigma}  & Sets the initial field. & \\
    \texttt{Overide\_global\_tau\_} & & \\
    \texttt{sampling\_parameters}  & Allows setting \texttt{global\_tau} parameters at run time. & \\    
    \texttt{Init\_obs}  & Initializes the observables to zero. & \\    
    \texttt{Pr\_obs}    & Writes the observables to disk by calling \texttt{Print\_bin}. \\\bottomrule    
   \end{tabular}
   \caption{Overview of the subprograms of the  module \texttt{Hamiltonian}, contained in \texttt{Hamiltonian\_Examples\_mod.F90}, used to define the Hamiltonian, the lattice and the observables. The \hl{highlighted} subroutines may have to be modified by the user.
    \label{table:hamiltonian}}
\end{center}
\end{table}
%

%------------------------------------------------------------
\subsubsection{The \texttt{Operator} type}\label{sec:op}
%------------------------------------------------------------

The fundamental data structure in the code is the \path{Operator}. It is implemented as a Fortran derived data type designed to efficiently define the Hamiltonian~\eqref{eqn:general_ham}.

Let the matrix $\bm{X}$ of dimension $N_{\mathrm{dim}} \times N_{\mathrm{dim}}$ stand for any of the typically sparse, Hermitian matrices $\bm{T}^{(ks)}$, $\bm{V}^{(ks)}$ and $\bm{I}^{(ks)}$ that define the Hamiltonian.
Furthermore, let $\left\{z_{1},\cdots, z_{N} \right\}$ denote a subset of $N$ indices
for which
\begin{equation}
X_{x,y} 
\left\{\begin{matrix}  \neq 0  &  \text{ if }   x,  y  \in \left\{ z_1, \cdots z_N \right\}\\ 
                                 = 0         &  \text{ otherwise. } 
      \end{matrix}\right.
\end{equation}
Usually, we have $N\ll N_{\text{dim}}$.
 We define the $N \times N_{\mathrm{dim}}$ matrices $\bm{P}$  as
\begin{equation}
P_{i,x}=\delta_{z_{i},x}\;,
\end{equation}
where $i \in [1,\cdots, N ]$ and $ x  \in [1,\cdots, N_{\mathrm{dim}}]$. The matrix  $\bm{P}$ selects the non-vanishing entries of $\bm{X}$, 
which are contained in the rank-$N$  matrix $\bm{O}$ defined by:
\begin{equation}\label{eqn:xeqpdop}
\bm{X} =\bm{P}^{T} \bm{O} \bm{P}\;,
\end{equation}
and 
\begin{equation}
X_{x,y} = \sum\limits_{i,j}^{N}  P_{i,x}  O_{i,j} P_{j,y}=\sum\limits_{i,j}^{N} \delta_{z_{i},x}  O_{ij} \delta_{z_{j},y} \;.
\end{equation}
Since  the  $\bm{P}$ matrices have only one non-vanishing entry per column,  they can conveniently be stored as a vector $\vec{P}$, with entries
\begin{equation}
     P_i = z_i.
\end{equation}  
There are  many useful  identities which emerge from this  structure. For example: 
\begin{equation}
	e^{\bm{X}} =  e^{\bm{P}^{T} \bm{O} \bm{P}}   = \sum_{n=0}^{\infty}  \frac{\left( \bm{P}^{T} \bm{O} \bm{P} \right)^n}{n!} = \mathds{1}+ \bm{P}^{T} \left(e^{ \bm{O} }-\mathds{1} \right) \bm{P}\;,
\end{equation}
since 
\begin{equation} 
	 \bm{P} \bm{P}^{T}= \mathds{1}_{N\times N}.
\end{equation}

In the code, we define a structure called \path{Operator} to capture the above. 
This type \path{Operator} bundles several components, listed in Table \ref{table:operator}, that are needed to define and use an operator matrix in the program.  

%------------------------------------------------------------
\subsubsection{Specification of the model}\label{sec:specific}
%------------------------------------------------------------
%
\begin{table}[h]
    \begin{tabular}{@{} l l l @{}}\toprule
    Variable & Type & Description \\\midrule
    \hl{\texttt{Op\_X\%N}}       & Integer     &  Effective dimension $N$ \\
    \hl{\texttt{Op\_X\%O}}       & Complex    &  Matrix  $\bm{O}$  of dimension $N \times N$\\
    \hl{\texttt{Op\_X\%P}}       & Integer   &  Matrix $\bm{P}$  encoded as a vector of dimension $N$\\
    \hl{\texttt{Op\_X\%g}}       & Complex    &  Coupling strength $g$ \\  
    \hl{\texttt{Op\_X\%alpha}}   & Complex  &  Constant $\alpha$ \\
    \hl{\texttt{Op\_X\%type}}    & Integer   &  Sets the type of HS transformation (1: Ising; 2: discrete HS for\\
             &   &   perfect-square term; 3: continuous real field.)  \\ 
    \texttt{Op\_X\%diag}  & Logical & True if   $\bm{O}$  is  diagonal  \\
    \texttt{Op\_X\%U}            & Complex &  Matrix containing the eigenvectors of $\bm{O}$  \\
    \texttt{Op\_X\%E}            & Real &  Eigenvalues of $\bm{O}$ \\
    \texttt{Op\_X\%N\_non\_zero} & Integer &  Number of non-vanishing eigenvalues of $\bm{O}$  \\
    \texttt{Op\_X\%M\_exp}    & Complex &  Stores $ \texttt{M\_exp}(:,:,s) = e^{g  \phi(s,\texttt{type}) \bm{O}(:,:)} $  \\
    \texttt{Op\_X\%E\_exp}    & Complex &  Stores $ \texttt{E\_exp}(:,s) = e^{g  \phi(s,\texttt{type}) \bm{E}(:)} $ 
     \\\bottomrule
   \end{tabular}
   \caption{Member variables of the \texttt{Operator}  type. 
   In the left column, the letter \texttt{X} is a placeholder for the letters \texttt{T} and \texttt{V}, 
   indicating hopping and interaction operators, respectively.
   The \hl{highlighted} variables must be specified by the user. \texttt{M\_exp} and \texttt{E\_exp}  are allocated only if  $\texttt{type}=1,2$. 
  %  One will have to specify $N$, $O$, $P$, $g$, $\alpha$ and the type.  The other variables will be automatically generated in the routine \texttt{Op\_Set}.  
    \label{table:operator}}
\end{table}
%

In this section we show how the Hamiltonian (\ref{eqn:general_ham}) is specified in the code. Notice that ALF comes with predefined structures (Sec.~\ref{sec:predefined}) which the user can combine together or use as templates for defining new Hamiltonians.

In order to specify a Hamiltonian, we have to set the matrix representation of the imaginary-time propagators,
$ e^{-\Delta \tau {\bm T}^{(ks)}}$, $e^{  \sqrt{- \Delta \tau  U_k} \eta_{k\tau} {\bm V}^{(ks)} }$ and $e^{  -\Delta \tau s_{k\tau}  {\bm I}^{(ks)}}$, that appear in the 
partition function (\ref{eqn:partition_2}).  For each pair of indices $(k,s)$, these terms have the general form
\begin{equation}\label{eqn:exponent_mat}
\text{Matrix Exponential}=
e^{g \,\phi(\texttt{type})\,\bm{X} }\;.
\end{equation}
In case of the  perfect-square term,  we additionally have to set the constant $\alpha$, see the definition of the operators $\hat{V}^{(k)}$ in Eq.~(\ref{eqn:general_ham_v}).
The data structures which hold all the above information are variables of the type \path{Operator} (see Table \ref{table:operator}). 
For each pair of indices $(k,s)$, we store the following parameters in an \path{Operator} variable:
\begin{itemize}
\item $\vec{P}$ and   $ \bm{O}$   defining the matrix $\bm{X}$ [see Eq.~(\ref{eqn:xeqpdop})],
\item the constants $g$, $\alpha$,
\item optionally: the type \texttt{type} of the discrete fields $\phi$.
\end{itemize}
The latter parameter can take one of three values: Ising (1), discrete HS (2), and real (3), as detailed in Sec.~\ref{sec:fields}.
Note that we have dropped the color index $\sigma$, since the implementation uses the $SU(N_{\mathrm{col}})$ invariance of the Hamiltonian. 

Accordingly, the following data structures fully describe the  Hamiltonian (\ref{eqn:general_ham}):
\begin{itemize}
\item For the hopping Hamiltonian (\ref{eqn:general_ham_t}), we have to set the exponentiated hopping matrices $ e^{-\Delta \tau {\bm T}^{(ks)}}$: \\
In this case $\bm{X}^{(ks)}=\bm{T}^{(ks)}$, and a single variable  \texttt{Op\_T}  describes the operator matrix
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x T_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{T}]$ and $s=[1, N_{\mathrm{fl}}]$. In the notation of the general expression (\ref{eqn:exponent_mat}), we set $g=-\Delta \tau$ (and $\alpha = 0$).
In case of the hopping matrix, the type variable $\texttt{Op\_T\%type}$  is neglected by the code. 
All in all, the corresponding array of structure variables is  \texttt{Op\_T(M$_T$,N$_{fl}$)}.

\item For the interaction Hamiltonian (\ref{eqn:general_ham_v}), which is of perfect-square type, we have to set the exponentiated matrices $e^{  \sqrt{ -  \Delta \tau  U_k} \eta_{k\tau} {\bm V}^{(ks)} }$:\\
In this case, $\bm{X}  = \bm{V}^{(ks)}$ and a single variable  \texttt{Op\_V}  describes the operator matrix:
\begin{equation}
             \left[ \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x V_{x,y}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  + \alpha_{ks} \right]  \;,
\end{equation} 
where $k=[1, M_{V}]$ and $s=[1, N_{\mathrm{fl}}]$, $g = \sqrt{-\Delta \tau  U_k}$ and  $\alpha = \alpha_{ks}$. 
The discrete Hubbard-Stratonovich decomposition which is used for the perfect-square interaction, is selected by setting the type variable to $\texttt{Op\_V\%type}=2$.
All in all, the required structure variables \texttt{Op\_V} are defined  using the array \texttt{Op\_V(M$_V$,N$_\mathrm{fl}$)}.


\item For the Ising interaction Hamiltonian (\ref{eqn:general_ham_i}), we have to set the exponentiated matrices $e^{  -\Delta \tau s_{k\tau}  {\bm I}^{(ks)}}$:\\
In this case, $\bm{X}  = \bm{I}^{(k,s)} $ and a single variable  \texttt{Op\_V} then  describes the operator matrix:
\begin{equation}
            \left( \sum_{x,y}^{N_{\mathrm{dim}}} \hat{c}^{\dagger}_x I_{xy}^{(ks)} \hat{c}^{\phantom{\dagger}}_{y}  \right)  \;,
\end{equation} 
where $k=[1, M_{I}]$ and $s=[1, N_{\mathrm{fl}}]$ and $g = -\Delta \tau$ (and $\alpha = 0$).
The Ising interaction is specified by setting the type variable  $\texttt{Op\_V\%type=1}$. 
All in all, the required structure variables are contained in the array \texttt{Op\_V(M$_{I}$,N$_\mathrm{fl}$)}.

\item In case of a full interaction [perfect-square term (\ref{eqn:general_ham_v}) and Ising term (\ref{eqn:general_ham_i})],
we  define  the corresponding doubled array \texttt{Op\_V(M$_V$+M$_I$,N$_\mathrm{fl}$)} and set the variables separately for both ranges of the array according to the above.  

\end{itemize}

%------------------------------------------------------------
\subsubsection{ Handling of the fields: the \texttt{Fields}  type } \label{sec:fields}
%------------------------------------------------------------

The partition function (see Sec.~\ref{sec:method}) consists of terms which, in general, can be written as $\gamma e^{g \phi \bm{X} }$, where $\bm{X}$ denotes an arbitrary operator, $g$ is a constant, and $\gamma$ and $\phi$ are fields. 
For such auxiliary fields a dedicated type \texttt{Fields} is defined, whose components, listed in Table~\ref{table:Fields}, include the variables \texttt{Field\%f} and \texttt{Field\%t}, which store the field values and types, respectively, and functions such as \texttt{Field\%flip}, which flips the field values randomly (as there are only two Ising states, $s_{k,\tau} = \pm 1$, it simply inverts the sign for those).

For an Ising term, we store type \texttt{t=1}, which sets $\gamma_{k,\tau} = 1$ and $\phi_{k,\tau}=s_{k,\tau} = \pm 1$. 
In the case of a perfect-square term, the fields results from the discrete HS transformation (\ref{HS_squares}) and we store \texttt{t=2}, which sets $\gamma_{k,\tau} = s_{k,\tau}$ and $\phi_{k,\tau}=\eta_{k,\tau}$ (see Eq.~\ref{eta_gamma_fields}). For continuous real fields $f$ we store \texttt{t=3}, which sets $\gamma_{k,\tau} = 1$ and $\phi_{k,\tau}=f$.

%
\begin{table}[h]
	\begin{center}
	\begin{tabular}{@{} p{0.25\columnwidth} p{0.08\columnwidth} p{0.6\columnwidth} @{}}\toprule
		Component                 &                & Description    \\ \midrule
		\textbf{Variable}         &  \textbf{Type} &  \\ \midrule
		\texttt{Field\%f(:,:)}    &  Real          & Defines the auxiliary fields. The first index runs through the operator sequence and the second through the time slices. \\
		\texttt{Field\%t(:)}      &  Integer       & Sets the HS transformation type (1: Ising; 2: discrete HS for perfect-square term; 3: continuous real field). The index denotes the operator. \\
		\texttt{Field\%del}       &  Real          & Width $\Delta x$ of the uniform random initial configuration for fields of type \texttt{t=3}, with a default value of \texttt{1}. \\
		\texttt{Field\%amplitude} &  Real          & Width of a random flip for fields of type \texttt{t=3}, defaults to \texttt{1}. \vspace{7pt} \\ 
		\multicolumn{2}{@{}l@{}}{ \textbf{Method(arguments)}}          &    \\ \midrule
		\multicolumn{2}{@{}l@{}}{ \texttt{Fields\_init(del)}}          & Initializes internal variables such as $s_{k,\tau}$ and $\eta_{k,\tau}$, the variable $\texttt{del}=\Delta x$ (see above) is optional.  \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%make(n\_op,n\_tau)}}  & Reserves memory for the field.    \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%clear()}}             & Clears field from memory.    \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%set()}}               & Sets a random configuration.    \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%flip(n\_op,n\_tau)}}  & Flips the field values randomly. \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%phi(n\_op,n\_tau)}}   & Returns $\phi_{k\tau}$ for the $k$-th operator at the time slice $\tau$. \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%gamma(n\_op,n\_tau)}} & Returns $\gamma_{k\tau}$ for the $k$-th operator at the time slice $\tau$.    \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%i(n\_op,n\_tau)}}     & Returns \texttt{Field\%f} rounded to nearest integer (for \texttt{t=1} or \texttt{2}). \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%in(Group\_Comm,In\_field)}} & Reads in the initial field configuration from the file \texttt{confin\_0}, if present, otherwise reads \texttt{seeds} (see Table~\ref{table:input}) and the configuration \texttt{In\_field} -- if provided, otherwise calls \texttt{Field\%set()}. \\
		\multicolumn{2}{@{}l@{}}{ \texttt{Field\%out(Group\_Comm)}}    & Writes out the field configuration.    \\\bottomrule
	\end{tabular}
	\caption{Components of a variable of type \texttt{Fields} named \texttt{Field}, where 
		%\texttt{this} denotes the field itself,
		\texttt{del} (real) denotes the \texttt{Field\%del}, \texttt{n\_op} and \texttt{n\_tau} (integers) are the number of operators and time slices, respectively, \texttt{Group\_Comm} (integer) defines an MPI communicator, and the optional \texttt{In\_field} stores the initial field configuration.}
    \end{center}
	\label{table:Fields}
\end{table}
%



%------------------------------------------------------------
\subsubsection{The \texttt{Lattice} and \texttt{Unit\_cell} types}\label{sec:latt}
%------------------------------------------------------------

ALF's lattice module can generate one- and two-dimensional Bravais lattices.
Both the lattice and the unit cell are defined in the module \texttt{Lattices\_v3\_mod.F90} and their components are detailed in Tables \ref{table:lattice} and \ref{table:unit_cell}. 
Note that the orbital structure of each unit cell has to be specified by the user in the Hamiltonian module -- however, the \texttt{Predefined\_Latt\_mod.F90} also provides, as its name suggests, predefined lattices, described in Sec.~\ref{sec:predefined_lattices}.
The user who wishes to defined their own lattice also has to specify unit vectors $\vec{a}_1$ and $\vec{a}_2$, as well as the size of the  lattice, characterized by the vectors $\vec{L}_1$ and $\vec{L}_2$. The lattice is placed on a torus (periodic boundary conditions):
\begin{align}
	\hat{c}_{\vec{i} + \vec{L}_1 }  = \hat{c}_{\vec{i} + \vec{L}_2 }  = \hat{c}_{\vec{i}}\;.
\end{align}
The function call 
\begin{lstlisting}[style=fortran]
Call Make_Lattice( L1, L2, a1, a2, Latt )
\end{lstlisting}
generates the lattice \texttt{Latt} of type \texttt{Lattice}.   Note again that  the orbital structure of the unit cell has to be provided by the user.    The reciprocal lattice vectors $\vec{g}_i$ are defined by: 
\begin{equation}
\label{Latt.G.eq}
	\vec{a}_i  \cdot \vec{g}_i = 2 \pi \delta_{i,j}, 
\end{equation}
and the Brillouin zone $BZ$ corresponds to the Wigner-Seitz cell of the lattice. 
With $\vec{k} = \sum_{i} \alpha_i  \vec{g}_i $, the  k-space quantization follows from: 
\begin{equation}
\begin{bmatrix}
	\vec{L}_1 \cdot \vec{g}_1  &  \vec{L}_1 \cdot \vec{g}_2  \\
	\vec{L}_2  \cdot \vec{g_1} & \vec{L}_2 \cdot  \vec{g}_2  
\end{bmatrix}
\begin{bmatrix}
   \alpha_1 \\
   \alpha_2
\end{bmatrix}
=  2 \pi 
\begin{bmatrix}
   n \\
   m
\end{bmatrix}
\end{equation}
such that 
\begin{eqnarray} \label{k.quant.eq}
     \vec{k} =  n \vec{b}_1  + m \vec{b}_2,\; \text{with}   & &   \vec{b}_1 = \frac{2 \pi}{ (\vec{L}_1 \cdot \vec{g}_1)  (\vec{L}_2 \cdot  \vec{g}_2 )  - (\vec{L}_1 \cdot \vec{g}_2) (\vec{L}_2  \cdot \vec{g_1} ) }   \left[  (\vec{L}_2 \cdot  \vec{g}_2) \vec{g}_1 -   (\vec{L}_2  \cdot \vec{g_1} ) \vec{g}_2 \right], \nonumber \\ 
        & & \vec{b}_2 = \frac{2 \pi}{ (\vec{L}_1 \cdot \vec{g}_1)  (\vec{L}_2 \cdot  \vec{g}_2 )  - (\vec{L}_1 \cdot \vec{g}_2) (\vec{L}_2  \cdot \vec{g_1} ) }   
           \left[  (\vec{L}_1 \cdot  \vec{g}_1) \vec{g}_2 -   (\vec{L}_1  \cdot \vec{g_2} ) \vec{g}_1 \right].
\end{eqnarray}

%
\begin{table}[h]
	\begin{center}
   \begin{tabular}{@{} l l l @{}}\toprule
    Variable  & Type & Description \\\midrule
     \hl{\texttt{Latt\%a1\_p}, \texttt{Latt\%a2\_p}}   & Real     & Unit vectors $\vec{a}_1$,  $\vec{a}_2$. \\ 
     \hl{\texttt{Latt\%L1\_p}, \texttt{Latt\%L2\_p}}   & Real     & Vectors $\vec{L}_1$, $\vec{L}_2$ that define the topology of the  lattice. \\
     									  &              &  Tilted lattices are  thereby possible to implement.  \\
    \hl{\texttt{Latt\%N}}                                                 &   Integer &  Number of lattice points, $N_{\text{unit-cell}}$.   \\
    \texttt{Latt\%list}                                               & Integer &  Maps each lattice point $i=1,\cdots, N_{\text{unit-cell}}$ to a real space vector\\ 
                                                                             &   &  denoting the position of the unit cell: \\
                                                                             &   & $\vec{R}_i$ = \texttt{list(i,1)}$\vec{a}_1$ + \texttt{list(i,2)}$\vec{a}_2$  $  \equiv i_1  \vec{a}_1 + i_2  \vec{a}_2 $. \\
    \texttt{Latt\%invlist}                                        &  Integer &   Return lattice point from position: \texttt{Invlist}$(i_1,i_2) = i $. \\
    \texttt{Latt\%nnlist}                                         &  Integer &  Nearest neighbor indices: $j = \texttt{nnlist} (i, n_1, n_2) $,  $n_1, n_2 \in [-1,1] $, \\
                                                                           &              &    $\vec{R}_j = \vec{R}_i + n_1 \vec{a}_1  + n_2 \vec{a}_2 $. \\
   \texttt{Latt\%imj}                                             &   Integer  &  $\vec{R}_{\mathrm{imj}(i,j)}  =  \vec{R}_i -  \vec{R}_j$, with  $\mathrm{imj}, i, j \in  1,\cdots, N_{\text{unit-cell}}$.\\
    \texttt{Latt\%BZ1\_p}, \texttt{Latt\%BZ2\_p}  &   Real     & Reciprocal space vectors $\vec{g}_i$   (See Eq.~\ref{Latt.G.eq}).\\
    \texttt{Latt\%b1\_p}, \texttt{Latt\%b1\_p}       &   Real     &  $k$-quantization (See Eq.~\ref{k.quant.eq}). \\
    \texttt{Latt\%listk}                                           &  Integer &  Maps each reciprocal lattice point $k=1,\cdots, N_{\text{unit-cell}}$\\
                                                                          &    & to a reciprocal space vector\\
                                                                          &     & $\vec{k}_k= \texttt{listk(k,1)} \vec{b}_1 +  \texttt{listk(k,2)} \vec{b}_2  \equiv k_1  \vec{b}_1 +   k_2  \vec{b}_2 $.\\
    \texttt{Latt\%invlistk}                                     &    Integer    &   \texttt{Invlistk}$(k_1,k_2) = k $. \\
   \texttt{Latt\%b1\_perp\_p},  \\ 
   \texttt{Latt\%b2\_perp\_p}                             &    Real         &  Orthonormal vectors to $\vec{b}_i$.  For internal use. \\\bottomrule
   \end{tabular}
   \caption{Components of the \texttt{Lattice} type for two-dimensional lattices using as example the default lattice name \texttt{Latt}.
   The \hl{highlighted} variables must be specified by the user.  Other components of the Lattice are generated upon calling: \texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt )}. 
    \label{table:lattice}}
\end{center}
\end{table}
%

The \path{Lattice} module also handles the Fourier transformation.  For example,  the  subroutine  \path{Fourier_R_to_K}   carries out the  transformation: 
\begin{equation}
	S(\vec{k}, :,:,:) =  \frac{1}{N_\text{unit-cell}}  \sum_{\vec{i},\vec{j}}   e^{-i \vec{k} \cdot \left( \vec{i}-\vec{j} \right)} S(\vec{i}  - \vec{j}, :,:,:)
\end{equation}
and  \path{Fourier_K_to_R}  the  inverse Fourier transform 
 \begin{equation}
	S(\vec{r}, :,:,:) =  \frac{1}{N_\text{unit-cell}}  \sum_{\vec{k} \in BZ }   e^{ i \vec{k} \cdot \vec{r}} S(\vec{k}, :,:,:).
\end{equation}
In the above,   the unspecified dimensions of  the structure factor can refer  to imaginary-time  and orbital indices. 

%\subsubsection{The \texttt{Unit\_cell} type}\label{sec:unit}
%This type defines the unit cell.   

\begin{table}[h]
	\begin{center}
   \begin{tabular}{@{} l l l @{}}\toprule
    Variable  & Type & Description \\\midrule
     \hl{\texttt{Norb}}   & Integer    & Number of orbitals.  \\
      \hl{\texttt{N\_coord}} & Integer & Coordination number.  \\
       \hl{\texttt{Orb\_pos(1..Norb,2) }} & Real & Positions of the orbitals as measured from the lattice site.  \\\bottomrule
   \end{tabular}
     \caption{Components of an instance \texttt{Latt\_unit} of the \texttt{Unit\_cell} type.
   The \hl{highlighted} variables have to be specified by the user. } 
    \label{table:unit_cell}
\end{center}
\end{table}


%--------------------------------------------------------------------------------------------
\subsubsection{Setting up the hopping matrix: the \texttt{Hopping\_Matrix\_type}}\label{sec:hopping_type}
%--------------------------------------------------------------------------------------------

The module \texttt{Predefined\_Hopping}   provides a   generic way to   specify a  hopping matrix on a  multi-orbital   Bravais lattice.  The only  assumption that we make is  translation symmetry.   We   allow  for twisted  boundary conditions in the $\vec{L}_1$ and $\vec{L}_2$ lattice directions. The twist is given by  \texttt{Phi\_X}  and \texttt{Phi\_Y}  respectively.  If the flag  \texttt{bulk=.true.}, then the twist is implemented with a vector potential. Otherwise, if  \texttt{bulk=.false.}, the twist is imposed at the boundary. The routine also accounts for  the inclusion of a  total number of \texttt{N\_Phi}  flux quanta traversing the lattice.  All phase factors mentioned above can be flavor dependent.   The checkerboard decomposition can also be specified in this module.      All information, including the checkerboard decomposition is specified in the  \path{Hopping_Matrix_type}   type (see below) from which  the array of  operator type \path{OP_T},   accounting for the single particle propagation in one time step,  as well as the Kinetic energy can be derived.    

\paragraph*{Generic hopping matrices}\label{sec:generic_hopping}
%-----------------------------------------------------------------------------------

\red{[Add an example.]}\\

The generic Hopping Hamiltonian  reads: 
\begin{equation}
\hat{H}_T = \sum_{(i,\delta), (j,\delta'), s, \sigma}    T_{(i,\delta), (j,\delta')}^{(s)}    c^{\dagger}_{(i,\delta),s,\sigma }   e^{\frac{2 \pi i}{\Phi_0} \int_{i + \delta}^{j + \delta'}  \vec{A}^{(s)}(\vec{l})  d \vec{l}} c^{}_{(j,\delta'),s,\sigma }
\end{equation}
with boundary conditions 
\begin{equation}
c^{\dagger}_{(i + L_i,\delta) ,s,\sigma }   =  e^{- 2 \pi i\frac{\Phi_i^{(s)}}{\Phi_0}} \, e^{\frac{2 \pi i }{\Phi_0} \chi^{(s)}_{L_1} ( i + \delta ) } \, c^{\dagger}_{(i,\delta) ,s,\sigma }.
\end{equation}
Both the twist and  vector  potential can have a flavor dependency. For now onwards we will  mostly omit the flavor index ${s}$.\\

\noindent
\textbf{Phase factors}.  
The vector potential accounts for an orbital magnetic field that is implemented  in the Landau  gauge:  $\vec{A}(\vec{x})  =  -B(y,0,0) $ with $ \vec{x} = (x,y,z)$. $\Phi_0$ corresponds to the flux  quanta and the scalar function $\chi$ is defined  through as:
\begin{equation}
\vec{A}( \vec{x} + \vec{L}_{i} )  = \vec{A}( \vec{x} )   +  \vec{\nabla} \chi_{L_{\alpha}}(\vec{x}). 
\end{equation}

Provided that the bare hopping Hamiltonian, $T$,  is invariant under lattice translations, $\hat{H}_T$ commutes with magnetic translations  that satisfy the  Algebra: 
\begin{equation}
\hat{T}_{\vec{a}} \hat{T}_{\vec{b}} =  e^{ \frac{2 \pi i}{\Phi_0}   \vec{B} \cdot \left( \vec{a} \times \vec{b} \right) }  \hat{T}_{\vec{b}} \hat{T}_{\vec{a}}. 
\end{equation}
On the  torus, the uniqueness of the wave functions requires that  $\hat{T}_{\vec{L}_1} \hat{T}_{\vec{L}_2}  =   \hat{T}_{\vec{L}_2} \hat{T}_{\vec{L}_1} $ such
that
\begin{equation}
\frac{\vec{B} \cdot \left( \vec{a} \times \vec{b}  \right) }{\Phi_0 } = N_{\Phi}   
\end{equation}
with  $N_\Phi $ an integer.  The variable \texttt{N\_Phi},   specified in the parameter file,   denotes the number of flux quanta piercing the lattice.    The variables \texttt{Phi\_X}  and   \texttt{Phi\_Y} also   in the parameter file denote  the twists  -- in units of the flux quanta  --  along the $\vec{L}_1$ and  $\vec{L}_2$ directions.     There are gauge  equivalent ways to insert the  twist in the boundary conditions. In the above we  have inserted   twist as a boundary condition such  that for example setting  \texttt{Phi\_1=0.5}  corresponds to anti-periodic boundary conditions along the $L_1$  axis.   Alternatively we  can  consider the 
Hamiltonian:
\begin{equation}
\hat{H}_T = \sum_{(i,\delta), (j,\delta'), s, \sigma}    T_{(i,\delta), (j,\delta')}^{(s)}    \tilde{c}^{\dagger}_{(i,\delta),s,\sigma }   e^{\frac{2 \pi i}{\Phi_0} \int_{i + \delta}^{j + \delta'} \left(  \vec{A}(\vec{l})  + \vec{A}_{\phi} \right)  d \vec{l}} \tilde{c}^{}_{(j,\delta'),s,\sigma }
\end{equation}
with boundary conditions 
\begin{equation}
\tilde{c}^{\dagger}_{(i + L_i,\delta) ,s,\sigma }   =  e^{\frac{2 \pi i }{\Phi_0} \chi_{L_1} ( i + \delta ) } \, \tilde{c}^{\dagger}_{(i,\delta) ,s,\sigma }.
\end{equation}
Here 
\begin{equation}
\vec{A}_{\phi} =\frac{  \phi_1  |\vec{a}_1|} { 2 \pi |\vec{L}_1| } \vec{b}_1 +  \frac{  \phi_2  |\vec{a}_2|}{2 \pi  |\vec{L}_2| } \vec{b}_2
\end{equation}
and $\vec{b}_i$  correspond to the reciprocal lattice vectors satisfying  $ \vec{a}_i  \cdot  \vec{b}_j  = 2 \pi \delta_{i,j} $.   The logical variable $\texttt{bulk} $ chooses between these two  gauge equivalent ways  of inserting the twist angle. If \texttt{bulk=\.true\.}    then  we use periodic boundary conditions  --  in the absence of an orbital field -- otherwise  twisted boundaries are used.  
The above phase factors are computed  in the   module function: 
\begin{lstlisting}[style=fortran]
complex function Generic_hopping(i,no_i, n_1, n_2, no_j, N_Phi, Phi_1,Phi_2, Bulk, 
Latt, Latt_Unit)
\end{lstlisting}
that  returns the  phase factor involved in the hopping of a hole from lattice site $ \ve{i} + \ve{\delta}_{\text{no}_i} $ to 
$\ve{i} + n_1 \ve{a}_1 + n_1 \ve{a}_2+ \ve{\delta}_{\text{no}_j}  $.  Here  $\ve{\delta}_{\text{no}_i}$  is  the position of the $\text{no}_i$  orbital in the unit cell
$\ve{i}$. 
As  we will see below, the information for the phases is encoded in  the type \texttt{Hopping\_matrix\_type}.\\

\noindent
\textbf{The  Hopping matrix elements}. 
The hopping matrix  is specified assuming only translation invariance.  (The point group symmetry of the lattice can be broken).    That is, we assume that  for  each flavor index: 
\begin{equation} 
T_{(\ve{i},\ve{\delta}), (\ve{i} +  n_1\vec{a}_1  + n_2 \vec{a}_2,\ve{\delta}')}^{(s)}   =   T^{(s)}_{(\ve{0},\ve{\delta}),  (n_1\vec{a}_1  + n_2 \vec{a}_2,\ve{\delta}') }.
\label{Hop.eq}	 
\end{equation}
The right  hand side of the above equation is given  the type  \texttt{Hopping\_matrix\_type}.\\


\noindent
\textbf{The checkerboard decomposition.}   Aside from the hopping phases and hopping matrix elements, the \texttt{Hopping\_matrix\_type} type, contains information  concerning the checkerboard   decomposition.  In Eq.~\ref{Checkerboard.Eq} we wrote the hopping Hamiltonian as:
\begin{equation}
\hat{\mathcal{H}}_{T}     = \sum_{i=1}^{N_T} \sum_{k \in \mathcal{S}^{T}_i} \hat{T}^{(k)},  
\end{equation}
with the rule that  if $k$ and $k'$  belong to the same set $\mathcal{S}^{T}_i $ then   $ \left[ \hat{T}^{(k)} , \hat{T}^{(k')} \right] = 0 $.  In the checkerboard decomposition, $\hat{T}^{(k)}$   corresponds to  hopping on a bond.    The checkerboard decomposition depends on the   lattice type, as well as on the hopping matrix elements.   The required  information is stored in  \texttt{Hopping\_matrix\_type}. In this data type,  \texttt{N\_FAM}  corresponds to the number of sets  ($N_T$ in the above equation). \texttt{L\_FAM(1:N\_FAM)}   corresponds to the number of bonds in the set,  and finally,  \texttt{LIST\_FAM(1:N\_FAM, 1:max(L\_FAM(:)), 2)}    contains  information concerning the two legs of the bonds.    In the checkerboard decomposition, care has to be taken for local terms: each site  occurs multiple times in the list of bonds.    Since we have postulated translation symmetry,    a one-dimensional array, \texttt{Multiplicity},  of length  given by  the number of orbitals per unit cell suffices to  encode the required information.  
Finally, to be able to generate  the imaginary time step of length $\Delta \tau$  we  have to know   by which fraction of  $\Delta \tau$   we have to propagate each set.  This information is given in  the array  \texttt{Prop\_Fam}.  



\paragraph*{Usage: the \texttt{Hopping\_Matrix\_type} } %\label{Hopping_Matrix_type.sec} 

There are  \path{N_bonds}   hopping   matrix  elements  emanating  from  a  given unit  cell. For  each bond,  the array 
\texttt{List}   contains the full  information to define the  RHS of Eq.~\eqref{Hop.eq}.    The hopping amplitudes are  stored in the  array  \texttt{T}  and the local potentials in the  array \texttt{T\_loc}   (See  Table~\ref{table:Hopping_matrix}).    The  \texttt{Hopping\_Matrix\_type}   type    also contains the information for the  checkerboard   decomposition.

\begin{table}[h]
	\begin{center}
		%    \begin{tabular}{@{} l l l @{}}\toprule
		\begin{tabular}{@{} p{0.28\columnwidth} @{} p{0.08\columnwidth} p{0.61\columnwidth} @{}}\toprule
			Variable & Type & Description \\\midrule
			\texttt{N\_bonds}  &  Integer  &      Number of  hopping  matrix elements emanating from a unit cell   \\
			\texttt{List(N\_bonds,4)}    & Integer &  List($\bullet$,1) =   $\delta$ \\
			&              &  List($\bullet$,2) =   $\delta'$ \\
			&              &  List($\bullet$,3) =   $n_1$     \\
			&              &  List($\bullet$,4) =   $n_2$     \\ 
			\texttt{T(N\_bonds)}          & Complex &   Hopping amplitude   \\
			\texttt{T\_loc(Norb)}           & Complex &    On site  potentials (e.g., chemical potential, Zeeman field)   \\
			\texttt{N\_Phi}                    & Integer     &  Number of  flux quanta piercing the lattice   \\
			\texttt{Phi\_X}                    &  Real        &   Twist in $\ve{a}_1$  direction   \\
			\texttt{Phi\_Y}                    &  Real        &   Twist in $\ve{a}_2$  direction   \\
			\texttt{Bulk}                        &   Logical   &   Twist as vector potential (T) or  boundary condition (F).
			\\  \\
			\texttt{N\_Fam}                &  Integer  &      Number of  sets, $N_T$ in Eq.~\eqref{Checkerboard.Eq}   \\
			\texttt{L\_Fam(N\_FAM)}  &  Integer &     Number of bonds per set $\mathcal{S}^{T}$ \\    
			\texttt{List\_Fam(N\_FAM,L\_FAM,2)}     &  Integer  &   \texttt{List Fam($ \bullet,\bullet $,1)} =  Unit cell \\
			&                        &          \texttt{List Fam($\bullet,\bullet$,2)} =   Bond number \\
			\texttt{Multiplicity(Norb)} & Integer           &        Number of  times a  given orbital  occurs in the list of bonds  \\
			\texttt{Prop\_Fam} &  Real            &         The fraction of $ \Delta \tau $   with which the set will be propagated   \                                
			\\\bottomrule
		\end{tabular}
		\caption{Member variables of the \texttt{Hopping\_Matrix\_type}  type.   
			\label{table:Hopping_matrix}}
	\end{center}
\end{table}

The  data in the \texttt{Hopping\_matrix\_type} type suffices to uniquely define the  unit step propagation for the kinetic energy, and for  any combinations of the  \texttt{Checkerboard} and  \texttt{Symm}  options (see Sec.~\ref{sec:trotter}).   This is carried  by the call: 
\begin{lstlisting}[style=fortran]
Call Predefined_Hoppings_set_OPT(Hopping_Matrix, List, Invlist, Latt, Latt_unit, Dtau,
Checkerboard, Symm, OP_T)
\end{lstlisting}
in which  the  operator   array  \path{OP_T(*,N_FL )}   is  allocated and defined.    In the simplest  case, where no  checkerboard is  used, the  first dimension  is  unity. 

The   data in  the \texttt{Hopping\_matrix\_type} type   equally  suffices to compute  the kinetic energy.  This is carried out in the routine \texttt{Predefined\_Hoppings\_Compute\_Kin}.




%--------------------------------------------------------------------------------------------
\subsection{The observable types \texttt{Obser\_Vec} and \texttt{Obser\_Latt}}\label{sec:obs}
%--------------------------------------------------------------------------------------------

Our definition  of the model includes observables [Eq.~(\ref{eqn:obs_rw})]. We have defined two observable types: \texttt{Obser\_vec}  for an array of \emph{scalar} observables
such as the energy, and  \texttt{Obser\_Latt}   for correlation functions that have the lattice symmetry. In the latter case, translation symmetry can be used to provide improved estimators and to reduce the size of the output.   
We also obtain improved estimators by taking measurements in the imaginary-time interval $[\texttt{LOBS\_ST},\texttt{LOBS\_EN\texttt{}}]$ (see the parameter file in Sec.~\ref{sec:input}) thereby exploiting the invariance under translation in imaginary-time.
Note that the translation symmetries  in space and in time are \emph{broken} for a given  configuration $C$ but restored by the Monte Carlo sampling. 
In general, the user defines size and number of bins in the parameter file, each bin containing a given amount of sweeps. Within a sweep we run sequentially through the HS and Ising fields, from time slice $1$ to time slice $L_{\text{Trotter}}$ and back.  The results of each bin are written to a file  and analyzed at the end of the run.     

To accomplish the reweighting of observables (see Sec.~\ref{sec:reweight}), for each configuration the measured value of an observable is multiplied by the factors \texttt{ZS} and \texttt{ZP}:
\begin{align}
\texttt{ZS} &= \text{sign}(C)\;, \\
\texttt{ZP} &= \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}\;.
\end{align}
They are computed from the Monte Carlo phase of a configuration,
\begin{equation}\label{eqn:phase}
	\texttt{phase}   =   \frac{e^{-S(C)}}{ \left| e^{-S(C) }\right| }\;,
\end{equation}
which is provided by the main program.
Note that each observable structure also includes the average sign [Eq.~(\ref{eqn:sign_rw})].

%---------------------------------
\subsubsection{Scalar observables}
%---------------------------------

Scalar observables are stored in the data type \texttt{Obser\_vec}, described in Table \ref{table:Obser_vec}. Consider  a variable \texttt{Obs} of type  \texttt{Obser\_vec}.  At the beginning of each bin,  a call to  \texttt{Obser\_Vec\_Init} in the module \texttt{observables\_mod.F90}  will  set   \texttt{Obs\%N=0},   \texttt{Obs\%Ave\_sign=0}  and  \texttt{Obs\%Obs\_vec(:)=0}.  Each time the main  program calls the routine \texttt{Obser}  in the  \texttt{Hamiltonian} module,  the counter \texttt{Obs\%N}   is incremented by one, the sign  (see Eq.~\ref{Sign.eq}) is accumulated in the  variable \texttt{Obs\%Ave\_sign},  and the desired observables (multiplied by the sign and   $\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}$, see Sec.~\ref{Observables.General})  are accumulated in the vector \texttt{Obs\%Obs\_vec}.  
%
\begin{table}[h]
	\begin{center}
   \begin{tabular}{@{} l l l l @{}}\toprule
    Variable  &  Type      &  Description &  Contribution of configuration $C$ \\\midrule
    \texttt{Obs\%N}                       &  Int.       &    Number of measurements &    $+1$ \\
    \texttt{Obs\%Ave\_sign}               &  Real     	&    Cumulated average sign [Eq.~\eqref{eqn:sign_rw}] & $\text{sign}(C)$  \\
    \texttt{Obs\%Obs\_vec(:)}  		      &  Comp.      &    Cumul. vector of observables [Eq.~\eqref{eqn:obs_rw}] &
           $ \langle \langle \hat{O}(:) \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]} \text{ sign }(C) $ \\
     \texttt{Obs\%File\_Vec}           &  Char.    &    Name of output file  &\\\bottomrule
   \end{tabular}
   \caption{Components of a variable of type \texttt{Obser\_vec} named \texttt{Obs}.}
   % \mycomment{MB $\texttt{Obs\%Phase}$ is not $phase(C)$ but $sign(C)$. And the type of sign could in principle be reduced to integer.   }
         \label{table:Obser_vec}
     \end{center}
\end{table}
%
At the end of the bin, a call to  \texttt{Print\_bin\_Vec}   in  module \texttt{observables\_mod.F90}  will  append the result of the bin in the file  \texttt{File\_Vec}\emph{\_scal}.  Note that this subroutine will automatically append the suffix \emph{\_scal}
to the the filename \texttt{File\_Vec}.
This suffix  is important to allow automatic analysis of the data at the end of the run. 

%------------------------------------------------------------
\subsubsection{ Equal-time and time-displaced correlation functions}
%------------------------------------------------------------

The data type \texttt{Obser\_latt} (see Table~\ref{table:Obser_latt}) is useful for dealing with both equal-time and imaginary-time-displaced correlation functions of the form: 
\begin{align}\label{eqn:s}
	S_{\alpha,\beta}(\vec{k},\tau) =   \frac{1}{N_{\text{unit-cell}}} \sum_{\vec{i},\vec{j}}  e^{-i \vec{k} \cdot \left( \vec{i}-\vec{j}\right) } \left( \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle  - 
	  \langle \hat{O}_{\vec{i},\alpha} \rangle \langle   \hat{O}_{\vec{j},\beta}  \rangle \right),
\end{align}
where $\alpha$ and $\beta$ are orbital indices and $\vec{i}$ and $\vec{j}$ lattice positions.
%
\begin{table}[h]
	\begin{center}
	\begin{tabular}{@{} l l l l @{}}\toprule
		Variable  &  Type      &  Description &  Contribution of configuration $C$ \\\midrule
		\texttt{Obs\%N}                       &  Int.        &   Number of measurements &    $+1$\\
		\texttt{Obs\%Ave\_sign}  
		&  Real  &    Cumulated sign [Eq.~(\ref{eqn:sign_rw})] & $\text{sign}(C)$  \\
		\texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},$}        & Compl.      &    Cumul.  correl. funct. [Eq.~(\ref{eqn:obs_rw})] &  $ \langle \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle \rangle_{C} \; \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{sign}(C) $ \vspace{-4pt} \\
		\hfill \texttt{$\tau,\alpha,\beta$)} & & & \\
		\texttt{Obs\%Obs\_latt0($\alpha$)}        & Compl.      &    Cumul. expect. value [Eq.~(\ref{eqn:obs_rw})] &   $ \langle \langle \hat{O}_{\vec{i},\alpha} \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{ sign }(C) $ \\
		\texttt{Obs\%File\_Latt}           &  Char.    &    Name of output file  &\\\bottomrule
	\end{tabular}
	\caption{Components of a variable of type \texttt{Obser\_latt} named \texttt{Obs}.}
	\label{table:Obser_latt}
\end{center}
\end{table}
%
Here,  translation symmetry of the Bravais lattice is explicitly taken into account. 
The correlation function splits in a correlated part $S_{\alpha,\beta}^{\mathrm{(corr)}}(\vec{k},\tau)$ and a background part $S_{\alpha,\beta}^{\mathrm{(back)}}(\vec{k})$:
\begin{align}
S_{\alpha,\beta}^{\mathrm{(corr)}}(\vec{k},\tau)
&=
\frac{1}{N_{\text{unit-cell}}} \sum_{\vec{i},\vec{j}}  e^{- i\vec{k} \cdot \left( \vec{i}-\vec{j}\right) }  \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle \label{eqn:s_corr} \;,\\
\begin{split}
S_{\alpha,\beta}^{\mathrm{(back)}}(\vec{k})
&=
\frac{1}{N_{\text{unit-cell}}} \sum_{\vec{i},\vec{j}}  e^{- i\vec{k} \cdot \left( \vec{i}-\vec{j}\right) }  \langle \hat{O}_{\vec{i},\alpha} (\tau)\rangle \langle \hat{O}_{\vec{j},\beta} \rangle\\
&=
N_{\text{unit-cell}}\, \langle \hat{O}_{\alpha} \rangle \langle \hat{O}_{\beta} \rangle \, \delta(\vec{k}) \label{eqn:s_back}\;,
\end{split}
\end{align}
where translation invariance in space and time has been exploited to obtain the last line. 
The background part depends only on the expectation value $\langle \hat{O}_{\alpha} \rangle$, for which we use the following estimator 
\begin{equation}\label{eqn:o}
\langle \hat{O}_{\alpha} \rangle \equiv \frac{1}{N_{\text{unit-cell}}} \sum\limits_{\vec{i}} \langle \hat{O}_{\vec{i},\alpha} \rangle\;.
\end{equation}
Consider a variable  \texttt{Obs} of type  \texttt{Obser\_latt}. At the beginning of each bin a call to  \texttt{Obser\_Latt\_Init} in the module \texttt{observables\_mod.F90}  will  initialize  the elements of \texttt{Obs} to zero.    Each time the main program calls the   \texttt{Obser} or  \texttt{ObserT} routines one accumulates $ \langle \langle \hat{O}_{\vec{i},\alpha} (\tau) \hat{O}_{\vec{j},\beta} \rangle \rangle_{C} \; \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{sign}(C) $    in  \texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},\tau,\alpha,\beta$)}   
and $ \langle \langle \hat{O}_{\vec{i},\alpha} \rangle \rangle_{C}\frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}  \text{ sign }(C) $  in \texttt{Obs\%Obs\_latt0($\alpha$)}.   At the end of each bin, a call to \texttt{Print\_bin\_Latt} in the module  \texttt{observables\_mod.F90}   will append the result of the bin in the specified  file \texttt{Obs\%File\_Latt}.   Note that the routine  \texttt{Print\_bin\_Latt}  carries out the Fourier transformation and prints the results in $k$-space. 
We have adopted the following naming conventions.
For equal-time observables, defined by having the second dimension of the array  \texttt{Obs\%Obs\_latt($\vec{i}-\vec{j},\tau,\alpha,\beta$)}   set to unity, 
the routine \texttt{Print\_bin\_Latt}  attaches the suffix \emph{\_eq} to \texttt{Obs\%File\_Latt}.  For time-displaced correlation functions we use the suffix \emph{\_tau}.

