% Copyright (c) 2016-2022 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex

All the data structures necessary to implement a given model have been introduced in the previous sections. Here we show how to implement a new model based on the example of the Hubbard model.

As stated in Sec. \ref{sec:hamiltonian}, for defining a new Hamiltonian calle \emph{New\_model} one needs to 
\begin{enumerate}
\item Add a new line containing \emph{New\_model} to the file \path{Prog/Hamiltonians.list}
\item Write the corresponding new submodule in \texttt{Prog/Hamiltonians/Hamiltonian\_\emph{New\_model}\_smod.F90}
\end{enumerate}
Here our \emph{New\_model} will be \path{Hubbard_Plain_Vanilla}. There is a template \path{Prog/Hamiltonians/Hamiltonian_##NAME##_smod.F90} that can be used for creating a new model.

To get a valid Hamiltonian, one has to specify its parameters, the lattice, the hopping, the interaction, the trial wave function  (if  required), and the observables.  Consider  the  \textit{plain vanilla}  Hubbard model  written as: 
\begin{equation}
\label{eqn_hubbard_Mz}
\mathcal{H}=
- t 
\sum\limits_{\langle \ve{i}, \ve{j} \rangle,  \sigma={\uparrow,\downarrow}} 
  \left(  \hat{c}^{\dagger}_{\ve{i}, \sigma} \hat{c}^{\phantom\dagger}_{\ve{j},\sigma}  + \hc \right) 
- \frac{U}{2}\sum\limits_{\ve{i}}\left[
\hat{c}^{\dagger}_{\ve{i}, \uparrow} \hat{c}^{\phantom\dagger}_{\ve{i}, \uparrow}  -   \hat{c}^{\dagger}_{\ve{i}, \downarrow} \hat{c}^{\phantom\dagger}_{\ve{i}, \downarrow}  \right]^{2}   
-  \mu \sum_{\ve{i},\sigma } \hat{c}^{\dagger}_{\ve{i}, \sigma}  \hat{c}^{\phantom\dagger}_{\ve{i},\sigma}. 
\end{equation} 
Here $ \langle \ve{i}, \ve{j} \rangle $    denotes nearest neighbors. 
We can make contact with the general form of the Hamiltonian  [see Eq.~\eqref{eqn:general_ham}] by setting: 
$N_{\mathrm{fl}} = 2$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =1 $, 
 $M_T    =    1$, 
 \begin{equation}
  T^{(ks)}_{x y}   = 
  \left\{ 
 \begin{array}{ll}
       -t         & \text{if } x,y \text{ are nearest neighbors} \\
       -\mu    & \text{if } x = y \\
       0         &  \text{otherwise},
 \end{array}
  \right.
 \end{equation}
 $M_V   =  N_{\text{unit-cell}} $,  $U_{k}       =   \frac{U}{2}$, 
 $V_{x y}^{(k, s=1)} =  \delta_{x,y} \delta_{x,k}  $,  $V_{x y}^{(k, s=2)} =  - \delta_{x,y} \delta_{x,k}  $,  $\alpha_{ks}   = 0  $ and $M_I       = 0 $.   
The coupling of the HS fields to the $z$-component of the magnetization breaks the SU(2) spin symmetry. Nevertheless, the $z$-component of the spin remains a good quantum number such that the imaginary-time propagator -- for a given HS field -- is block  diagonal in this quantum number. This corresponds to the flavor index running from $1$ to $2$,  labeling spin up and spin down degrees of freedom. We note that  in this formulation the  hopping matrix can be flavor dependent such that a Zeeman  magnetic field can be introduced.  If the chemical potential is set to zero, this will not generate a negative sign problem \cite{Wu04,Milat04,Bercx09}.    
The code that we describe below  can be found in the submodule \path{Prog/Hamiltonians/Hamiltonian_Hubbard_Plain_Vanilla_smod.F90}.

%------------------------------------------------------------
\subsection{Defining the parameters}
%------------------------------------------------------------
Defining the parameters as specified in Sec. \ref{sec:hamiltonian}, we arrive at:

\begin{lstlisting}[style=fortran]
!#PARAMETERS START# VAR_lattice
Character (len=64) :: Model = ''  ! Value irrelevant
Character (len=64) :: Lattice_type = 'Square'  ! Possible Values: 'Square'
Integer            :: L1 = 4   ! Length in direction a_1
Integer            :: L2 = 4   ! Length in direction a_2
!#PARAMETERS END#

!#PARAMETERS START# VAR_Hubbard_Plain_Vanilla
!Integer              :: N_SUN = 2
real(Kind=Kind(0.d0)) :: ham_T    = 1.d0     ! Hopping parameter
real(Kind=Kind(0.d0)) :: Ham_chem = 0.d0     ! Chemical potential
real(Kind=Kind(0.d0)) :: Ham_U    = 4.d0     ! Hubbard interaction
real(Kind=Kind(0.d0)) :: Dtau     = 0.1d0    ! Thereby Ltrot=Beta/dtau
real(Kind=Kind(0.d0)) :: Beta     = 5.d0     ! Inverse temperature
!logical              :: Projector = .false. ! Whether the projective algorithm is used
real(Kind=Kind(0.d0)) :: Theta    = 5.d0     ! Projection parameter
!logical              :: Symm = .false.      ! Whether symmetrization takes place
Integer               :: N_part   = -1       ! Number of particles in trial wave function.
                                             ! If N_part < 0 -> N_part = L1*L2/2
!#PARAMETERS END#
\end{lstlisting}
We can test the correct formatting of the parameters by calling:
\begin{lstlisting}[style=bash]
../parse_ham.py --test_file Hamiltonian_Hubbard_Plain_Vanilla_smod.F90
\end{lstlisting}

%------------------------------------------------------------
\subsection{Setting the Hamiltonian:  \texttt{Ham\_set} }
%------------------------------------------------------------

The main program will call the subroutine \texttt{Ham\_set} in the submodule \path{Hamiltonian_Hubbard_Plain_Vanilla_smod.F90}
which specify the model.  The  routine \texttt{Ham\_set}  will first  read the parameter file \texttt{parameters} (see Sec.~\ref{sec:input}) \texttt{Call read\_parameters}; then set the lattice: \texttt{Call Ham\_latt};  set the hopping: \texttt{Call Ham\_hop};  
 set the interaction: \texttt{call Ham\_V}; and if required, set the trial wave function: \texttt{call Ham\_trial}.     In the  subroutine   \texttt{Ham\_set} one  
 will equally  have  to  specify  if  a  symmetry  relates   different  flavors.   This functionality  is   described in  Sec.~\ref{sec:flavor_sym}   and   one  enables it  by allocating  tine  array  \texttt{Calc\_Fl}. 
 
%------------------------------------------------------------
\subsection{The lattice: \texttt{Ham\_latt}} \label{U_PV_Ham_latt}
%------------------------------------------------------------

The routine, which sets the square lattice, reads:
\begin{lstlisting}[style=fortran]
a1_p(1) = 1.0  ; a1_p(2) = 0.d0
a2_p(1) = 0.0  ; a2_p(2) = 1.d0
L1_p    = dble(L1)*a1_p
L2_p    = dble(L2)*a2_p
Call Make_Lattice(L1_p, L2_p, a1_p, a2_p, Latt)
Latt_unit%Norb = 1
Latt_unit%N_coord = 2
allocate(Latt_unit%Orb_pos_p(Latt_unit%Norb,2))
Latt_unit%Orb_pos_p(1, :) = [0.d0, 0.d0]
Ndim = Latt%N*Latt_unit\%Norb

\end{lstlisting}
In its last line, the routine sets the total number of single particle states per flavor and color:
\texttt{Ndim = Latt\%N*Latt\_unit\%Norb}.

%------------------------------------------------------------
\subsection{The hopping: \texttt{Ham\_hop}} \label{U_PV_Ham_hop}
%------------------------------------------------------------

The hopping matrix is implemented as follows.
We allocate an array of dimension $1\times N_{\mathrm{fl}}$ of type operator  called \texttt{Op\_T} and set the  dimension for the hopping  matrix to $N=N_{\mathrm{dim}}$. The operator allocation and initialization is performed by the subroutine \texttt{Op\_make}:
\begin{lstlisting}[style=fortran]
do nf = 1,N_FL
   call Op_make(Op_T(1,nf),Ndim)
enddo
\end{lstlisting}
Since the hopping  does not  break down into small blocks, we have ${\bm P}=\mathds{1}$   and  
\begin{lstlisting}[style=fortran]
Do nf = 1, N_FL
  Do i = 1,Latt%N
     Op_T(1,nf)%P(i) = i
  Enddo
Enddo
\end{lstlisting}
We set the hopping matrix  with 
\begin{lstlisting}[style=fortran]
Do nf = 1, N_FL
   Do I = 1, Latt%N
      Ix = Latt%nnlist(I,1,0)
      Iy = Latt%nnlist(I,0,1)
      Op_T(1,nf)%O(I,  Ix) = cmplx(-Ham_T,    0.d0, kind(0.D0))
      Op_T(1,nf)%O(Ix, I ) = cmplx(-Ham_T,    0.d0, kind(0.D0))
      Op_T(1,nf)%O(I,  Iy) = cmplx(-Ham_T,    0.d0, kind(0.D0))
      Op_T(1,nf)%O(Iy, I ) = cmplx(-Ham_T,    0.d0, kind(0.D0))
      Op_T(1,nf)%O(I,  I ) = cmplx(-Ham_chem, 0.d0, kind(0.D0))
   Enddo
   Op_T(1,nf)%g     = -Dtau
   Op_T(1,nf)%alpha = cmplx(0.d0,0.d0, kind(0.D0))
   Call Op_set(Op_T(1,nf))
Enddo
\end{lstlisting}
Here, the integer function \texttt{Latt\%nnlist(I,n,m)} is defined in the lattice module and returns the index of the lattice site $ \vec{I} +  n \vec{a}_1 +  m \vec{a}_2$.
Note that periodic boundary conditions are 
already taken into account.  The hopping parameter \texttt{Ham\_T}, as well as the chemical potential \texttt{Ham\_chem} are read from the parameter file.  
To completely define the hopping  we further set: \texttt{Op\_T(1,nf)\%g = -Dtau }, \texttt{Op\_T(1,nf)\%alpha = cmplx(0.d0,0.d0, kind(0.D0))} and call the routine  \texttt{Op\_set(Op\_T(1,nf))}  so as to generate  the unitary transformation and eigenvalues as specified in Table \ref{table:operator}.  Recall that for the hopping, the variable  \texttt{Op\_set(Op\_T(1,nf))\%type}  takes its default value of 0.  
Finally, note that, although a checkerboard decomposition is not used here, it can be implemented by considering a larger number of sparse hopping matrices.  


%------------------------------------------------------------
\subsection{The interaction: \texttt{Ham\_V}}\label{U_PV_Ham_V} 
%------------------------------------------------------------
To implement  the interaction, we allocate an array of \texttt{Operator} type. The array is called  \texttt{Op\_V} and has dimensions $N_{\mathrm{dim}}\times N_{\mathrm{fl}}=N_{\mathrm{dim}} \times 2$. 
We set the dimension for the interaction term to  $N=1$, and  allocate and initialize this array of type  \texttt{Operator} by repeatedly calling the subroutine \texttt{Op\_make}: 

\begin{lstlisting}[style=fortran]
Allocate(Op_V(Ndim,N_FL))
do nf = 1,N_FL
   do i  = 1, Ndim
      Call Op_make(Op_V(i,nf), 1)
   enddo
enddo
Do nf = 1,N_FL
   X = 1.d0
   if (nf == 2)  X = -1.d0
   Do i = 1,Ndim
      nc = nc + 1
      Op_V(i,nf)%P(1)   = i
      Op_V(i,nf)%O(1,1) = cmplx(1.d0, 0.d0, kind(0.D0))
      Op_V(i,nf)%g      = X*SQRT(CMPLX(DTAU*ham_U/2.d0, 0.D0, kind(0.D0))) 
      Op_V(i,nf)%alpha  = cmplx(-0.5d0, 0.d0, kind(0.D0))
      Op_V(i,nf)%type   = 2
      Call Op_set( Op_V(i,nf) )
   Enddo
Enddo
\end{lstlisting}
The code above makes it explicit that there is a sign difference between the coupling of the HS field in the two flavor sectors.        Hence,  
\texttt{Op\_V(i,nf)}     encodes    $ e^{  X \sqrt{\Delta   \tau U/2} \left( \hat{c}^{\dagger}_{\ve{i},{\texttt{nf}}}  \hat{c}^{\phantom\dagger}_{\ve{i},{\texttt{nf}}}  + \alpha  \right) }  $    with  $X=1 $  for  $\texttt{nf}=1$  and $X=-1 $  for  $\texttt{nf}=2$.    Strictly  speaking  $X$  can  be  omitted.  However,  it  is  required  when  using the  flavor  symmetry  option in the presence  of  particle-hole  symmetry (see  Sec.~\ref{sec:flavor_sym}). 


%------------------------------------------------------------
\subsection{The trial wave function: \texttt{Ham\_Trial}} \label{U_PV_Ham_Trial}
%------------------------------------------------------------
\label{Sec:Plain_vanilla_trial}
As  argued in Sec.~\ref{sec:trial_wave_function}, it is useful to generate the trial wave function from a non-interacting trial Hamiltonian.   Here we will  use the same left and right  flavor-independent trial wave functions that correspond to the ground state of: 
\begin{equation}
   \hat{H}_T    = - t \sum_{\ve{i}} \left[  \left( 1 + (-1)^{i_x + i_y}  \delta \right)  \hat{c}^{\dagger}_{\ve{i}}   \hat{c}^{\phantom\dagger}_{\ve{i} +\ve{a}_x}  +  
   							\left(1 - \delta \right)  \hat{c}^{\dagger}_{\ve{i}}   \hat{c}^{\phantom\dagger}_{\ve{i} +\ve{a}_y}    + \hc  \right]   \equiv   \sum_{\ve{i},\ve{j}}  \hat{c}^{\dagger}_{\ve{i}}   h_{\ve{i},\ve{j}}  \hat{c}^{\phantom\dagger}_{\ve{i}}.
\end{equation}
For the half-filled case, the  dimerization $\delta  = 0^{+} $  opens up a gap at  half-filling,   thus generating the desired  non-degenerate  trial wave function  that has the same symmetries (particle-hole  for instance) as  the   trial  Hamiltonian.

Diagonalization  of  $ h_{\ve{i},\ve{j}}$,      $U^{\dagger} h  U  = \mathrm{Diag} \left(   \epsilon_1, \cdots, \epsilon_{N_{\mathrm{dim}}} \right) $     with  $\epsilon_i  <  \epsilon_j $  for $i < j$, allows us  to define the  trial wave function.  In particular, for the half-filled case, we set 
\begin{lstlisting}[style=fortran,escapechar=\#]
Do s = 1, N_fl
   Do x = 1,Ndim
      Do n = 1, N_part
         WF_L(s)%P(x,n)  = # $U_{x,n}$ #
         WF_R(s)%P(x,n)  = # $U_{x,n}$ #
      Enddo
   Enddo
Enddo
\end{lstlisting}
with \texttt{N\_part = Ndim/2}.     The  variable \texttt{Degen}   belonging to the \texttt{WaveFunction}  type  is given by  \texttt{Degen}$=\epsilon_{N_{\mathrm{Part}} +1 } - \epsilon_{N_{\mathrm{Part}}  }$.   This quantity should be greater than zero  for non-degenerate trial wave functions. 

%------------------------------------------------------------
\subsection{Observables}
%------------------------------------------------------------

At this point, all the information for starting the simulation has been provided.  The code will sequentially go through  the operator list  \texttt{Op\_V}  and update the  fields.  Between  time slices  \texttt{LOBS\_ST}  and  \texttt{LOBS\_EN} the main program will call the routine  \texttt{Obser(GR,Phase,Ntau)}, which handles equal-time correlation functions, and, if \texttt{Ltau=1}, the routine \texttt{ObserT(NT,  GT0,G0T,G00,GTT, PHASE)} which handles imaginary-time displaced correlation functions. 

Both \texttt{Obser} and \texttt{ObserT} should be provided by the user, who can either implement themselves the observables they want to compute or use the predefined structures of Chap.~\ref{Predefined_chap}. Here we describe how to proceed in order to define an observable. 

%------------------------------------------------------------------------------------
\subsubsection[Allocating space for the observables: \texttt{Alloc\_obs}]{Allocating space for the observables: \texttt{Alloc\_obs(Ltau)}} \label{Alloc_obs_sec}
%-------------------------------------------------------------------------------------

For  four scalar  or vector observables,  the user will have to  declare the following: 
\begin{lstlisting}[style=fortran]
Allocate ( Obs_scal(4) )
Do I = 1,Size(Obs_scal,1)
   select case (I)
   case (1)
      N = 2;  Filename ="Kin"
   case (2)
      N = 1;  Filename ="Pot"
   case (3)
      N = 1;  Filename ="Part"
   case (4)
      N = 1,  Filename ="Ener"
   case default
      Write(6,*) ' Error in Alloc_obs '  
   end select
   Call Obser_Vec_make(Obs_scal(I), N, Filename)
enddo
\end{lstlisting}
Here,   \texttt{Obs\_scal(1)}   contains a vector  of two observables  so as to account for the $x$- and $y$-components of the kinetic energy, for example.  

For equal-time correlation functions  we allocate  \texttt{Obs\_eq}  of type \texttt{Obser\_Latt}.  Here we include the calculation of spin-spin and density-density correlation functions alongside equal-time Green functions. 
\begin{lstlisting}[style=fortran]
Allocate ( Obs_eq(5) )
Do I = 1,Size(Obs_eq,1)
   select case (I)
   case (1)
      Filename = "Green"
   case (2)
      Filename = "SpinZ"
   case (3)
      Filename = "SpinXY"
   case (4)
      Filename = "SpinT"
   case (5)
      Filename = "Den"
   case default
      Write(6,*) "Error in Alloc_obs"
   end select
   Nt = 1
   Channel = "--"
   Call Obser_Latt_make(Obs_eq(I), Nt, Filename, Latt, Latt_unit, Channel, dtau)
Enddo
\end{lstlisting} 
Be aware that \texttt{Obser\_Latt\_make} does not copy the Bravais lattice \texttt{Latt} 
and unit cell \texttt{Latt\_unit}, but links them through pointers to be more memory 
efficient. One can have different lattices attached to different observables by declaring 
additional instances of \texttt{Type(Lattice)} and \texttt{Type(Unit\_cell)}.
 For equal-time correlation functions, we set \texttt{Nt = 1} and \texttt{Channel} specification is not necessary.

If \texttt{Ltau = 1}, then the code allocates space for time displaced quantities. The 
same structure as for equal-time correlation functions is used, albeit with 
\texttt{Nt = Ltrot + 1} and the channel should be set. Whith \texttt{Channel="PH"}, for instance, the analysis algorithm assumes the observable to be particle-hole symmetric. For more details on this parameter, see Sec.~\ref{sec:maxent}.

At the beginning of each bin, the main program will set the bin observables to zero by calling  the routine \texttt{Init\_obs(Ltau)}. The user does not have to edit this routine. 
 
%-------------------------------------------------------------------------------------
\subsubsection[Measuring equal-time observables: \texttt{Obser}]{Measuring equal-time observables: \texttt{Obser(GR,Phase,Ntau)}} \label{sec:EqualTimeobs}
%-------------------------------------------------------------------------------------

Having allocated the necessary memory, we proceed to define the observables. The equal-time  Green function,
\begin{equation}
	 \texttt{GR(x,y},\sigma{\texttt)}  = \langle \hat{c}^{\phantom{\dagger}}_{x,\sigma} \hat{c}^{\dagger}_{y,\sigma}  \rangle,
\end{equation}
the  phase factor \texttt{phase} [Eq.~(\ref{eqn:phase})], and time slice \texttt{Ntau}   are provided by the main program.  

Here,   $x$ and $y$ label  both unit cell as well as the orbital within the unit cell. For the Hubbard model described here, $x$ corresponds to the unit cell.  The Green function  does not depend on the color index, and is diagonal in flavor.  For the SU(2) symmetric implementation  there is only one flavor, $\sigma = 1$ and the Green function is  independent on the spin index.  This renders the calculation of the observables particularly easy.   

An explicit calculation of the   potential energy  $ \langle U \sum_{\vec{i}}  \hat{n}_{\vec{i},\uparrow}   \hat{n}_{\vec{i},\downarrow}  \rangle $ reads 
\begin{lstlisting}[style=fortran]
Obs_scal(2)%N        = Obs_scal(2)%N + 1
Obs_scal(2)%Ave_sign = Obs_scal(2)%Ave_sign + Real(ZS,kind(0.d0))
Do i = 1,Ndim
  Obs_scal(2)%Obs_vec(1)= Obs_scal(2)%Obs_vec(1) +(1-GR(i,i,1))*(1-GR(i,i,2))*Ham_U*ZS*ZP
Enddo
\end{lstlisting} 
Here  $ \texttt{ZS} = \sgn(C) $  [see Eq.~(\ref{Sign.eq})],  $ \texttt{ZP} =   \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}   $ [see Eq.~(\ref{eqn:phase})] and  \texttt{Ham\_U}  corresponds to the Hubbard  $U$ term.

Equal-time correlations  are also computed in this routine. As an explicit example, we  consider the equal-time density-density correlation:
\begin{equation}
	 \langle \hat{n}_{\vec{i}}   \hat{n}_{\vec{j}} \rangle   -  \langle \hat{n}_{\ve{i} }\rangle  \langle    \hat{n}_{\ve{j}}  \rangle,
\end{equation} 
with
\begin{equation}
	 \hat{n}_{\vec{i}}  =   \sum_{\sigma} \hat{c}^{\dagger}_{\ve{i},\sigma} \hat{c}^{\phantom\dagger}_{\ve{i},\sigma}.
\end{equation}
For the calculation of such quantities, it is convenient to  define: 
\begin{equation}
\label{GRC.eq}
	\texttt{GRC(x,y,s)}   =  \delta_{x,y}  - \texttt{GR(y,x,s)  }
\end{equation}
such that \texttt{GRC(x,y,s)}    corresponds to  $ \langle \langle  \hat{c}_{x,s}^{\dagger}\hat{c}_{y,s}^{\phantom\dagger} \rangle \rangle $. 
In the program code, the calculation of the equal-time density-density correlation function looks as follows:
\begin{lstlisting}[style=fortran]
Obs_eq(4)%N = Obs_eq(4)%N + 1           ! Even if it is redundant, each observable  
                                        ! carries its own counter and sign.
Obs_eq(4)%Ave_sign = Obs_eq(4)%Ave_sign + Real(ZS,kind(0.d0))  
Do I = 1,Ndim
   Do J = 1,Ndim                       
      imj = latt%imj(I,J)
      Obs_eq(4)%Obs_Latt(imj,1,1,1) =  Obs_eq(4)%Obs_Latt(imj,1,1,1) + &
                     &     ( (GRC(I,I,1)+GRC(I,I,2)) * (GRC(J,J,1)+GRC(J,J,2))       + &
                     &        GRC(I,J,1)*GR(I,J,1)   +  GRC(I,J,2)*GR(I,J,2)  ) * ZP * ZS 
   Enddo
   Obs_eq(4)%Obs_Latt0(1) = Obs_eq(4)%Obs_Latt0(1) + (GRC(I,I,1)+GRC(I,I,2))*ZP*ZS
Enddo
\end{lstlisting} 
At the end of each bin the main program calls the routine \texttt{ Pr\_obs(LTAU)}. This routine appends the result for the current bins to the corresponding file, with the appropriate suffix. 

%-------------------------------------------------------------------------------------
\subsubsection[Measuring time-displaced observables: \texttt{ObserT}]{Measuring time-displaced observables: \texttt{ObserT(NT, GT0, G0T, G00, GTT, PHASE)}}  \label{sec:TimeDispObs}
%-------------------------------------------------------------------------------------
%
This subroutine is called by the main program at the beginning of each sweep, provided that \texttt{LTAU}  is set to $1$. The variable \texttt{NT} runs from \texttt{0}  to \texttt{Ltrot} and denotes the imaginary time difference. For a given time  displacement, the main program provides:
\begin{align}
\begin{aligned}
\label{Time_displaced_green.eq}
\texttt{GT0(x,y,s) }  &=   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle \;=\; \langle \langle \mathcal{T} \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle   \\
\texttt{G0T(x,y,s) }   &=  -   \langle \langle   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)    \hat{c}^{\phantom\dagger}_{x,s} (0)    \rangle \rangle \;=\;
    \langle \langle \mathcal{T} \hat{c}^{\phantom\dagger}_{x,s} (0)    \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle    \\
  \texttt{G00(x,y,s) }  &=    \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (0)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle     \\
    \texttt{GTT(x,y,s) }  &=   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle.
\end{aligned}
\end{align}
In the above we have omitted the color index since  the  Green functions are color independent.  The time-displaced spin-spin correlations 
$ 4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle   $ 
are then given by: 
\begin{multline}
	4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle
	=  ( \texttt{GTT(I,I,1)} -  \texttt{GTT(I,I,2)} ) * ( \texttt{G00(J,J,1)} -  \texttt{G00(J,J,2)} )     \\  
	-   \; \texttt{G0T(J,I,1)}*\texttt{GT0(I,J,1)}  -  \texttt{G0T(J,I,2)}* \texttt{GT0(I,J,2)}
\end{multline}

The handling of time-displaced correlation functions is identical to that of equal-time correlations. 


%-------------------------------------------------------------------------------------
\subsection[Flavor symmetries]{Flavor symmetries: \texttt{weight\_reconstruction(weight),  GR\_reconstruction(GR)}, and \texttt{GRT\_reconstruction(GT0, G0T)}}  \label{sec:flavor_symm_vanilla_hubbard}
%-------------------------------------------------------------------------------------
At  zero  chemical  potential,  and  for  repulsive  interactions,    the plain-vanilla   Hubbard  model  enjoys a  partial  particle-hole  symmetry which, for  each HS  field  configuration,  maps one  flavor  (i.e.  spin  sector)  onto  the other:      
\begin{equation} 
	\hat{P}  z   \hat{c}^{\dagger}_{\ve{i},\downarrow} \hat{P}^{-1}    =  z^{*}  e^{i \,  \ve{i} \cdot \ve{Q} }\hat{c}^{\phantom\dagger}_{\ve{i},\uparrow}.
\end{equation}
Here  $ \ve{Q}$  is  the  antiferromagnetic wave  vector. 
Note  that   in the presence  of  an  orbital magnetic field, or  of   twisted boundary conditions  that  couples  symmetrically  to  the  flavor (spin)  
degree of  freedom,  
the anti-unitarity of the   transformation is   required.    Aa a   consequence  of  this    symmetry,  for  a  given  HS  field configuration the  following holds for  the  equal-time Green function. 
\begin{align}
\begin{aligned}
 \texttt{G00(x,y,}\uparrow\texttt{)}  &=     \langle \langle \hat{c}^{\phantom\dagger}_{\ve{x},\uparrow} (0)   \hat{c}^{\dagger}_{\ve{y},\uparrow} (0)   \rangle \rangle
 \;=\;   e^{i (\ve{y} - \ve{x}) \cdot \ve{Q}} \, \,  \overline{ \langle \langle \hat{c}^{\dagger}_{\ve{x},\downarrow} (0)  
     \hat{c}^{\phantom\dagger}_{\ve{y},\uparrow} (0)   \rangle }   
 \\      & =   \delta_{\ve{x},\ve{y}} -  e^{i (\ve{y} - \ve{x}) \cdot \ve{Q}}\, \, \overline{ \texttt{G00(y,x,}\downarrow\texttt{)}  } 
\end{aligned}
\end{align}

For   the  attractive  Hubbard  model  $U<0$,  the  up  and  down  sectors  are  related  by  time  reversal  symmetry:   
\begin{equation}
\hat{T}  z  
\begin{pmatrix}
  \hat{c}^{\phantom\dagger}_{\ve{i},\uparrow}  \\
    \hat{c}^{\phantom\dagger}_{\ve{i},\downarrow} 
\end{pmatrix}
 \hat{T }^{-1}    =  z^{*}    i  \sigma_y  
\begin{pmatrix}
  \hat{c}^{\phantom\dagger}_{\ve{i},\uparrow}  \\
    \hat{c}^{\phantom\dagger}_{\ve{i},\downarrow} 
\end{pmatrix}
\end{equation}
Of  course,   we  have  assumed  that  the  hopping    remains  invariant    under  time  reversal.    As  a  consequence of  this  symmetry: 
\begin{align}
\begin{aligned}
 \texttt{G00(x,y,}\uparrow\texttt{)}     =  \overline{ \texttt{G00(x,y}\downarrow\texttt{)}  } 
\end{aligned}
\end{align}

The  usage  of  the  flavor   symmetry  is  described  in   Sec.~\ref{sec:flavor_sym}.   Only  one  flavor  has  to be   computed  and  the   routines
\texttt{GR\_reconstruction(GR)}, and \texttt{GRT\_reconstruction(GT0, G0T)}  reconstruct, respectively,    the  equal-time  and    time-displaced  Green  functions for one flavor  given the  other.   Hence we  gain a  factor  two  in  computing time.   We  note  that  since  both  symmetries  are  anti-unitary, the  weights   between  the  two  sectors  are  related  by a  complex  conjugation.  This is  specified in the routine    \texttt{ weight\_reconstruction(weight)}.

%-------------------------------------------------------------------------------------
\subsection{Numerical precision}\label{sec:prec_spin}
%-------------------------------------------------------------------------------------

Information on the numerical stability is included in the following lines of the corresponding file \texttt{info}. 
For a  \textit{short} simulation on a $4 \times 4$  lattice at $U/t=4$ and $\beta t = 10$  we obtain
\begin{lstlisting}[basicstyle=\ttfamily\small,columns=fullflexible,keepspaces=true]
Precision Green  Mean, Max :   5.0823874429126405E-011  5.8621144596315844E-006
Precision Phase  Max       :   0.0000000000000000    
Precision tau    Mean, Max :   1.5929357848647394E-011  1.0985132530727526E-005 
\end{lstlisting}
showing the mean and maximum difference between the \textit{wrapped}  and from scratched computed equal and time-displaced  Green functions \cite{Assaad08_rev}.
A stable code  should produce results where the mean difference is smaller than the  stochastic error. The above example  shows a very stable simulation since the Green function  is of order one. 

\subsection{Running the code and testing}

To test the code, one can carry out high precision simulations. After compilation, the executable \texttt{ALF.out} is found in the directory \texttt{\$ALF\_DIR/Prog/} and can be run from any directory containing the files \texttt{parameters} and \texttt{seeds} (See Sec.~\ref{sec:files}).

Alternatively, as we do bellow, it may be convenient to use \texttt{pyALF} to compile and run the code, especially when using one of the scripts or notebooks available.  

\paragraph*{One-dimensional case} 

The \texttt{pyALF} python script   \href{https://git.physik.uni-wuerzburg.de/ALF/pyALF/-/blob/\pyALFbranch/Scripts/Hubbard_Plain_Vanilla.py}{\texttt{Hubbard\_Plain\_Vanilla.py}}   runs the projective version of the code for the four-site Hubbard model.  At $\theta t =10$, $\Delta \tau t = 0.05 $ with the symmetric Trotter  decomposition, we obtain after 40 bins of 2000 sweeps each the total energy:   
\begin{equation*}
       \langle  \hat{H}   \rangle = -2.103750  \pm      0.004825,
 \end{equation*}
and the exact result is  
\begin{equation*}
\langle  \hat{H}   \rangle_{\texttt{Exact}}    = -2.100396.
\end{equation*}

\paragraph*{Two-dimensional case}  
For the two-dimensional case,   with similar parameters, we obtain the results listed in Table~\ref{tab:2dplain}.
\begin{table}[h!]
\begin{center}
\begin{tabular}{l l l}
\toprule
             &  QMC  & Exact  \\ \midrule
Total energy & -13.618   $\pm $  0.002 &  -13.6224  \\
 $\ve{Q}=(\pi,\pi)$ spin correlations &  \phantom{-1}3.630     $ \pm $   0.006     & \phantom{-1}3.64 \\ 
 \bottomrule
\end{tabular}
\caption{Test results for the \texttt{Hubbard\_Plain\_Vanilla} code on a two-dimensional lattice with default parameters.} \label{tab:2dplain}
\end{center}
\end{table}
The exact results stem from Ref.~\cite{Parola91}     and the slight discrepancies from the exact results can be  assigned to the finite value of $\Delta \tau$.  Note that all the simulations were carried out with the default value of the Hubbard interaction, $U/t =4$. 
