% Copyright (c) 2016 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex


\red{TO BE DELETED, with parts being reused in sections Predefined Structures and Model classes.}

%------------------------------------------------------------
\subsection{The $SU(2)$-Hubbard model on a square lattice}\label{sec:walk1}
%------------------------------------------------------------

To implement a Hamiltonian, the user has to provide  a module   which  specifies the lattice, the model, as well as the observables  they wish to compute. 
In this section, we describe the module 
\path{Hamiltonian_Examples_mod.F90} which contains an implementation of the Hubbard model on the square lattice. 
A sample run for this model can be found in \path{Examples/Hubbard_SU2_Square/}.

The Hamiltonian reads 
\begin{equation}
\label{eqn_hubbard_sun}
\mathcal{H}= 
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y =1 }^{N_{\text{unit-cell}}} 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
+ \frac{U}{2}\sum\limits_{x}\left[
\sum\limits_{\sigma=1}^{2}
\left(  c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{x \sigma}  -1/2 \right) \right]^{2}\;.
\end{equation} 
We can make contact with the general form of the Hamiltonian by setting: 
$N_{\mathrm{fl}} = 1$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =2 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit-cell}} $,  $U_{k}       =   -\frac{U}{2}$, 
 $V_{x y}^{(ks)} =  \delta_{x,y} \delta_{x,k}$,  $\alpha_{ks}   = - \frac{1}{2}  $ and $M_I       = 0 $.


%------------------------------------------------------------
\subsubsection{Setting the Hamiltonian:  \texttt{Ham\_set} }
%------------------------------------------------------------

The main program will call the subroutine   \texttt{Ham\_set} in the module \texttt{Hamiltonian\_Hub\_mod.F90}.
The latter  subroutine  defines the  public variables
\begin{lstlisting}[style=fortran]
Type (Operator), dimension(:,:), allocatable  :: Op_V 
Type (Operator), dimension(:,:), allocatable  :: Op_T
Integer, allocatable :: nsigma(:,:)
Integer              :: Ndim,  N_FL,  N_SUN,  Ltrot

\end{lstlisting}
which specify the model. The array \texttt{nsigma} contains the HS field. The  routine \texttt{Ham\_set}  will first  read the parameter file,  then set the lattice, \texttt{Call Ham\_latt},  set the hopping, \texttt{Call Ham\_hop},  and set the interaction, 
\texttt{call Ham\_V}.  
The parameters are read in from the file \texttt{parameters}, see Sec.~\ref{sec:input}.

%------------------------------------------------------------
\paragraph{The lattice:   \texttt{Call Ham\_latt} }
%------------------------------------------------------------

\red{Superseded by Predefined Structures.}

%------------------------------------------------------------
\paragraph{The hopping term: \texttt{Call Ham\_hop}}
%------------------------------------------------------------

The hopping matrix is implemented as follows. 
We allocate an array of dimension $1\times 1$ of type operator  called \texttt{Op\_T} and set the  dimension for the hopping  matrix to $N=N_{\mathrm{dim}}$. One  allocates and initializes this type by a single call to the subroutine \texttt{Op\_make}: 
\begin{lstlisting}[style=fortran]
call Op_make(Op_T(1,1),Ndim)
\end{lstlisting}
Since the hopping  does not  break down into small blocks, we have ${\bm P}=\mathds{1}$   and  
\begin{lstlisting}[style=fortran]
Do i= 1,Ndim
  Op_T(1,1)%P(i) = i
Enddo
\end{lstlisting}
We set the hopping matrix  with 
\begin{lstlisting}[style=fortran]
DO I = 1, Latt%N
   Ix = Latt%nnlist(I,1,0)
   Iy = Latt%nnlist(I,0,1)
   Op_T(1,1)%O(I  ,Ix) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(Ix,I  ) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(I  ,Iy) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(Iy, I ) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(I  ,I ) = cmplx(-Ham_chem,0.d0,kind(0.D0))
ENDDO

\end{lstlisting}
Here, the integer function \texttt{  j=  Latt\%nnlist(I,n,m)} is defined in the lattice module and returns the index of the lattice site $ \vec{I} +  n \vec{a}_1 +  m \vec{a}_2$.
Note that periodic boundary conditions are 
already taken into account.  The hopping parameter \texttt{Ham\_T} as well as the chemical potential \texttt{Ham\_chem} are read from the parameter file.  
To completely define the hopping  we further set: \texttt{Op\_T(1,1)\%g = -Dtau }, \texttt{Op\_T(1,1)\%alpha = cmplx(0.d0,0.d0, kind(0.D0))} and call the routine  \texttt{Op\_set(Op\_T(1,1))}  so as to generate  the unitary transformation and eigenvalues as specified in Table \ref{table:operator}.  Recall that for the hopping, the variable  \texttt{Op\_set(Op\_T(1,1))\%type}  is not  required. 
Note that although a checkerboard decomposition is not  used here,  it can be implemented by considering a larger number of sparse hopping matrices.


%------------------------------------------------------------
\paragraph{The interaction term: \texttt{Call Ham\_V}}
%------------------------------------------------------------

\red{Superseded by Predefined Structures.}

%------------------------------------------------------------
\subsubsection{Observables}
%------------------------------------------------------------

At this point, all the information   for the simulation to  start has been provided.  The code will sequentially go through  the operator list  \texttt{Op\_V}  and update the  fields.   Between  time slices   \texttt{LOBS\_ST}  and  \texttt{LOBS\_EN}   the main program will call the routine  \texttt{Obser(GR,Phase,Ntau)}   which is provided by the user and handles equal-time correlation functions. 
If \texttt{Ltau=1} the main program will call the routine \texttt{ObserT(NT,  GT0,G0T,G00,GTT, PHASE) }   which is again  provided by the user and handles  imaginary-time displaced correlation functions. 

The user will have to  implement the  observables  they  want to compute. Here  we  will describe how to  proceed. 

%------------------------------------------------------------------------------------
\paragraph{Allocating space for the observables: \texttt{Call Alloc\_obs(Ltau) }} \label{Alloc_obs_sec}
%-------------------------------------------------------------------------------------

For  four scalar  or vector observables,  the user will have to  declare the following: 
\begin{lstlisting}[style=fortran]
Allocate ( Obs_scal(4) )
Do I = 1,Size(Obs_scal,1)
   select case (I)
   case (1)
      N = 2;  Filename ="Kin"
   case (2)
      N = 1;  Filename ="Pot"
   case (3)
      N = 1;  Filename ="Part"
   case (4)
      N = 1,  Filename ="Ener"
   case default
      Write(6,*) ' Error in Alloc_obs '  
   end select
   Call Obser_Vec_make(Obs_scal(I),N,Filename)
enddo
\end{lstlisting}
Here,   \texttt{Obs\_scal(1)}   contains a vector  of two observables  so as to account for the $x$- and $y$-components of the kinetic energy for example.  

For equal-time correlation functions  we allocate  \texttt{Obs\_eq}  of type \texttt{Obser\_Latt}.  Here we include the calculation of spin-spin and density-density correlation functions alongside equal-time Green functions. 
\begin{lstlisting}[style=fortran]
Allocate ( Obs_eq(4) )
Do I = 1,Size(Obs_eq,1)
   select case (I)
   case (1)
      Ns = Latt%N; No = Norb;  Filename ="Green"
   case (2)
      Ns = Latt%N; No = Norb;  Filename ="SpinZ"
   case (3)
      Ns = Latt%N; No = Norb;  Filename ="SpinXY"
   case (4)
      Ns = Latt%N; No = Norb;  Filename ="Den"
   case default
      Write(6,*) ' Error in Alloc_obs '  
   end select
   Nt = 1
   Call Obser_Latt_make(Obs_eq(I),Ns,Nt,No,Filename)
enddo
\end{lstlisting} 
 For the Hubbard model \texttt{Norb = 1} and for   equal-time correlation functions   \texttt{Nt = 1}.       If  \texttt{Ltau = 1}  then the code will allocate space for  time displaced quantities.   The same structure as for  equal-time correlation functions will be used, albeit with  \texttt{Nt = Ltrot + 1}.  At the beginning of each bin, the main program will set the bin observables to zero by calling  the routine 
 \texttt{Init\_obs(Ltau)}.   The user does not have to edit this routine. 
 
%-------------------------------------------------------------------------------------
\paragraph{Measuring equal-time observables: \texttt{Obser(GR,Phase,Ntau)}}
%-------------------------------------------------------------------------------------

The equal-time  Green function,
\begin{equation}
	 \texttt{GR(x,y},\sigma{\texttt)}  = \langle c^{\phantom{\dagger}}_{x,\sigma} c^{\dagger}_{y,\sigma}  \rangle,
\end{equation}
the  phase factor \texttt{phase} [Eq.~(\ref{eqn:phase})], and time slice \texttt{Ntau}   are provided by the main program.  

Here,   $x$ and $y$ label  both unit cell as well as the orbital within the unit cell. For the Hubbard model described here, $x$ corresponds to the unit cell.  The Green function  does not depend on the color index, and is diagonal in flavor.  For the $SU(2)$ symmetric implementation  there is only one flavor, $\sigma = 1$ and the Green function is  independent on the spin index.  This renders the calculation of the observables particularly easy.   

An explicit calculation of the   potential energy  $ \langle U \sum_{\vec{i}}  \hat{n}_{\vec{i},\uparrow}   \hat{n}_{\vec{i},\downarrow}  \rangle $ reads 
\begin{lstlisting}[style=fortran]
Obs_scal(2)%N     = Obs_scal(2)%N + 1
Obs_scal(2)%Ave_sign = Obs_scal(2)%Ave_sign + Real(ZS,kind(0.d0))
Do i = 1,Ndim
   Obs_scal(2)%Obs_vec(1) = Obs_scal(2)%Obs_vec(1) + (1-GR(i,i,1))**2 * Ham_U * ZS * ZP
Enddo
\end{lstlisting} 
Here  $ \texttt{ZS} = \text{ sign} (C) $  [see Eq.~(\ref{Sign.eq})],  $ \texttt{ZP} =   \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}   $ [see Eq.~(\ref{eqn:phase})] and  \texttt{Ham\_U}  corresponds to the Hubbard-$U$ term.

Equal-time correlations  are also computed in this routine. As an explicit example, we  consider the equal-time density-density correlation:
\begin{equation}
	 \langle n_{\vec{i},\alpha}   n_{\vec{j},\beta} \rangle   -  \langle n_{\vec{i},\alpha} \rangle  \langle    n_{\vec{j},\beta}  \rangle \;.
\end{equation} 
For the calculation of such quantities, it is convenient to  define: 
\begin{equation}
\label{GRC.eq}
	\texttt{GRC(x,y,s)}   =  \delta_{x,y}  - \texttt{GR(y,x,s)  }
\end{equation}
such that \texttt{GRC(x,y,s)}    corresponds to  $ \langle \langle  \hat{c}_{x,s}^{\dagger}\hat{c}_{y,s}^{\phantom\dagger} \rangle \rangle $. 
In the program code, the calculation of the equal-time density-density correlation function looks as follows:
\begin{lstlisting}[style=fortran]
Obs_eq(4)%N = Obs_eq(4)%N + 1           ! Even if it is redundant, each observable  
                                        ! carries its own counter and sign.
Obs_eq(4)%Ave_sign = Obs_eq(4)%Ave_sign + Real(ZS,kind(0.d0))  
Do I1 = 1,Ndim
   I    = List(I1,1)                    ! = I1  (The Hubbard model  on the square
   no_I = List(I1,2)                    ! = 1   lattice has one orbital per unit-cell)
   Do J1 = 1,Ndim                       
      J    = List(J1,1)
      no_J = List(J1,2)
      imj = latt%imj(I,J)
      Obs_eq(4)%Obs_Latt(imj,1,no_I,no_J) =  Obs_eq(4)%Obs_Latt(imj,1,no_I,no_J) + &
                     &     (    GRC(I1,I1,1) * GRC(J1,J1,1) * N_SUN * N_SUN      + &
                     &          GRC(I1,J1,1) * GR(I1,J1,1) * N_SUN   ) * ZP * ZS 
   Enddo
   Obs_eq(4)%Obs_Latt0(no_I) = Obs_eq(4)%Obs_Latt0(no_I) + GRC(I1,I1,1) * N_SUN*ZP*ZS
Enddo
\end{lstlisting} 
Note that we consider the  square lattice of the single site Hubbard model as a special case of a multiorbital problem as described in Sec.~\ref{sec:multi-orbital}
At the end of each bin  the main program will call the routine \texttt{ Pr\_obs(LTAU)}. This routine will append the result of the bins in the specified file,  with appropriate suffix. 

%-------------------------------------------------------------------------------------
\paragraph{Measuring time displaced observables: \texttt{ObserT(NT,  GT0,G0T,G00,GTT, PHASE) }}
%-------------------------------------------------------------------------------------
%
This subroutine is called by the main program at the beginning of each sweep, provided that \texttt{LTAU}  is set to unity.  \texttt{NT} runs from \texttt{0}  to \texttt{Ltrot} and denotes the   imaginary time difference.   For a given time  displacement, the main program provides:
\begin{align}
\begin{aligned}
\texttt{GT0(x,y,s) }  &=   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle = \langle \langle \mathcal{T} \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle   \\
\texttt{G0T(x,y,s) }   &=  -   \langle \langle   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)    \hat{c}^{\phantom\dagger}_{x,s} (0)    \rangle \rangle =
    \langle \langle \mathcal{T} \hat{c}^{\phantom\dagger}_{x,s} (0)    \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle    \\
  \texttt{G00(x,y,s) }  &=    \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (0)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle     \\
    \texttt{GTT(x,y,s) }  &=   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle    
\end{aligned}
\end{align}
In the above we have omitted the color index since  the  Green functions are color independent.  The time displaced  spin-spin correlations 
$ 4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle   $ 
are thereby given by: 
\begin{equation}
	4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle   = - 2 \; \texttt{G0T(J1,I1,1) } \texttt{GT0(I1,J1,1) } \;.
\end{equation}
Note that the above holds for the $SU(2)$ HS transformation discussed in this chapter. 
The handling of time displaced correlation functions is identical to that of equal-time correlations. 

%-------------------------------------------------------------------------------------
\subsubsection{Numerical precision}\label{sec:prec_charge}
%-------------------------------------------------------------------------------------
The directory \path{Examples/Hubbard_SU2_Square}  contains an example simulation of the $4 \times 4$ Hubbard model at $U/t=4$ and $\beta t = 10$. 
Information on the numerical stability is included in the following lines of the corresponding file \texttt{info}:
\begin{alltt}
Precision Green  Mean, Max :    1.2918865817224671E-014   4.0983018995027644E-011
Precision Phase, Max       :    5.0272908791449966E-012
Precision tau    Mean, Max :    8.4596701790588625E-015   3.5033530012121281E-011
\end{alltt}
showing the mean and maximum difference between the \textit{wrapped}  and from scratched computed equal and time displaced  Green functions \cite{Assaad08_rev}.
A stable code  should produce results where the mean difference is smaller than the  stochastic error. The above example  shows a very stable  simulation since the Green function  is of order one. 


%-------------------------------------------------------------------------------------
\subsection{The $M_z$-Hubbard model on a square lattice}\label{sec:walk1.1}
%-------------------------------------------------------------------------------------

The Hubbard Hamiltonian can equally be written as:
\begin{equation}
\label{eqn_hubbard_Mz}
\mathcal{H}=
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y =1 }^{N_\text{unit cells }} 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
- \frac{U}{2}\sum\limits_{x}\left[
c^{\dagger}_{x, \uparrow} c^{\phantom\dagger}_{x \uparrow}  -   c^{\dagger}_{x, \downarrow} c^{\phantom\dagger}_{x \downarrow}  \right]^{2}\;.
\end{equation} 
We can make contact with the general form of the Hamiltonian  (see Eq.~\ref{eqn:general_ham}) by setting: 
$N_{\mathrm{fl}} = 2$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =1 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit-cell}} $,  $U_{k}       =   \frac{U}{2}$, 
 $V_{x y}^{(k, s=1)} =  \delta_{x,y} \delta_{x,k}  $,  $V_{x y}^{(k, s=2)} =  - \delta_{x,y} \delta_{x,k}  $,  $\alpha_{ks}   = 0  $ and $M_I       = 0 $.   
 The coupling of the HS fields to the $z$-component of   the magnetization breaks the $SU(2)$ spin symmetry. Nevertheless the $z$-component of the spin remains a good quantum number such that the imaginary-time propagator -- for a given HS field -- is block  diagonal in this quantum number. This corresponds to the flavor index  which runs from one to two  labelling spin up and spin down  degrees of freedom.       In the parameter file  listed in  Sec.~\ref{sec:input}  setting the model variable to  \texttt{Hubbard\_Mz}  will carry out the simulation in the above representation. 
 With respect to the $SU(2)$ case, the changes required in the \texttt{Hamiltonian\_Examples\_mod.F90}  module are  minimal and essentially effect only the interaction term, and the calculation of observables.  We note that  in this formulation the  hopping matrix can be flavor dependent such that a Zeeman  magnetic field can be introduced.  If the chemical potential is set to zero, this will not generate a negative sign problem \cite{Wu04,Milat04,Bercx09}.    
 A sample run for this model can be found in \texttt{Examples/Hubbard\_Mz\_Square/}.

%-------------------------------------------------------------------------------------
\subsubsection{The interaction term: \texttt{Call Ham\_V} } 
%-------------------------------------------------------------------------------------

\red{Superseded by Predefined Structures.}

%-------------------------------------------------------------------------------------
 \subsubsection{The  measurements: \texttt{Call Obser, Call  ObserT} } 
%-------------------------------------------------------------------------------------

 Since  the spin up and spin down Green functions differ  for a given HS configuration,  the Wick decomposition will take a different form. In particular, the  equal-time spin-spin correlation functions 
 $ 4 \langle \langle \hat{S}^{z}_{\vec{i}}   \hat{S}^{z}_{\vec{j}} \rangle \rangle   $  calculated in the subroutine  \texttt{Obser}  will take the form: 
  \begin{align}
   4 \langle \langle \hat{S}^{z}_{x}   \hat{S}^{z}_{y} \rangle \rangle   =   &  \texttt{  GRC(x,y,1) * GR(x,y,1) + GRC(x,y,2) * GR(x,y,2) + }  \nonumber \\ 
 & \texttt{   (GRC(x,x,2) - GRC(x,x,1))*(GRC(y,y,2) - GRC(y,y,1))}  \nonumber
  \end{align}
Here,  \texttt{GRC}  is defined in Eq.~\ref{GRC.eq}.  Equivalent changes will have to be carried out for other equal-time and time displaced observables. 
  
Apart from these modifications, the program  will run in exactly the same manner as for the $SU(2)$ case. 
    
  
%-------------------------------------------------------------------------------------
\subsubsection{Numerical precision}\label{sec:prec_spin}
%-------------------------------------------------------------------------------------
The directory \path{Examples/Hubbard_Mz_Square}  contains an example simulation of the $4 \times 4$ Hubbard model at $U/t=4$ and $\beta t = 10$. 
Information on the numerical stability is included in the following lines of the corresponding file \texttt{info}:
 \begin{alltt}
Precision Green  Mean, Max :    5.0823874429126405E-011   5.8621144596315844E-006
Precision Phase, Max       :    0.0000000000000000     
Precision tau    Mean, Max :    1.5929357848647394E-011   1.0985132530727526E-005 
\end{alltt}

This is still an excellent precision but nevertheless choosing a 
 HS field which couples to the z-component of the magnetization apparently leads to numerical results that are 
a couple of order of magnitudes less precise than a HS decomposition coupling to the charge (compare with Sec.~\ref{sec:prec_charge}).

    

%-------------------------------------------------------------------------------------  
\subsection{The $SU(2)$-Hubbard model on  the honeycomb  lattice}\label{sec:walk1.2}
%-------------------------------------------------------------------------------------

The Hamilton module \texttt{Hamiltonian\_Examples\_mod.F90} can also carry out simulations for the Hubbard model on the Honeycomb lattice by setting in the parameter file   \path{Lattice_type = "Honeycomb"} (see Sec.~\ref{sec:input}).
 A sample run for this model can be found in \path{Examples/Hubbard_SU2_Honeycomb/}.

 %-------------------------------------------------------------------------------------
\subsubsection{Working with multi-orbital unit cells:  \texttt{Call Ham\_Latt} } \label{sec:multi-orbital}
%-------------------------------------------------------------------------------------

\red{Superseded by Predefined Structures.}

%-------------------------------------------------------------------------------------
\subsubsection{The hopping term:  \texttt{Call Ham\_Hop} }
%-------------------------------------------------------------------------------------

Some care has to be taken when setting the hopping matrix. In the Hamilton module \path{Hamiltonian_Examples_mod.F90} we do this in the following way:
\begin{lstlisting}[style=fortran]
DO I = 1, Latt%N                              ! Loop over unit cell 
   do no = 1,Norb                             ! Runs over orbitals and 
                                              ! sets the chemical potential
      I1 = invlist(I,no)  
      Op_T(nc,n)%O(I1 ,I1) = cmplx(-Ham_chem, 0.d0, kind(0.D0))
   enddo
   I1 = Invlist(I,1)                          ! Orbital A of unit cell I
   Do nc1 = 1,N_coord                         ! Loop over coordination  number
      select case (nc1)
      case (1)
         J1 = invlist(I,2)                    ! Orbital B of unit cell i
      case (2)
         J1 = invlist(Latt%nnlist(I,1,-1),2)  ! Orbital B of unit cell i + a_1 - a_2
      case (3)
         J1 = invlist(Latt%nnlist(I,0,-1),2)  ! Orbital B of unit cell i - a_2 
      case default
         Write(6,*) ' Error in  Ham_Hop '  
      end select
      Op_T(nc,n)%O(I1,J1) = cmplx(-Ham_T,    0.d0, kind(0.D0))   
      Op_T(nc,n)%O(J1,I1) = cmplx(-Ham_T,    0.d0, kind(0.D0))
   Enddo
Enddo
\end{lstlisting}
As apparent from the above, hopping matrix elements   are non-zero only between the $A$ and $B$  sublattices. 

%-------------------------------------------------------------------------------------
\subsubsection{Observables:  \texttt{Call Obser},   \texttt{Call ObserT}}
%-------------------------------------------------------------------------------------

In the multi-orbital case,  the correlation functions have additional orbital indices. This is automatically taken care of in the routines \texttt{Call Obser} and \texttt{Call ObserT}  since  we have already considered the  Hubbard model on the square lattice to correspond to a multi-orbital unit cell albeit with the special choice of one orbital per unit cell. 

%------------------------------------------------------------------------------------- 
\subsection{The $SU(2)$-Hubbard model on a square lattice coupled to a transverse Ising field}\label{sec:walk2}
%-------------------------------------------------------------------------------------

The model we consider here  is very similar to the  above,  but has an additional coupling to a transverse field: 
\begin{equation}
\begin{aligned}
\label{eqn_hubbard_sun_Ising}
\mathcal{H} =&
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y } 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
+ \frac{U}{2}\sum\limits_{x}\left[
\sum\limits_{\sigma=1}^{2}
\left(  c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{x \sigma}  -1/2 \right) \right]^{2}   
+  \xi \sum_{\sigma,\langle x,y \rangle} \hat{Z}_{\langle x,y \rangle}  \left( c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{y \sigma}  + h.c. \right) \\ 
 &- h \sum_{\langle x,y \rangle} \hat{X}_{\langle x,y \rangle}   - J \sum_{\langle \langle x,y \rangle \langle x',y' \rangle \rangle} 
  \hat{Z}_{\langle x,y \rangle}   \hat{Z}_{\langle x',y' \rangle} 
  \end{aligned}
\end{equation}
We can make contact with the general form of the Hamiltonian by setting: 
$N_{\mathrm{fl}} = 1$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =2 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit-cell}} \equiv N_{\mathrm{dim}}$,  $U_{k}       =   -\frac{U}{2}$, 
 $V_{x y}^{(ks)} =  \delta_{x,y} \delta_{x,k}$,  $\alpha_{ks}   = - \frac{1}{2}  $ and $M_I       = 2 N_{\text{unit-cell}} $.  
 The last two terms of the  above Hamiltonian describe a transverse Ising field model on the bonds of the square lattice.  This  type of Hamiltonian  has  recently been extensively discussed  \cite{Schattner15,Xu16,Assaad16}.  Here we adopt the notation of Ref.~\cite{Assaad16}. Note that   $\langle \langle x,y \rangle \langle x',y' \rangle \rangle $ denotes nearest neighbor bonds.
The modifications  required to generalize the Hubbard model code to the above model are two-fold. 

First,  one has to specify the function \path{Real (Kind=8) function S0(n,nt)}, and  second,  modify the interaction \texttt{Call Ham\_V}.

A sample run for this model can be found in \path{Examples/Hubbard_SU2_Ising_Square/}.


%-------------------------------------------------------------------------------------
\subsubsection{The Ising term.}
%-------------------------------------------------------------------------------------
Since the Ising field lives on bonds we have to provide a data structure defining this quantity.  A bond has an anchor site as well as an orientation. The routine \path{Setup_Ising_action}   initializes  the arrays \path{L_bond} and  \path{L_bond_inv} that contain this information.
\begin{lstlisting}[style=fortran]
nc = 0
Do n_orientation = 1,N_coord
Do I = 1, Latt%N
   nc = nc + 1
   L_bond(I,n_orientation) = nc
   L_bond_inv(nc,1) = I    
   L_bond_inv(nc,2) = n_orientation
enddo
enddo
\end{lstlisting}
The two legs of the bond are given by  the anchor $\vec{I}$ and $\vec{I}+ \vec{a}_{n_\text{orientation}}$
%-------------------------------------------------------------------------------------
\subsubsection{The interaction term: \texttt{Call Ham\_V}}
%-------------------------------------------------------------------------------------

The dimension of   \texttt{Op\_V}  is now  $(M_I + M_V)\times N_{\mathrm{fl}}=((N_\text{coord} +  1 )N_{\text{dim}}) \times 1$ since each site has $N_\text{coord} =2$ bonds   for the square lattice.
\begin{lstlisting}[style=fortran]
do i  = 1,N_coord*Ndim                     ! Runs over bonds for Ising interaction.
  call Op_make(Op_V(i,1),2)
enddo
do i  =  N_coord*Ndim+1, (N_coord+1)*Ndim  ! Runs over sites for Hubbard interaction.
  call Op_make(Op_V(i,1),1)
enddo
\end{lstlisting}
The  first  \texttt{N\_coord*Ndim} operators run through the $2N$ bonds of the square lattice and   are given by:
\begin{lstlisting}[style=fortran]
Do nc = 1,Ndim*N_coord                     ! Runs over bonds. Coordination number = 2.
                                           ! For the square lattice Ndim = Latt%N
  
   I1 = L_bond_inv(nc,1)                   ! Anchor of the bond
	                                   ! L_bond_inv is setup in Setup_Ising_action
   if ( L_bond_inv(nc,2)  == 1 ) I2 = Latt%nnlist(I1,1,0)  ! Second site of the bond 
   if ( L_bond_inv(nc,2)  == 2 ) I2 = Latt%nnlist(I1,0,1) 
   Op_V(nc,1)%P(1) = I1
   Op_V(nc,1)%P(2) = I2
   Op_V(nc,1)%O(1,2) = cmplx(1.d0 ,0.d0, kind(0.D0))
   Op_V(nc,1)%O(2,1) = cmplx(1.d0 ,0.d0, kind(0.D0))
   Op_V(nc,1)%g      = cmplx(-dtau*Ham_xi,0.D0,kind(0.D0))
   Op_V(nc,1)%alpha  = cmplx(0d0,0.d0, kind(0.D0))
   Op_V(nc,1)%type   = 1
Enddo
\end{lstlisting}
Here,  \texttt{ham\_xi} defines the coupling strength  between the Ising  and fermion degree of freedom.
As for the Hubbard case, the last \texttt{Ndim}  operators read: 
\begin{lstlisting}[style=fortran]
nc = N_coord*Ndim 
Do i = 1, Ndim
    nc = nc + 1
    Op_V(nc,1)%P(1)   = i 
    Op_V(nc,1)%O(1,1) = cmplx(1.d0  ,0.d0, kind(0.D0))
    Op_V(nc,1)%g      = sqrt(cmplx(-dtau*ham_U/(DBLE(N_SUN)), 0.D0, kind(0.D0)))
    Op_V(nc,1)%alpha  = cmplx(-0.5d0,0.d0, kind(0.D0))
    Op_V(nc,1)%type   = 2
Enddo
\end{lstlisting}

%-------------------------------------------------------------------------------------
\subsubsection{The function \texttt{Real (Kind=8) function S0(n,nt)} }\label{sec:s0}
%-------------------------------------------------------------------------------------

As mentioned above,  a configuration now includes both HS spins and Ising spins and is given by
\begin{equation}
	C = \left\{   s_{i,\tau} ,  l_{j,\tau},  \text{ with }  i=1,\cdots, M_I;\;  j = 1,\cdots, M_V;\;  \tau=1,\cdots,L_\text{Trotter}  \right\}\:.
\end{equation}
This configuration is stored in the  integer array \texttt{nsigma(M\_V + M\_I, Ltrot)}.  With the above ordering of Hubbard and Ising interaction terms, and a for a given imaginary time, the first \texttt{2*Ndim} fields correspond to the Ising interaction and the next \path{Ndim} ones to the Hubbard interaction.
The first   argument of the function \texttt{S0}, namely \texttt{n},  corresponds to the index of the operator  string 
\texttt{Op\_V(n,1)}. If \texttt{Op\_V(n,1)\%type = 2} then   \texttt{S0(n,nt)}  returns 1. Note that \texttt{type=2} refers to spins that stem from a  HS transformation. 
If however  \texttt{Op\_V(n,1)\%type = 1}  then function \texttt{S0}  returns
\begin{equation}
\frac{e^{-S_{0,I} \left(  s_{1,\tau},  \cdots,  - s_{n,\tau},  \cdots s_{M_I,\tau}   \right) } }{e^{-S_{0,I}  \left(  s_{1,\tau},  \cdots,   s_{n,\tau},  \cdots s_{M_I,\tau}   \right)   } }	
\end{equation}
That is,   if $n \leq 2* \texttt{Ndim} $,    $ \texttt{S0(n,nt)} $  returns the ratio of the new weight to the old weight  of the  Ising Hamiltonian upon flipping a single Ising spin $ s_{n,\tau} $.  Otherwise, $ \texttt{S0(n,nt)} $   returns unity. 

