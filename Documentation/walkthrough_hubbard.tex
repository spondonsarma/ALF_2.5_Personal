% !TEX root = Doc.tex
\section{Walkthrough: the $SU(2)$-Hubbard model on a square lattice}\label{sec:walk1}
To implement a Hamiltonian, the user has to provide  a module   which  specifies the lattice, the model, as well as the observables  he/she  wishes to compute. 
In this section, we describe the module \\
\texttt{Hamiltonian\_Examples.f90} which contains an implementation of the Hubbard model on the square lattice. 
A sample run for this model can be found in \path{Examples/Hubbard_SU2_Square/}.

The Hamiltonian reads 
\begin{equation}
\label{eqn_hubbard_sun}
\mathcal{H}=
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y =1 }^{N_{\text{unit cell}}} 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
+ \frac{U}{2}\sum\limits_{x}\left[
\sum\limits_{\sigma=1}^{2}
\left(  c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{x \sigma}  -1/2 \right) \right]^{2}\;.
\end{equation} 
We can make contact with the general form of the Hamiltonian by setting: 
$N_{\mathrm{fl}} = 1$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =2 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit cell}} $,  $U_{k}       =   -\frac{U}{2}$, 
 $V_{x y}^{(ks)} =  \delta_{x,y} \delta_{x,k}$,  $\alpha_{ks}   =  \frac{1}{2}  $ and $M_I       = 0 $.



\subsection{Setting the Hamiltonian:  \texttt{Ham\_set} }
The main program will call the subroutine   \texttt{Ham\_set} in the module \texttt{Hamiltonian\_Hub.f90}.
This  subroutine  defines the  public variables
\begin{lstlisting}

  Type (Operator), dimension(:,:), allocatable  :: Op_V 
  Type (Operator), dimension(:,:), allocatable  :: Op_T
  Integer, allocatable :: nsigma(:,:)
  Integer              :: Ndim,  N_FL,  N_SUN,  Ltrot

\end{lstlisting}
which specify the model.  This  routine will first  read the parameter file,  then set the lattice, \texttt{Call Ham\_latt},  set the hopping \texttt{Call Ham\_hop}  and set the interaction
\texttt{call Ham\_V}.  
The parameters are read in from the file \texttt{parameters}, see Sec.~\ref{sec:input}.
% \begin{lstlisting}
% 
% ===============================================================================
% !  Variables for the Hubb program
% !-------------------------------------------------------------------------------
% &VAR_lattice
% L1=4                    ! Length in direction a_1
% L2=4                    ! Length in direction a_2
% Lattice_type = "Square"	! a_1 = (1,0) and a_2=(0,1)
% Model = "Hubbard_SU2"   ! Sets  Nf = 1, N_sun = 2
% /
% &VAR_Hubbard            ! Variables for the Hubbard model
% ham_T   =1.D0
% ham_chem=0.D0
% ham_U   =4.D0
% Beta    =5.D0
% dtau    =0.1D0          ! Thereby Ltrot=Beta/dtau
% /
% &VAR_QMC      ! Variables for the QMC run
% Nwrap   = 10  ! Stabilization. Green functions will be computed from scratch 
%               ! after each time interval  Nwrap*Dtau
% NSweep  = 500 ! Number of sweeps
% NBin    = 2   ! Number of bins
% Ltau    = 1   ! 1 for calculation of time displaced. 0 otherwise
% LOBS_ST = 1   ! Start measurements at time slice LOBS_ST
% LOBS_EN =50   ! End   measurements at time slice LOBS_EN
% CPU_MAX= 0.1  ! Code will stop after CPU_MAX hours. 
%               ! If not specified, code will stop after Nbin bins.
% /
% 
% \end{lstlisting}
% %\end{verbatim}
% Here we have three name lists relevant for  defining the lattice, model parameters as well  as the Monte Carlo run.   Thereby, \texttt{Ltrot=Beta/dtau}. 

\subsubsection{The lattice:   \texttt{Call Ham\_latt} }
The choice \texttt{Lattice\_type = "Square"} sets $\vec{a}_1 =  (1,0) $ and $\vec{a}_2 =  (0,1) $  and for an $L_1 \times L_2$  lattice  $\vec{L}_1 = L_1 \vec{a}_1$ and  $\vec{L}_2 = L_2 \vec{a}_2$.     The call to  \texttt{ Call Make\_Lattice( L1, L2, a1,  a2, Latt)} will generate the lattice   \texttt{Latt} of type \texttt{Lattice} . 
For the Hubbard model on the square lattice, the number of orbitals per unit cell is given by \texttt{NORB=1} such that   $N_{\mathrm{dim}}   \equiv N_{\text{unit cell}}   \cdot \texttt{NORB}  =  \texttt{Latt\%N}$. 


\subsubsection{The hopping term: \texttt{Call Ham\_hop}}
The hopping matrix is implemented as follows. 
We allocate an array of dimension $1\times 1$ of type operator  called \texttt{Op\_T} and set the  dimension for the hopping  matrix to $N=N_{\mathrm{dim}}$. One  allocates and initializes this type by a single call to the subroutine \texttt{Op\_make}: 
\begin{lstlisting}

call Op_make(Op_T(1,1),Ndim)

\end{lstlisting}
Since the hopping  does not  break down into small blocks ${\bm P}=\mathds{1}$   and  
\begin{lstlisting}

Do i= 1,Ndim
  Op_T(1,1)%P(i) = i
Enddo

\end{lstlisting}
We set the hopping matrix  with 
\begin{lstlisting}

DO I = 1, Latt%N
   Ix = Latt%nnlist(I,1,0)
   Iy = Latt%nnlist(I,0,1)
   Op_T(1,1)%O(I  ,Ix) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(Ix,I  ) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(I  ,Iy) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(Iy, I ) = cmplx(-Ham_T,   0.d0,kind(0.D0))
   Op_T(1,1)%O(I  ,I ) = cmplx(-Ham_chem,0.d0,kind(0.D0))
ENDDO

\end{lstlisting}
Here,    the integer  function \texttt{  j=  Latt\%nnlist(I,n,m)}   is defined in the lattice module and returns the index of the lattice site $ \vec{I} +  n \vec{a}_1 +  m \vec{a}_2$. Note that periodic boundary conditions are 
already taken into account.  The hopping parameter, \texttt{Ham\_T} as well as the chemical potential \texttt{Ham\_chem} are read from the parameter file.  
%Finally,   \texttt{ Op_T(1,1)\%g = -Dtau }
Note that although a checkerboard decomposition is not  used here,  it can be implemented by considering a larger number of sparse hopping matrices

\subsubsection{The interaction term: \texttt{Call Ham\_V}}
To implement this interaction, we allocate an array of \texttt{Operator} type. The array is called  \texttt{Op\_V} and has dimensions $N_{\mathrm{dim}}\times N_{\mathrm{fl}}=N_{\mathrm{dim}} \times 1$. 
We set the dimension for the interaction term to  $N=1$, and  allocate and initialize this array of type  \texttt{Operator} by repeatedly calling the subroutine \texttt{Op\_make}: 

\begin{lstlisting}

do i  = 1,Ndim
   call Op_make(Op_V(i,1),1)
enddo

\end{lstlisting}
For each lattice site $i$, the  matrices ${\bm P}$ are of dimension $1\times N_{\mathrm{dim}} $ and have only one non-vanishing entry. Thereby we can set:

\begin{lstlisting}

Do i = 1,Ndim
   Op_V(i,1)%P(1)   = i
   Op_V(i,1)%O(1,1) = cmplx(1.d0,0.d0, kind(0.D0))
   Op_V(i,1)%g      = sqrt(cmplx(-dtau*ham_U/(dble(N_SUN)),0.D0,kind(0.D0)))
   Op_V(i,1)%alpha  = cmplx(-0.5d0,0.d0, kind(0.D0))
   Op_V(i,1)%type   = 2
Enddo

\end{lstlisting}
so as to completely define the interaction term. 

\subsection{Observables}
At this point, all the information   for the simulation to  start has been provided.  The code will sequentially go through  the operator list  \texttt{Op\_V}  and update the  fields.   Between  time slices   \texttt{LOBS\_ST}  and  \texttt{LOBS\_EN}   the main program will call the routine  \texttt{Obser(GR,Phase,Ntau)}   which is provided by the user and handles equal time correlation functions. 
If \texttt{Ltau=1} the the main program will call the routine \texttt{ObserT(NT,  GT0,G0T,G00,GTT, PHASE) }   which is again 


The user will have to  implement the  observables  he/she  wants to compute. Here  we  will describe how to  proceed. 

\subsubsection{Allocating space for the observables: \texttt{Call Alloc\_obs(Ltau) }} 
\label{Alloc_obs_sec}

 For  four scalar  or vector observables,  the user will have to  declare the following: 
\begin{lstlisting}

Allocate ( Obs_scal(4) )
Do I = 1,Size(Obs_scal,1)
   select case (I)
   case (1)
      N = 2;  Filename ="Kin"
   case (2)
      N = 1;  Filename ="Pot"
   case (3)
      N = 1;  Filename ="Part"
   case (4)
      N = 1,  Filename ="Ener"
   case default
      Write(6,*) ' Error in Alloc_obs '  
   end select
   Call Obser_Vec_make(Obs_scal(I),N,Filename)
enddo
\end{lstlisting}
Here,   \texttt{Obs\_scal(1)}   contains a vector  of two observables  so as to account for the x -and -y components of the kinetic energy for example.  

For equal time correlation  functions  we allocate  \texttt{Obs\_eq}  of type \texttt{Obser\_Latt}.  Here we include the calculation of spin-spin and density-density correlation functions alongside equal time Green functions. 
\begin{lstlisting}

Allocate ( Obs_eq(4) )
Do I = 1,Size(Obs_eq,1)
   select case (I)
   case (1)
      Ns = Latt%N; No = Norb;  Filename ="Green"
   case (2)
      Ns = Latt%N; No = Norb;  Filename ="SpinZ"
   case (3)
      Ns = Latt%N; No = Norb;  Filename ="SpinXY"
   case (4)
      Ns = Latt%N; No = Norb;  Filename ="Den"
   case default
      Write(6,*) ' Error in Alloc_obs '  
   end select
   Nt = 1
   Call Obser_Latt_make(Obs_eq(I),Ns,Nt,No,Filename)
enddo
 \end{lstlisting} 
 For the Hubbard model \texttt{Norb = 1} and for   equal time correlation functions   \texttt{Nt = 1}.       If  \texttt{Ltau = 1}  then the code will allocate space for  time displaced quantities.   The same structure as for  equal time correlation functions will be used albeit with  \texttt{Nt = Ltrot + 1}.  At the beginning of each bin, the main program will set the bin observables to zero by calling  the routine 
 \texttt{Init\_obs(Ltau)}.   The user does not have to edit this routine. 
 
\subsubsection{Measuring equal time observables: \texttt{Obser(GR,Phase,Ntau)}}


The equal time  green function,
\begin{equation}
	 \texttt{GR(x,y},\sigma{\texttt)}  = \langle c^{\phantom{\dagger}}_{x,\sigma} c^{\dagger}_{y,\sigma}  \rangle,
\end{equation}
the  phase factor \texttt{phase} [Eq.~(\ref{eqn:phase})] and time slice \texttt{Ntau}   is provided by the main program.  

Here,   $x$ and $y$ label  unit-cell as well as the orbital within the unit cell. For the Hubbard model described here, $x$ corresponds to the unit cell.  The Green function  does not depend on the color index, and is diagonal in flavor.  For the SU(2)-symmetric implementation  there is only one flavor, $\sigma = 1$ and the Green function is  independent on the spin index.  This renders the calculation of the observables particularly easy.   

An explicit calculation of the   potential energy  $ \langle U \sum_{\vec{i}}  \hat{n}_{\vec{i},\uparrow}   \hat{n}_{\vec{i},\downarrow}  \rangle $ reads 

\begin{lstlisting} 

Obs_scal(2)%N     = Obs_scal(2)%N + 1
Obs_scal(2)%Ave_sign = Obs_scal(2)%Ave_sign + Real(ZS,kind(0.d0))
Do i = 1,Ndim
   Obs_scal(2)%Obs_vec(1) = Obs_scal(2)%Obs_vec(1) + (1-GR(i,i,1))**2 * Ham_U * ZS * ZP
Enddo

\end{lstlisting} 
Here  $ \texttt{ZS} = \text{ sign} (C) $  [see Eq.~(\ref{Sign.eq})],  $ \texttt{ZP} =   \frac{e^{-S(C)}} {\Re \left[e^{-S(C)} \right]}   $ [see Eq.~(\ref{eqn:phase})] and  \texttt{Ham\_U}  corresponds to the Hubbard $U$ term.


Equal time correlations  are also computed in this routine. As an explicit example, we  consider the equal time density-density   fluctuations:
\begin{equation}
	 \langle n_{\vec{i},\alpha}   n_{\vec{j},\beta} \rangle   -  \langle n_{\vec{i},\alpha} \rangle  \langle    n_{\vec{j},\beta}  \rangle 
\end{equation} 
For the calculation of such quantities, it is convenient to  define: 
\begin{equation}
\label{GRC.eq}
	\texttt{GRC(x,y,s)}   =  \delta_{x,y}  - \texttt{GR(y,x,s)  }
\end{equation}
such that \texttt{GRC(x,y,s)}    corresponds to  $ \langle \langle  \hat{c}_{x,s}^{\dagger}\hat{c}_{y,s}^{\phantom\dagger} \rangle \rangle $.  
\begin{lstlisting} 

Obs_eq(4)%N     = Obs_eq(4)%N + 1       ! Even if it is redundant, each observable carries 
Obs_eq(4)%Ave_sign = Obs_eq(4)%Ave_sign + Real(ZS,kind(0.d0))  ! its own counter and sign.
Do I1 = 1,Ndim
   I    = List(I1,1)                    ! = I  For the Hubbard model  on the square
   no_I = List(I1,2)                    ! = 1  lattice there is one orbital per unit-cell. 
   Do J1 = 1,Ndim
      J    = List(J1,1)
      no_J = List(J1,2)
      imj = latt%imj(I,J)
      Obs_eq(4)%Obs_Latt(imj,1,no_I,no_J) =  Obs_eq(4)%Obs_Latt(imj,1,no_I,no_J)  + &
                     &     (    GRC(I1,I1,1)  * GRC(J1,J1,1)  * NSUN * NSUN       + &
                     &          GRC(I1,J1,1)  * GR (I1,J1,1   * NSUN              )* ZP*ZS  
   Enddo
   Obs_eq(4)%Obs_Latt0(no_I) =  Obs_eq(4)%Obs_Latt0(no_I) +   GRC(I1,I1,1) * NSUN * ZP * ZS
Enddo

\end{lstlisting} 
At the end of each bin  the main program will call the routine \texttt{ Pr\_obs(LTAU)}. This routine will append the result of the bins in the specified file,  with appropriate suffix. 


\subsubsection{Measuring time-displaced observables: \texttt{ObserT(NT,  GT0,G0T,G00,GTT, PHASE) }}

This subroutine is called by the main program at the beginning of each sweep, provided that \texttt{LTAU}  is set to unity.  \texttt{NT} runs from \texttt{0}  to \texttt{Ltrot} and denotes the   imaginary time difference.   For a given time  displacement, the main program provides:
\begin{eqnarray}
\texttt{GT0(x,y,s) }  &=&   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle = \langle \langle {\cal T} \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle  \nonumber \\
\texttt{G0T(x,y,s) }   &=&  -   \langle \langle   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)    \hat{c}^{\phantom\dagger}_{x,s} (0)    \rangle \rangle =
    \langle \langle {\cal T} \hat{c}^{\phantom\dagger}_{x,s} (0)    \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle  \nonumber  \\
  \texttt{G00(x,y,s) }  &=&    \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (0)   \hat{c}^{\dagger}_{y,s} (0)   \rangle \rangle    \nonumber \\
    \texttt{GTT(x,y,s) }  &=&   \phantom{+} \langle \langle \hat{c}^{\phantom\dagger}_{x,s} (Nt \Delta \tau)   \hat{c}^{\dagger}_{y,s} (Nt \Delta \tau)   \rangle \rangle    
\end{eqnarray}
In the above we have omitted the color index since  the  Green functions are color independent.  The time displaced  spin-spin correlations: 
$ 4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle   $ 
are thereby given by: 
\begin{equation}
	4 \langle \langle \hat{S}^{z}_{\vec{i}} (\tau)  \hat{S}^{z}_{\vec{j}} (0)\rangle \rangle   = - 2 \; \texttt{G0T(J,I,1) } \texttt{GT0(I,J1) } 
\end{equation}
Note that the above holds for the SU(2) HS transformation discussed in this chapter. 
The handling of time-displaced correlation functions is identical to that of equal time correlations. 




\section{Walkthrough: the $M_z$-Hubbard model on a square lattice}\label{sec:walk1.1}

The Hubbard Hamiltonian can equally be written as:
\begin{equation}
\label{eqn_hubbard_Mz}
\mathcal{H}=
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y =1 }^{N_{unit\; cells }} 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
- \frac{U}{2}\sum\limits_{x}\left[
c^{\dagger}_{x, \uparrow} c^{\phantom\dagger}_{x \uparrow}  -   c^{\dagger}_{x, \downarrow} c^{\phantom\dagger}_{x \downarrow}  \right]^{2}\;.
\end{equation} 
We can make contact with the general form of the Hamiltonian  (see Eq.~\ref{eqn:general_ham}) by setting: 
$N_{\mathrm{fl}} = 2$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =1 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit cell}} $,  $U_{k}       =   \frac{U}{2}$, 
 $V_{x y}^{(k, s=1)} =  \delta_{x,y} \delta_{x,k}  $,  $V_{x y}^{(k, s=2)} =  - \delta_{x,y} \delta_{x,k}  $,  $\alpha_{ks}   = 0  $ and $M_I       = 0 $.   
 The coupling of the HS  to the z-component of   the magnetization breaks the SU(2) spin symmetry. Nevertheless the z-component of spin remains a good quantum number such that  the imaginary time propagator -- for a given HS field -- is block  diagonal in this quantum number. This corresponds to the flavor index  which runs from one to two  labelling spin up and spin down  degrees of freedom.       In the parameter file  listed in  Sec.~\ref{sec:input}  setting the model variable to  \texttt{Hubbard\_Mz}  will carry the simulation in the above representation. 
 With respect to the SU(2) case, the changes required in the \texttt{Hamiltonian\_Examples.f90}   module are  minimal and essentially effect only the interaction term, and calculation of observables.  We note that  in this formulation the  hopping matrix can be favor dependent such that a Zeeman  magnetic field can be introduced.  If the chemical potential is set to zero, this will not generate a negative sign problem \cite{Wu04,Milat04,Bercx09}.    
 A sample run for this model can be found in \texttt{Examples/Hubbard\_Mz\_Square/}.
 \subsection{The interaction term: \texttt{Call Ham\_V} } 
The interaction term is now given by: 

\begin{lstlisting}

Allocate(Op_V(Ndim,N_FL))
do nf = 1,N_FL
   do i  = 1, Ndim
      Call Op_make(Op_V(i,nf),1)
   enddo
enddo
Do nf = 1,N_FL
   nc = 0
   X = 1.d0
   if (nf == 2) X = -1.d0
   Do i = 1,Ndim
      nc = nc + 1
      Op_V(nc,nf)%P(1) = I
      Op_V(nc,nf)%O(1,1) = cmplx(1.d0, 0.d0, kind(0.D0))
      Op_V(nc,nf)%g      = X*SQRT(CMPLX(DTAU*ham_U/2.d0, 0.D0, kind(0.D0))) 
      Op_V(nc,nf)%alpha  = cmplx(0.d0, 0.d0, kind(0.D0))
      Op_V(nc,nf)%type   = 2
      Call Op_set( Op_V(nc,nf) )
   Enddo
Enddo

\end{lstlisting}
In the above, one will see explicitly that  there is a sign   difference between  the coupling of the HS field  in  the  two flavor sectors.  

 \subsection{The  measurements: \texttt{Call Obser, Call  ObserT} } 
 Since  the spin up and spin down Green functions differ  for a given HS configuration,  the Wick decomposition will take a different form. In particular, the  equal time spin-spin correlation functions,
 $ 4 \langle \langle \hat{S}^{z}_{\vec{i}}   \hat{S}^{z}_{\vec{j}} \rangle \rangle   $, calculated in the subroutine  \texttt{Obser},  will take the form: 
  \begin{eqnarray}
   4 \langle \langle \hat{S}^{z}_{x}   \hat{S}^{z}_{y} \rangle \rangle   =  & &  \texttt{  GRC(x,y,1) * GR(x,y,1) + GRC(x,y,2) * GR(x,y,2) + }  \nonumber \\ 
& & \texttt{   (GRC(x,x,2) - GRC(x,x,1))*(GRC(y,y,2) - GRC(y,y,1))}  \nonumber
  \end{eqnarray}
  Here,  \texttt{GRC}  is defined in Eq.~\ref{GRC.eq}.  Equivalent changes will have to be carried out for other equal time and time displaced observables. 
  
  Apart from these modifications, the program  will run in exactly the same manner as for the SU(2) case. 
  
  
\section{Walkthrough: the $SU(2)$-Hubbard model on  the honeycomb  lattice}\label{sec:walk1.2}
The Hamilton module \texttt{Hamiltonian\_Examples.f90}   can also carry out simulations for  the the Hubbard model on the Honeycomb lattice by setting in the parameter file  (see Sec.~\ref{sec:input})   \texttt{Lattice\_type = "Honeycomb"}.
 A sample run for this model can be found in \texttt{Examples/Hubbard\_SU2\_Honeycomb/}.
 
\subsection{Working with multi-orbital unit cells:  \texttt{Call Ham\_Latt} }

  This model is an example of  a multi-orbital unit cell, and the aim of this section is to document how  implement this in the code.  The  Honeycomb lattice is a  triangular Bravais lattice the two orbitals per unit cell.  The routine  \texttt{Ham\_Latt} will set: 

\begin{lstlisting}

Norb    = 2
N_coord = 3
a1_p(1) =  1.D0   ; a1_p(2) =  0.d0
a2_p(1) =  0.5D0  ; a2_p(2) =  sqrt(3.D0)/2.D0             
L1_p    =  dble(L1) * a1_p
L2_p    =  dble(L2) * a2_p
            
\end{lstlisting}
and then  call \texttt{ Make\_Lattice( L1\_p, L2\_p, a1\_p,  a2\_p, Latt ) } so as to generate the triangular lattice.  The coordination number of this lattice is \texttt{ N\_coord=3 }  and  the number of orbitals per unit cell  corresponds to \texttt{NORB=2}.    The total number of  orbitals  is thereby: \texttt{$N_{\mathrm{dim}}$=Latt\%N*NORB}.    To easily keep track of the orbital and unit cell, we define a  super-index as shown below:


\begin{lstlisting}

Allocate (List(Ndim,2), Invlist(Latt%N,Norb))
nc = 0
Do I = 1,Latt%N           ! Unit-cell index 
   Do no = 1,Norb         ! Orbital index
      nc = nc + 1         ! Super index labeling unit cell and orbital
      List(nc,1) = I      ! Unit-cell  of super index  nc
      List(nc,2) = no     ! Orbital of super inde nc
      Invlist(I,no) = nc  ! Super index for given  unit cell and orbital
  Enddo
Enddo

\end{lstlisting}

With the above lists one can run trough all the orbitals and at each time keep track of the unit-cell and orbital index.    We note that when translation symmetry is completely absent  one can work with on unit cell, and the  number of orbitals will then correspond to the  number of lattice sites. 

\subsection{The hopping term:  \texttt{Call Ham\_Hop} }

Some care has to be taken when setting the hopping matrix.    In the Hamilton module \path{Hamiltonian_Examples.f90}   we do this in the following way. 

\begin{lstlisting}

DO I = 1, Latt%N                              ! Loop over unit cell 
   do no = 1,Norb                             ! Runs over orbitals and sets chemical potential
      I1 = invlist(I,no)  
      Op_T(nc,n)%O(I1 ,I1) = cmplx(-Ham_chem, 0.d0, kind(0.D0))
   enddo
   I1 = Invlist(I,1)                          ! Orbital A of unit cell I
   Do nc1 = 1,N_coord                         ! Loop over coordination  number
      select case (nc1)
      case (1)
         J1 = invlist(I,2)                    ! Orbital B of unit cell i
      case (2)
         J1 = invlist(Latt%nnlist(I,1,-1),2)  ! Orbital B of unit cell i + a_1 - a_2
      case (3)
         J1 = invlist(Latt%nnlist(I,0,-1),2)  ! Orbital B of unit cell i - a_1 
      case default
         Write(6,*) ' Error in  Ham_Hop '  
      end select
      Op_T(nc,n)%O(I1,J1) = cmplx(-Ham_T,    0.d0, kind(0.D0))   
      Op_T(nc,n)%O(J1,I1) = cmplx(-Ham_T,    0.d0, kind(0.D0))
   Enddo
Enddo

\end{lstlisting}
As apparent from the above, hopping matrix elements   are non-zero only between the A and B  sublattices. 


\subsection{Observables:  \texttt{Call Obser},   \texttt{Call ObserT}}

In the multi-orbital case,  the correlation functions have additional orbital indices. This is automatically taken care of in the routines \texttt{Call Obser} and \texttt{Call ObserT}  since  we considered the  Hubbard model on the square lattice to correspond to a multi-orbital unit cell albeit with the special choice of one orbital per unit cell. 

 
\section{Walkthrough: the $SU(2)$-Hubbard model on a square lattice coupled to a transverse Ising field}\label{sec:walk2}

The model we consider here  is very similar to the  above,  but has an additional coupling to a transverse field. 
\begin{eqnarray}
\label{eqn_hubbard_sun_Ising}
\mathcal{H}= & & 
\sum\limits_{\sigma=1}^{2} 
\sum\limits_{x,y } 
  c^{\dagger}_{x \sigma} T_{x,y}c^{\phantom\dagger}_{y \sigma} 
+ \frac{U}{2}\sum\limits_{x}\left[
\sum\limits_{\sigma=1}^{2}
\left(  c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{x \sigma}  -1/2 \right) \right]^{2}   
+  \xi \sum_{\sigma,\langle x,y \rangle} \hat{Z}_{\langle x,y \rangle}  \left( c^{\dagger}_{x \sigma} c^{\phantom\dagger}_{y \sigma}  + h.c. \right)  \nonumber \\ 
 & & - h \sum_{\langle x,y \rangle} \hat{X}_{\langle x,y \rangle}   - J \sum_{\langle \langle x,y \rangle \langle x',y' \rangle \rangle} 
  \hat{Z}_{\langle x,y \rangle}   \hat{Z}_{\langle x',y' \rangle} 
\end{eqnarray}
We can make contact with the general form of the Hamiltonian by setting: 
$N_{\mathrm{fl}} = 1$, $N_{\mathrm{col}} \equiv \texttt{N\_SUN}     =2 $,   $M_T    =    1$,  $T^{(ks)}_{x y}   =  T_{x,y}$,  $M_V   =  N_{\text{unit cell}} \equiv N_{\mathrm{dim}}$,  $U_{k}       =   -\frac{U}{2}$, 
 $V_{x y}^{(ks)} =  \delta_{x,y} \delta_{x,k}$,  $\alpha_{ks}   =  \frac{1}{2}  $ and $M_I       = 2 N_{\text{unit cell}} $.  
 The last two terms of the  above Hamiltonian describes a  transverse Ising field model on the bonds of the square lattice.  This  type of Hamiltonian  has  recently been extensively discussed  \cite{Schattner15,Xu16,Assaad16}.  Here we adopt the notation of Ref.~\cite{Assaad16}. Note that   $\langle \langle x,y \rangle \langle x',y' \rangle \rangle $ denotes nearest neighbor bonds.
The modifications  required to generalize the Hubbard model code to the above model are two-fold. 


Firstly,  one has to specify the function \texttt{Real (Kind=8) function S0(n,nt)} and  secondly  modify the interaction \texttt{Call Ham\_V}.

A sample run for this model can be found in \texttt{Examples/Hubbard\_SU2\_Ising\_Square/}.

\subsection{The interaction term: \texttt{Call Ham\_V}}
The dimension of   \texttt{Op\_V}  is now  $(M_I + M_V)\times N_{\mathrm{fl}}=(3*N_{\mathrm{dim}}) \times 1$. 
We set the effective dimension  for the Hubbard term to  $N=1$  and to  $N=2$ for the Ising term. The allocation of this array of operators reads: 

\begin{lstlisting}

do i  = 1,N_coord*Ndim    !  Runs  over bonds for Ising variable
  call Op_make(Op_V(i,1),2)
enddo
do i  =  N_coord*Ndim+1, (N_coord+1)*Ndim   ! Runs over sites for Hubbard
  call Op_make(Op_V(i,1),1)
enddo

\end{lstlisting}

The  first  \texttt{N\_coord*Ndim} operators run through the 2N bonds of the square lattice and   are given by:
\begin{lstlisting}

Do nc = 1,Ndim*N_coord   ! Runs over bonds.  Coordination number = 2.
                         ! For the square lattice Ndim = Latt%N
  
   I1 = L_bond_inv(nc,1) ! Site one of the bond.  
	                 ! L_bond_inv is setup in Setup_Ising_action
   if ( L_bond_inv(nc,2)  == 1 ) I2 = Latt%nnlist(I1,1,0)   ! Site two of the bond 
   if ( L_bond_inv(nc,2)  == 2 ) I2 = Latt%nnlist(I1,0,1) 
   Op_V(nc,1)%P(1) = I1
   Op_V(nc,1)%P(2) = I2
   Op_V(nc,1)%O(1,2) = cmplx(1.d0 ,0.d0, kind(0.D0))
   Op_V(nc,1)%O(2,1) = cmplx(1.d0 ,0.d0, kind(0.D0))
   Op_V(nc,1)%g = cmplx(-dtau*Ham_xi,0.D0,kind(0.D0))
   Op_V(nc,1)%alpha = cmplx(0d0,0.d0, kind(0.D0))
   Op_V(nc,1)%type =1
Enddo

\end{lstlisting}
Here,  \texttt{ham\_xi} defines the coupling strength  between the Ising  and fermion degree of freedom.
As for the Hubbard case, the first \texttt{Ndim}  operators read: 

\begin{lstlisting}

nc = N_coord*Ndim 
Do nc  = i = 1, Ndim
    nc = nc + 1
    Op_V(nc,1)%P(1)   = i 
    Op_V(nc,1)%O(1,1) = cmplx(1.d0  ,0.d0, kind(0.D0))
    Op_V(nc,1)%g      = sqrt(cmplx(-dtau*ham_U/(DBLE(N_SUN)), 0.D0, kind(0.D0)))
    Op_V(nc,1)%alpha  = cmplx(-0.5d0,0.d0, kind(0.D0))
    Op_V(nc,1)%type   = 2
Enddo

\end{lstlisting}


\subsection{The function \texttt{Real (Kind=8) function S0(n,nt)} }\label{sec:s0}
As mentioned above,  a configuration is given by
\begin{equation}
	C = \left\{   s_{i,\tau} ,  l_{j,\tau}  \text{ with }  i=1\cdots M_I,  j = 1\cdots M_V,  \tau=1,L_{Trotter}  \right\}
\end{equation}
and is stored in the  integer array \texttt{nsigma(M\_V + M\_I, Ltrot)}.  With the above ordering of Hubbard and Ising interaction terms,  and a for a given  imaginary time, the first \path{Ndim} 
fields corresponds to the Hubbard  interaction and the next \texttt{2*Ndim} ones to the Ising interaction.    The first   argument of the function \texttt{S0}, \texttt{n},  corresponds to the index of the operator  string 
\texttt{Op\_V(n,1)}. If \texttt{Op\_V(n,1)\%type = 2},    \texttt{S0(n,nt)}  returns 1.  If   \texttt{Op\_V(n,1)\%type = 1}  then function \texttt{S0}  returns
\begin{equation}
\frac{e^{-S_{0,I} \left(  s_{1,\tau},  \cdots,  - s_{m,\tau},  \cdots s_{M_I,\tau}   \right) } }{e^{-S_{0,I}  \left(  s_{1,\tau},  \cdots,   s_{m,\tau},  \cdots s_{M_I,\tau}   \right)   } }	
\end{equation}
That is,  $ \texttt{S0(n,nt)} $  returns the ratio of the new to old weight  of the  Ising Hamiltonian upon flipping a single Ising spin $ s_{m,\tau} $. Note that in  this specific case  \texttt{ m = n -  Ndim } 
 

\section{Other models}
  The aim of this section is to briefly mention  a small  selection of  other models that can be simulated within the ALF-project.  
\subsection{The Kondo lattice}
 Simulating the Kondo lattice within the ALF-project   requires rewriting of the model along the lines of Refs.~\cite{Assaad99a,Capponi00,Beach04}.   Adopting the notation of these articles,   the Hamiltonian that one will simulate reads: 
 \begin{equation}
 	\hat{H}  = 
	\underbrace{-t \sum_{\langle  \vec{i},\vec{j} \rangle,\sigma} \left( \hat{c}_{\vec{i},\sigma}^{\dagger}  \hat{c}_{\vec{j},\sigma}^{\phantom\dagger}   + \text{H.c.} \right) }_{\equiv \hat{H}_t} - \frac{J}{4} 
	\sum_{\vec{i}} \left( \sum_{\sigma} \hat{c}_{\vec{i},\sigma}^{\dagger}  \hat{f}_{\vec{i},\sigma}^{\phantom\dagger}  + 
	                                                        \hat{f}_{\vec{i},\sigma}^{\dagger}  \hat{c}_{\vec{i},\sigma}^{\phantom\dagger}   \right)^{2}   +
        \underbrace{\frac{U}{2}   \sum_{\vec{i}}   \left( \hat{n}^{f}_{\vec{i}} -1 \right)^2}_{\equiv \hat{H}_U}.
 \end{equation}
This from is included in Eq.~\ref{eqn:general_ham_i}    such the above  Hamiltonian can  be implemented in our program package.  The  relation to the Kondo lattice mdel follows  from expanding the square  of the hybridization to obtain: 
 \begin{equation}
 	\hat{H}  =\hat{H}_t   
	+ J \sum_{\vec{i}}  \left(  \hat{\vec{S}}^{c}_{\vec{i}} \cdot  \hat{\vec{S}}^{f}_{\vec{i}}    +   \hat{\eta}^{z,c}_{\vec{i}} \cdot  \hat{\eta}^{z,f}_{\vec{i}}  
		-  \hat{\eta}^{x,c}_{\vec{i}} \cdot  \hat{\eta}^{x,f}_{\vec{i}}  -  \hat{\eta}^{y,c}_{\vec{i}} \cdot  \hat{\eta}^{y,f}_{\vec{i}} \right) 
	 + \hat{H}_U.
 \end{equation}
 where the $\eta$-operators  related to the spin-operators via a particle-hole transformation in one spin sector: 
 \begin{equation} 
 	\hat{\eta}^{\alpha}_{\vec{i}}  = \hat{P}^{-1}  \hat{S}^{\alpha}_{\vec{i}} \hat{P}  	\; \text{ with }  \;   
	\hat{P}^{-1}  \hat{c}^{\phantom\dagger}_{\vec{i},\uparrow} \hat{P}  =   (-1)^{i_x+i_y} \hat{c}^{\dagger}_{\vec{i},\uparrow}  \; \text{ and }  \;   
	\hat{P}^{-1}  \hat{c}^{\phantom\dagger}_{\vec{i},\downarrow} \hat{P}  = \hat{c}^{\phantom\dagger}_{\vec{i},\downarrow} 
 \end{equation}
 Since the $\hat{\eta}^{f} $ and $ \hat{S}^{f} $ operators  do not alter the  parity [$(-1)^{\hat{n}^{f}_{\vec{i}}}$ ] of the $f-$sites, 
 \begin{equation}
 	\left[  \hat{H}, \hat{H}_U \right] = 0.
 \end{equation}
 Thereby,  and for positive values of $U$ ,  doubly occupied  or empty f-sites corresponding to even parity will be suppressed  by a  Boltzmann factor 
 $e^{-\beta U/2} $ is comparison to odd parity ones.   Choosing $\beta U $ adequately will  essentially allow to  restrict the Hilbert space to  odd parity f-sites.  In this Hilbert space $\hat{\eta}^{x,f} = \hat{\eta}^{y,f} =  \hat{\eta}^{z,f} =0$  such that the Hamiltonian reduces to the Kondo lattice model. 
 
\subsection{SU(N) Hubbard-Heisenberg models}
SU(2N) Hubbard-Heisenberg \cite{Assaad04,Lang13} models can be written as:
\begin{equation}
 \hat{H}  =  
 \underbrace{ - t \sum_{ \langle \vec{i},\vec{j} \rangle }    \left(  \vec{\hat{c}}^{\dagger}_{\vec{i}}  \vec{\hat{c}}^{\phantom{\dagger}}_{\vec{j}} + \text{H.c.} \right) }_{\equiv \hat{H}_t} \; \; 
\underbrace{ -\frac{J}{2 N}  \sum_{ \langle \vec{i},\vec{j} \rangle  } \left(
           \hat{D}^{\dagger}_{ \vec{i},\vec{j} }\hat{D}^{\phantom\dagger}_{ \vec{i},\vec{j}}  +
            \hat{D}^{\phantom\dagger}_{ \vec{i},\vec{j} } \hat{D}^{\dagger}_{ \vec{i},\vec{j} }  \right) }_{\equiv\hat{H}_J}
            + 
 \underbrace{\frac{U}{N}  \sum_{\vec{i}} \left(
             \vec{\hat{c}}^{\dagger}_{\vec{i}}  \vec{\hat{c}}^{\phantom\dagger}_{\vec{i}} -  {\frac{N}{2} } \right)^2}_{\equiv \hat{H}_U}
\end{equation}
Here,
$ \vec{\hat{c}}^{\dagger}_{\vec{i}} =
(\hat{c}^{\dagger}_{\vec{i},1},  \hat{c}^{\dagger}_{\vec{i},2}, \cdots, \hat{c}^{\dagger}_{\vec{i}, N } ) $  is an
$N$-flavored spinor, and $ \hat{D}_{ \vec{i},\vec{j}} = \vec{\hat{c}}^{\dagger}_{\vec{i}}
\vec{\hat{c}}_{\vec{j}}  $.
To use the present package to simulate this model, one will rewrite  the $J$-term as a sum of perfect squares, 
\begin{equation}
        \hat{H}_J =  -\frac{J}{4 N}  \sum_{  \langle \vec{i}, \vec{j} \rangle }
        \left(\hat{D}^{\dagger}_{  \langle \vec{i}, \vec{j} \rangle  } +  \hat{D}_{  \langle \vec{i}, \vec{j} \rangle }  \right)^2  -
        \left(\hat{D}^{\dagger}_{   \langle \vec{i}, \vec{j} \rangle } -  \hat{D}_{  \langle \vec{i}, \vec{j} \rangle}  \right)^2,
\end{equation}
so to manifestly bring it into the form of Eq.~\ref{eqn:general_ham_i}.  It is amusing to note that setting the hopping $t=0$,    charge fluctuations  will be suppressed by the  Boltzmann factor $e^{\beta U /N \left(  \vec{\hat{c}}^{\dagger}_{\vec{i}}  \vec{\hat{c}}^{\phantom\dagger}_{\vec{i}} -  {\frac{N}{2} } \right)^2 } $ since in this case  
$ \left[   \hat{H}, \hat{H}_U \right]  = 0 $. This provides a route to use the auxiliary field QMC algorithm so as to simulate -- free of the sign problem -- SU(2N) Heisenberg models in the self-adjoint antisymmetric representation  \footnote{ This corresponds to a Young tableau with single column and $N/2$ rows.}  
For odd values of $N$ recent progress  in our understanding of the  origins of the sign problem \cite{Wei16}  will allows us to simulate -- without encountering the sign problem -- a set of non-trivial Hamiltonians \cite{Li15,Assaad16}.
 

