% Copyright (c) 2016 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex
%------------------------------------------------------------
\subsection{File structure}\label{sec:files}
%------------------------------------------------------------
%
\begin{table}[h]
	\begin{tabular}{@{} l l @{}}\toprule
   	Directory & Description \\\midrule
   	\path{Prog/} & Main program and subroutines.  \\
   	\path{Libraries/} & Collection of mathematical routines. \\  
  	\path{Analysis/} & Routines for error analysis. \\
  	\path{Scripts_and_Parameters_files/}   & Helper scripts and the \path{Start/} directory, which contains the files \\ 
  	                                      & required to start a run. \\
  	\path{Documentation/} & This documentation.\\
  	\path{testsuite/} & A suite for automatic testing various parts of the code.\\\bottomrule
  	\hline
	\end{tabular}
   	\caption{Overview of the directories included in the ALF package.\label{table:files}}
\end{table}
%

The code package, summarized in Table~\ref{table:files}, consists of the program directories \path{Prog/}, \path{Libraries/}, and \path{Analysis/}, as well as the directory \path{Scripts_and_Parameters_files/}, which contains supporting scripts and, in its subdirectory \path{Start}, the input files necessary for a run, described in the Sec.~\ref{sec:input}. Additionally, a suite of tests for individual parts of the code (subroutines, functions, operations, etc.) is available at the directory \path{testsuite} -- the tests can be run by executing the following sequence of commands (the script \path{configureHPC.sh} sets environment variables and is described in Sec.~\ref{sec:running}.):
\begin{lstlisting}[style=bash,morekeywords={make,cmake,ctest}]

source configureHPC.sh Devel serial
gfortran -v
make lib
make ana
make Examples
cd testsuite
cmake -E make_directory tests
cd tests
cmake -G "Unix Makefiles" -DCMAKE_Fortran_FLAGS_RELEASE=${F90OPTFLAGS} \
      -DCMAKE_BUILD_TYPE=RELEASE ..
cmake --build . --target all --config Release
ctest -VV -O log.txt
\end{lstlisting}
which will output test results and total success rate.
%The example simulations corresponding to the walkthroughs of Sec.~\ref{sec:walk1} - \ref{sec:walk2} are included in \path{Examples/}.

%------------------------------------------------------------
\subsubsection{Input files}\label{sec:input}
%------------------------------------------------------------
%
\begin{table}[h]
   \begin{tabular}{@{} l l @{}}\toprule
   File & Description \\\midrule
  \path{parameters} &  Sets the parameters for lattice, model, QMC process, and the error analysis.\\
  \path{seeds} & List of integer numbers to initialize the random number generator and \\
   & to start a simulation from scratch.
   %\\
 %  \path{confin_<thread number>} & Input files for the HS and Ising configuration, used to continue a simulation.
  \\\bottomrule
   \end{tabular}
   \caption{Overview of the input files required for a simulation, which can be found in the subdirectory \texttt{Scripts\_and\_Parameters\_files/Start/}. \label{table:input}}
\end{table}
%
The input files are listed in Table~\ref{table:input}. 
The parameter file \path{Start/parameters} has the following form --
using as an example  the $SU(2)$-symmetric Hubbard model on a square lattice (see Sec.~\ref{sec:walk1} for a detailed walkthrough):
%
\begin{lstlisting}[style=fortran]

!===============================================================================
!  Variables for the Hubb program
!-------------------------------------------------------------------------------
&VAR_lattice
L1 = 4                    ! Length in direction a_1
L2 = 4                    ! Length in direction a_2
Lattice_type = "Square"	  ! a_1 = (1,0), a_2=(0,1), Norb=1, N_coord=2
!Lattice_type ="Honeycomb"! a_1 = (1,0), a_2 =(1/2,sqrt(3)/2), Norb=2, N_coord=3
Model = "Hubbard_SU2"     ! Sets Nf=1, N_sun=2. HS field couples to the density
!Model = "Hubbard_Mz"     ! Sets Nf=2, N_sun=1. HS field couples to the 
                          ! z-component of magnetization.  
!Model="Hubbard_SU2_Ising"! Sets Nf_1, N_sun=2 and runs only for the square lattice
                          ! Hubbard model coupled to transverse Ising field
/

&VAR_Hubbard              ! Variables for the Hubbard model
ham_T   = 1.d0            ! Hopping parameter
ham_chem= 0.d0            ! chemical potential
ham_U   = 4.d0            ! Hubbard interaction
Beta    = 10.d0           ! inverse temperature
dtau    = 0.1d0           ! Thereby Ltrot=Beta/dtau
/

&VAR_Ising                ! Model parameters for the Ising code
Ham_xi = 1.d0             ! Only needed if Model="Hubbard_SU2_Ising"
Ham_J  = 0.2d0
Ham_h  = 2.d0
/

&VAR_QMC                  ! Variables for the QMC run
Nwrap   = 10              ! Stabilization. Green functions will be computed from 
                          ! scratch after each time interval Nwrap*Dtau
NSweep  = 10              ! Number of sweeps
NBin    = 10              ! Number of bins
Ltau    = 1               ! 1 for calculation of time displaced Green functions;
                          ! 0 otherwise
LOBS_ST = 1               ! Start measurements at time slice LOBS_ST
LOBS_EN = 100             ! End   measurements at time slice LOBS_EN
CPU_MAX = 0.1             ! Code will stop after CPU_MAX hours. 
                          ! If not specified, code will stop after Nbin bins.
/

&VAR_errors               ! Variables for analysis programs
n_skip  = 1               ! Number of bins that will be skipped. 
N_rebin = 1               ! Rebinning  
N_Cov   = 0               ! If set to 1 covariance will be computed
                          ! for non-equal-time correlation functions.                   
/            
\end{lstlisting}
%

The program allows for a number of different  updating schemes.  If no other variables are specified in the \texttt{VAR\_QMC} name space, then the program will run in its default mode, namely the sequential single spin-flip mode.   The additional, optional variables in   \texttt{VAR\_QMC}   include the following: 
\begin{lstlisting}[style=fortran]

&VAR_QMC                 ! Variables for the QMC run 
Propose_S0      = .true. ! Proposes single spin flip moves with probability exp(-S0) 
Global_moves    = .true. ! Allows for global moves in space and time 
N_Global        = 1      ! Number of global moves  per sweep 
Global_tau_moves= .true. ! Allows for global moves on a single time slice.  
N_Global_tau    = 10     ! Number of global moves that will be carried out on a 
                         ! single time slice
Nt_sequential_start = 1  ! One can combine sequential and global moves on 
                         ! a time slice.  
Nt_sequential_end =      ! The program will carry our sequential local moves in the
                         ! range [Nt_sequential_start, Nt_sequential_end] and then
                         ! N_Global_tau global moves
/   
\end{lstlisting}
Note that if \texttt{Nt\_sequential\_start}  and \texttt{Nt\_sequential\_end}  are not specified and that the variable \texttt{Global\_tau\_moves}  is set to true, then  the program will  carry out only global moves, by setting  \\  \texttt{Nt\_sequential\_start=1}  and \texttt{Nt\_sequential\_end=0}. 

If the program is compiled with the parallel tempering flag, then the additional name space \texttt{VAR\_TEMP} has to be included in the parameter file.
\begin{lstlisting}[style=fortran,escapechar=\%]

&VAR_TEMP                      ! Variables for parallel tempering
N_exchange_steps      = 6      ! Number of exchange moves %[see Eq.~\eqref{eq:exchangestep}]%
N_Tempering_frequency = 10     ! The frequency in units of sweeps at which the
                               ! exchange moves will be carried 
mpi_per_parameter_set = 2      ! Number of mpi-processes per parameter set
Tempering_calc_det    = .true. ! Specifies whether the fermion weight has to be taken
                               ! into account while tempering. The default is .true.,
                               ! and it can be set to .false. if the parameters that
                               ! get varied only enter the Ising action S_0
/
\end{lstlisting}

Additionally, in order for the maximum entropy code, described in Sec.~\ref{sec:maxent}, to be used, the namelist \texttt{VAR\_Max\_Stoch} should also be defined:
\begin{lstlisting}[style=fortran]

&VAR_Max_Stoch               ! Variables for Stochastic Maximum entropy
Ngamma     = 400             ! # of Dirac delta-functions for parametrization
Om_st      = 0               ! Frequency range lower bound
Om_en      = 8               ! Frequency range upper bound
NDis       = 2000            ! # of boxes for histogram
Nbins      = 250             ! # of bins for Monte Carlo
Nsweeps    = 70              ! # of sweeps per bin
NWarm      = 20              ! The Nwarm first bins will be ommitted
N_alpha    = 14              ! # of tempertures
alpha_st   = 1.d0            ! smallest inverse temperature
R          = 1.2d0           ! increment for inverse temperature (see above) 
Channel    = "P"             ! T0       : Zero temperature
                             ! P        : Finite temperarure particle 
                             ! PH       : Finite temperarure particle-hole
                             ! PP       : Finite temperarure particle-particle 
Checkpoint = .false.         !.true.    : dump files will be produced so as to be able
                             !            to restart the simulation
                             !.false.   : dump files will not be produced 
Tolerance  = 0.1d0           ! Data points for which the relative error exceeds the
                             ! tolerance threshold will be omitted.
/
\end{lstlisting}


%------------------------------------------------------------
\subsubsection{Output: Observables} \label{sec:output_obs}
%------------------------------------------------------------
%
\begin{table}[h]
   \begin{tabular}{@{} l l @{}}\toprule
   File & Description \\\midrule
   \path{info} & After completion of the simulation, this file documents the parameters of\\
   & the model, as well as the QMC run and simulation metrics (precision,\\
   & acceptance rate, wallclock time).\\
   \path{X_scal} & Results of equal-time measurements of scalar observables. \\
   & The placeholder \path{X} stands for the observables \path{Kin}, \path{Pot}, \path{Part}, and \path{Ener}. \\
   \path{Y_eq, Y_tau} & Results of equal-time and time-displaced measurements of correlation\\
   & functions. The placeholder \path{Y} stands for \path{Green}, \path{SpinZ}, \path{SpinXY}, and \path{Den}. \\   
   \path{confout_<thread number>} & Output files (one per MPI instance) for the HS and Ising configuration. \\\bottomrule
   \end{tabular}
   \caption{Overview of the standard output files. See Sec.~\ref{sec:obs} for the definitions of observables and correlation functions. \label{table:output}}
\end{table}
%
The standard output files are listed in Table~\ref{table:output}. 
The output of the measured data is organized in bins. One bin corresponds to the arithmetic average 
over a fixed number of individual measurements which depends 
on the chosen measurement interval \path{[LOBS_ST,LOBS_EN]} on the imaginary-time axis and on the number \path{NSweep} of Monte Carlo sweeps. If the user runs an MPI parallelized version of the code, the average also extends over the number of MPI threads. The formatting of a single bin's output depends on the observable type, \path{Obs_vec} or \path{Obs_Latt}:
\begin{itemize}
\item Observables of type \path{Obs_vec}:
For each additional bin, a single new line is added to the output file.
In case of an observable with \path{N_size} components, the formatting is 
\begin{verbatim}
N_size + 1    <measured value, 1> ... <measured value, N_size>    <measured sign>
\end{verbatim}
The counter variable \path{N_size+1} refers to the number of measurements per line, including the phase measurement. 
This format is required by the error analysis routine (see Sec.~\ref{sec:analysis}). 
Scalar observables like kinetic energy, potential energy, total energy and particle number are treated as a vector 
of size \path{N_size=1}.

\item Observables of type \path{Obs_Latt}:
For each additional bin, a new data block is added to the output file. 
The block consists of the expectation values [Eq.~(\ref{eqn:o})] contributing to the background part [Eq.~(\ref{eqn:s_back})] of the correlation function,
and the correlated part [Eq.~(\ref{eqn:s_corr})] of the correlation function.
For imaginary-time displaced correlation functions, the formatting of the block is given by:
\begin{alltt}
<measured sign>  <N_orbital>  <N_unit_cell>  <N_time_slices>  <dtau>
do alpha = 1, N_orbital
    \(\langle\hat{O}\sb{\alpha}\rangle \)
enddo
do i = 1, N_unit_cell
   <reciprocal lattice vector k(i)>
   do tau = 1, N_time_slices
      do alpha = 1, N_orbital
         do beta = 1, N_orbital
            \(\langle{S}\sb{\alpha,\beta}\sp{(\mathrm{corr})}(k(i),\tau)\rangle\)
         enddo
      enddo
   enddo
enddo
\end{alltt}
The same block structure is used for equal-time correlation functions, except for the entries  \path{<N_time_slices>} and \path{<dtau>}, which are then omitted.
Using this structure for the bins as input, the full correlation function $S_{\alpha,\beta}(\vec{k},\tau)$ [Eq.~(\ref{eqn:s})] is then calculated by calling the error analysis routine (see Sec.~\ref{sec:analysis}).
\end{itemize}

%
%------------------------------------------------------------
\subsubsection{Output: Precision} \label{sec:output_prec}
%------------------------------------------------------------
%


\red{[THIS SECTION MAYBE BELONGS INTO THE "RUNNING"...]}

The finite-temperature, auxiliary-field QMC algorithm is known to be numerically unstable, as discussed in Sec.~\ref{sec:stable}.
The numerical instabilities arise from the imaginary-time propagation, which invariably leads to exponentially small and exponentially large scales.
As shown in Ref.~\cite{Assaad08_rev}, scales can be omitted in the ground state algorithm -- thus rendering it very stable --  but have to be taken into account in the  finite-temperature code.

Numerical stabilization of the code is a delicate procedure that has been pioneered in Ref.~\cite{White89}  for the finite-temperature algorithm and in Refs.~\cite{Sugiyama86,Sorella89} for the zero-temperature projective algorithm.
It is important to be aware of the fragility of the numerical stabilization and that there is no guarantee that it will work for a given model. It is therefore crucial to always check the file \texttt{info}, which, apart from runtime data, contains important information concerning the stability of the code, in particular \texttt{Precision Green}.
If the numerical stabilization fails, one possible measure is to reduce the value of the parameter \texttt{Nwrap} in the parameter file, which will however also impact performance -- see Sec.~\ref{sec:optimize} for further optimization tips.

For performing the stabilization of the involved matrix multiplications we rely on routines from LAPACK. Notice that results are very likely to change
%significantly
depending on the specific implementation of the library used\footnote{The linked library should implement at least the LAPACK-3.4.0 interface.}.
In order to deal with this possibility, we offer a simple baseline which can be used as a quick check as tho whether results depend on the library used for linear algebra routines. Namely, we have included QR-decomposition related routines of the LAPACK-3.6.1 reference implementation from \url{http://www.netlib.org/lapack/}, which you can use by 
%including the switch \texttt{-DQRREF} into the \texttt{STABCONFIGURATION} string in the 
running the script \path{configureHPC.sh}, (described in Sec.~\ref{sec:running}), with the flag \texttt{STAB1} and recompiling ALF\footnote{This flag may trigger compiling issues, in particular, the Intel ifort compiler version 10.1 fails for all optimization levels.}.

In order to provide further flexibility, we offer various stabilization schemes that can be selected through the appropriate flags when running \texttt{configureHPC.sh}: \red{[MAKE A TABLE INSTEAD?]} \texttt{STAB1}, for using the reference stabilization scheme;
\texttt{STAB2}, which sets a stabilization scheme based on the QR decomposition, but not using the LAPACK reference implementation and with additional normalizations;
\texttt{STAB3}, for the newest and fastest stabilization, which separates large and small scales -- it generally works well, but there are models for which it fails;
and \texttt{LOG}, for using log storage for internal scales.

Typical values for the numerical precision can be found in the examples of Sec.~\ref{sec:ex} (see Sec.~\ref{sec:prec_charge} and \ref{sec:prec_spin}).

%------------------------------------------------------------
\subsection{Scripts}\label{sec:scripts}
%------------------------------------------------------------
%

\red{[IMPROVE or eliminate?]}

\begin{table}[h]
   \begin{tabular}{@{} l l l @{}}\toprule
   Script & Description & Section\\\midrule
   \path{Start/out_to_in.sh} & Copies the output field configurations to the respective input files. & \ref{sec:running} \\
   \path{Start/analysis.sh} & Starts the error analysis. & \ref{sec:analysis}\\\bottomrule
   \end{tabular}
   \caption{Overview of the bash script files. 
      \label{table:scripts}}
\end{table}
%
