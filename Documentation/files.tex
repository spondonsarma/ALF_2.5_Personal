% Copyright (c) 2016 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex
%------------------------------------------------------------
\subsection{File structure}\label{sec:files}
%------------------------------------------------------------
%
\begin{table}[h]
	\begin{tabular}{@{} l l @{}}\toprule
   	Directory & Description \\\midrule
   	\path{Prog/} & Main program and subroutines.  \\
   	\path{Libraries/} & Collection of mathematical routines. \\  
  	\path{Analysis/} & Routines for error analysis. \\
  	\path{Scripts_and_Parameters_files/}   & Helper scripts and the \path{Start/} directory, which contains the files \\ 
  	                                      & required to start a run. \\
  	\path{Documentation/} & This documentation.\\
  	\path{testsuite/} & A suite for automatic testing various parts of the code.\\\bottomrule
  	\hline
	\end{tabular}
   	\caption{Overview of the directories included in the ALF package.\label{table:files}}
\end{table}
%

The code package, summarized in Table~\ref{table:files}, consists of the program directories \path{Prog/}, \path{Libraries/}, and \path{Analysis/}, as well as the directory \path{Scripts_and_Parameters_files/}, which contains supporting scripts and, in its subdirectory \path{Start}, the input files necessary for a run, described in the Sec.~\ref{sec:input}.
The routines available in the directory \path{Analysis/} are described in Sec.~\ref{sec:analysis}, and the testsuite in Sec.~\ref{sec:compilation}. 

Below we describe the structure of the input and output files of the QMC. Notice that the input/output files for the Analysis routines are described in Sec.~\ref{sec:analysis}.

%------------------------------------------------------------
\subsubsection{Input files}\label{sec:input}
%------------------------------------------------------------
%

The input files are listed in Table~\ref{table:input}. 
The parameter file \path{Start/parameters} has the following form --
using as an example  the $SU(2)$-symmetric Hubbard model on a square lattice (see Sec.~\ref{sec:walk1} for a detailed walkthrough):
%
\begin{lstlisting}[style=fortran]

!===============================================================================
!  Variables for the Hubb program
!-------------------------------------------------------------------------------
&VAR_lattice
L1 = 4                    ! Length in direction a_1
L2 = 4                    ! Length in direction a_2
Lattice_type = "Square"	  ! a_1 = (1,0), a_2=(0,1), Norb=1, N_coord=2
!Lattice_type ="Honeycomb"! a_1 = (1,0), a_2 =(1/2,sqrt(3)/2), Norb=2, N_coord=3
Model = "Hubbard_SU2"     ! Sets Nf=1, N_sun=2. HS field couples to the density
!Model = "Hubbard_Mz"     ! Sets Nf=2, N_sun=1. HS field couples to the 
                          ! z-component of magnetization.  
!Model="Hubbard_SU2_Ising"! Sets Nf_1, N_sun=2 and runs only for the square lattice
                          ! Hubbard model coupled to transverse Ising field
/

&VAR_Hubbard              ! Variables for the Hubbard model
ham_T   = 1.d0            ! Hopping parameter
ham_chem= 0.d0            ! chemical potential
ham_U   = 4.d0            ! Hubbard interaction
Beta    = 10.d0           ! inverse temperature
dtau    = 0.1d0           ! Thereby Ltrot=Beta/dtau
/

&VAR_Ising                ! Model parameters for the Ising code
Ham_xi = 1.d0             ! Only needed if Model="Hubbard_SU2_Ising"
Ham_J  = 0.2d0
Ham_h  = 2.d0
/

&VAR_QMC                  ! Variables for the QMC run
Nwrap   = 10              ! Stabilization. Green functions will be computed from 
                          ! scratch after each time interval Nwrap*Dtau
NSweep  = 10              ! Number of sweeps
NBin    = 10              ! Number of bins
Ltau    = 1               ! 1 for calculation of time displaced Green functions;
                          ! 0 otherwise
LOBS_ST = 1               ! Start measurements at time slice LOBS_ST
LOBS_EN = 100             ! End   measurements at time slice LOBS_EN
CPU_MAX = 0.1             ! Code will stop after CPU_MAX hours. 
                          ! If not specified, code will stop after Nbin bins.
/

&VAR_errors               ! Variables for analysis programs
n_skip  = 1               ! Number of bins that will be skipped. 
N_rebin = 1               ! Rebinning  
N_Cov   = 0               ! If set to 1 covariance will be computed
                          ! for non-equal-time correlation functions.                   
/            
\end{lstlisting}
%

\begin{table}[h]
	\begin{tabular}{@{} l l @{}}\toprule
		File & Description \\\midrule
		\path{parameters} &  Sets the parameters for lattice, model, QMC process, and the error analysis.\\
		\path{seeds} & List of integer numbers to initialize the random number generator and \\
		& to start a simulation from scratch.
		%\\
		%  \path{confin_<thread number>} & Input files for the HS and Ising configuration, used to continue a simulation.
		\\\bottomrule
	\end{tabular}
	\caption{Overview of the input files required for a simulation, which can be found in the subdirectory \texttt{Scripts\_and\_Parameters\_files/Start/}. \label{table:input}}
\end{table}
%
\FloatBarrier

The program allows for a number of different  updating schemes.  If no other variables are specified in the \texttt{VAR\_QMC} name space, then the program will run in its default mode, namely the sequential single spin-flip mode.   The additional, optional variables in   \texttt{VAR\_QMC}   include the following: 
\begin{lstlisting}[style=fortran]

&VAR_QMC                 ! Variables for the QMC run 
Propose_S0      = .true. ! Proposes single spin flip moves with probability exp(-S0) 
Global_moves    = .true. ! Allows for global moves in space and time 
N_Global        = 1      ! Number of global moves  per sweep 
Global_tau_moves= .true. ! Allows for global moves on a single time slice.  
N_Global_tau    = 10     ! Number of global moves that will be carried out on a 
                         ! single time slice
Nt_sequential_start = 1  ! One can combine sequential and global moves on 
                         ! a time slice.  
Nt_sequential_end =      ! The program will carry our sequential local moves in the
                         ! range [Nt_sequential_start, Nt_sequential_end] and then
                         ! N_Global_tau global moves
/   
\end{lstlisting}
Note that if \texttt{Nt\_sequential\_start}  and \texttt{Nt\_sequential\_end}  are not specified and that the variable \texttt{Global\_tau\_moves}  is set to true, then  the program will  carry out only global moves, by setting  \\  \texttt{Nt\_sequential\_start=1}  and \texttt{Nt\_sequential\_end=0}. 

If the program is compiled with the parallel tempering flag, then the additional name space \texttt{VAR\_TEMP} has to be included in the parameter file.
\begin{lstlisting}[style=fortran,escapechar=\%]

&VAR_TEMP                      ! Variables for parallel tempering
N_exchange_steps      = 6      ! Number of exchange moves %[see Eq.~\eqref{eq:exchangestep}]%
N_Tempering_frequency = 10     ! The frequency in units of sweeps at which the
                               ! exchange moves will be carried 
mpi_per_parameter_set = 2      ! Number of mpi-processes per parameter set
Tempering_calc_det    = .true. ! Specifies whether the fermion weight has to be taken
                               ! into account while tempering. The default is .true.,
                               ! and it can be set to .false. if the parameters that
                               ! get varied only enter the Ising action S_0
/
\end{lstlisting}

Additionally, in order for the maximum entropy code, described in Sec.~\ref{sec:maxent}, to be used, the namelist \texttt{VAR\_Max\_Stoch} should also be defined:
\begin{lstlisting}[style=fortran]

&VAR_Max_Stoch               ! Variables for Stochastic Maximum entropy
Ngamma     = 400             ! # of Dirac delta-functions for parametrization
Om_st      = 0               ! Frequency range lower bound
Om_en      = 8               ! Frequency range upper bound
NDis       = 2000            ! # of boxes for histogram
Nbins      = 250             ! # of bins for Monte Carlo
Nsweeps    = 70              ! # of sweeps per bin
NWarm      = 20              ! The Nwarm first bins will be ommitted
N_alpha    = 14              ! # of tempertures
alpha_st   = 1.d0            ! smallest inverse temperature
R          = 1.2d0           ! increment for inverse temperature (see above) 
Channel    = "P"             ! T0       : Zero temperature
                             ! P        : Finite temperarure particle 
                             ! PH       : Finite temperarure particle-hole
                             ! PP       : Finite temperarure particle-particle 
Checkpoint = .false.         !.true.    : dump files will be produced so as to be able
                             !            to restart the simulation
                             !.false.   : dump files will not be produced 
Tolerance  = 0.1d0           ! Data points for which the relative error exceeds the
                             ! tolerance threshold will be omitted.
/
\end{lstlisting}


%------------------------------------------------------------
\subsubsection{Output files -- observables} \label{sec:output_obs}
%------------------------------------------------------------
%
\begin{table}[h]
   \begin{tabular}{@{} l l @{}}\toprule
   File & Description \\\midrule
   \path{info} & After completion of the simulation, this file documents the parameters of\\
   & the model, as well as the QMC run and simulation metrics (precision,\\
   & acceptance rate, wallclock time).\\
   \path{X_scal} & Results of equal-time measurements of scalar observables. \\
   & The placeholder \path{X} stands for the observables \path{Kin}, \path{Pot}, \path{Part}, and \path{Ener}. \\
   \path{Y_eq, Y_tau} & Results of equal-time and time-displaced measurements of correlation\\
   & functions. The placeholder \path{Y} stands for \path{Green}, \path{SpinZ}, \path{SpinXY}, and \path{Den}. \\   
   \path{confout_<thread number>} & Output files (one per MPI instance) for the HS and Ising configuration. \\\bottomrule
   \end{tabular}
   \caption{Overview of the standard output files. See Sec.~\ref{sec:obs} for the definitions of observables and correlation functions. \label{table:output}}
\end{table}
%
The standard output files are listed in Table~\ref{table:output}. 
The output of the measured data is organized in bins. One bin corresponds to the arithmetic average 
over a fixed number of individual measurements which depends 
on the chosen measurement interval \path{[LOBS_ST,LOBS_EN]} on the imaginary-time axis and on the number \path{NSweep} of Monte Carlo sweeps. If the user runs an MPI parallelized version of the code, the average also extends over the number of MPI threads. The formatting of a single bin's output depends on the observable type, \path{Obs_vec} or \path{Obs_Latt}:
\begin{itemize}
\item Observables of type \path{Obs_vec}:
For each additional bin, a single new line is added to the output file.
In case of an observable with \path{N_size} components, the formatting is 
\begin{verbatim}
N_size + 1    <measured value, 1> ... <measured value, N_size>    <measured sign>
\end{verbatim}
The counter variable \path{N_size+1} refers to the number of measurements per line, including the phase measurement. 
This format is required by the error analysis routine (see Sec.~\ref{sec:analysis}). 
Scalar observables like kinetic energy, potential energy, total energy and particle number are treated as a vector 
of size \path{N_size=1}.

\item Observables of type \path{Obs_Latt}:
For each additional bin, a new data block is added to the output file. 
The block consists of the expectation values [Eq.~(\ref{eqn:o})] contributing to the background part [Eq.~(\ref{eqn:s_back})] of the correlation function,
and the correlated part [Eq.~(\ref{eqn:s_corr})] of the correlation function.
For imaginary-time displaced correlation functions, the formatting of the block is given by:
\begin{alltt}
<measured sign>  <N_orbital>  <N_unit_cell>  <N_time_slices>  <dtau>
do alpha = 1, N_orbital
    \(\langle\hat{O}\sb{\alpha}\rangle \)
enddo
do i = 1, N_unit_cell
   <reciprocal lattice vector k(i)>
   do tau = 1, N_time_slices
      do alpha = 1, N_orbital
         do beta = 1, N_orbital
            \(\langle{S}\sb{\alpha,\beta}\sp{(\mathrm{corr})}(k(i),\tau)\rangle\)
         enddo
      enddo
   enddo
enddo
\end{alltt}
The same block structure is used for equal-time correlation functions, except for the entries  \path{<N_time_slices>} and \path{<dtau>}, which are then omitted.
Using this structure for the bins as input, the full correlation function $S_{\alpha,\beta}(\vec{k},\tau)$ [Eq.~(\ref{eqn:s})] is then calculated by calling the error analysis routine (see Sec.~\ref{sec:analysis}).
\end{itemize}


%------------------------------------------------------------
%\subsection{Scripts}\label{sec:scripts}
%------------------------------------------------------------
%

%\begin{table}[h]
%   \begin{tabular}{@{} l l l @{}}\toprule
%   Script & Description & Section\\\midrule
%   \path{Start/analysis.sh} & Starts the error analysis. & \ref{sec:analysis}\\
%   \path{Start/out_to_in.sh} & Copies outputted field configurations into input files for further runs. & \ref{sec:running} \\\bottomrule
%   \end{tabular}
%   \caption{Overview of the bash script files and the corresponding reference sections. 
%      \label{table:scripts}}
%\end{table}
%
