% Copyright (c) 2016 The ALF project.
% This is a part of the ALF project documentation.
% The ALF project documentation by the ALF contributors is licensed
% under a Creative Commons Attribution-ShareAlike 4.0 International License.
% For the licensing details of the documentation see license.CCBYSA.

% !TEX root = doc.tex
%-----------------------------------------
\subsection{Motivation}
%-----------------------------------------

The auxiliary field quantum Monte Carlo (QMC) approach is the algorithm of choice to simulate a variety of correlated electron systems in the solid state and beyond \cite{Blankenbecler81,Assaad08_rev}.  
The phenomena  one can investigate in detail include correlation effects in the bulk and surfaces of topological insulators, quantum phase transitions between semimetals (Dirac fermions)  and insulators,  
deconfined quantum critical points, topologically ordered phases, heavy fermion systems, nematic and magnetic quantum phase transitions in metals,   superconductivity in spin-orbit split bands, SU(N) symmetric models,  etc. 
This ever growing list of phenomena is based on  recent symmetry related insights enabling one to  find  sign-free formulations of the  problem thus allowing for solutions in polynomial time \cite{Wu04,Wei16}.   
The aim of the ALF project is to introduce a general formulation of the finite temperature  auxiliary field QMC method  so as to quickly be able to play with different model Hamiltonians  at  minimal programming cost.      
The reader is expected to be somewhat familiar with the auxiliary field QMC  approach. A detailed review containing all  the prerequisites for understanding  the code can be found in \cite{Assaad08_rev}.    
In this documentation, we briefly list the most important equations of the auxiliary field QMC method and then show in all details how to implement a variety of models, run the code, and produce  results for  equal time and time displaced correlation functions. 
The program code is written in Fortran according to the 2003 standard. 


%------------------------------------------------------------
\subsection{Definition of the Hamiltonian}
%------------------------------------------------------------

The first and most important  part is to define a general Hamiltonian which  can  accommodate a large class of models. 
Our approach is to express the model as a sum of one-body terms, a sum of two-body terms each written as a perfect square of a one body term, as well as one-body  term  coupled to an Ising field with  dynamics to be specified by the user. 
The form of the interaction in terms of sums of perfect squares allows us to use generic forms of  discrete  approximations to the  Hubbard-Stratonovich (HS)  transformation. 
Symmetry considerations  are  imperative to enhance the speed of the code.  
We therefore include a \textit{color} index  reflecting  an underlying  SU(N) color symmetry as  well as a flavor index  reflecting  the fact that  after  the HS  transformation,  the  fermionic determinant is block diagonal in this index.

The class of solvable models includes  Hamiltonians $\hat{\mathcal{H}}$ that have the following general form:
\begin{eqnarray}
\hat{\mathcal{H}}&=&\hat{\mathcal{H}}_{T}+\hat{\mathcal{H}}_{V} +  \hat{\mathcal{H}}_{I} +   \hat{\mathcal{H}}_{0,I}\;,\mathrm{where}
\label{eqn:general_ham}\\
\hat{\mathcal{H}}_{T}
&=&
\sum\limits_{k=1}^{M_T}
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma   s}T_{xy}^{(k s)} \hat{c}^{\phantom\dagger}_{y \sigma s}  \equiv  \sum\limits_{k=1}^{M_T} \hat{T}^{(k)}
\label{eqn:general_ham_t}\\
\hat{\mathcal{H}}_{V}
&=&
\sum\limits_{k=1}^{M_V}U_{k}
\left\{
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\left[
\left(
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma s}V_{xy}^{(k s)}\hat{c}^{\phantom\dagger}_{y \sigma s}
\right)
+\alpha_{k s} 
\right]
\right\}^{2}  \equiv   
\sum\limits_{k=1}^{M_V}U_{k}   \left(\hat{V}^{(k)} \right)^2
\label{eqn:general_ham_v}\\
\hat{\mathcal{H}}_{I}  & = &
\sum\limits_{k=1}^{M_I} \hat{Z}_{k} 
\left(
\sum\limits_{\sigma=1}^{N_{\mathrm{col}}}
\sum\limits_{s=1}^{N_{\mathrm{fl}}}
\sum\limits_{x,y}^{N_{\mathrm{dim}}}
\hat{c}^{\dagger}_{x \sigma s} I_{xy}^{(k s)}\hat{c}^{\phantom\dagger}_{y \sigma s}
\right) \equiv \sum\limits_{k=1}^{M_I} \hat{Z}_{k}    \hat{I}^{(k)} 
\;.\label{eqn:general_ham_i}
\end{eqnarray}
The indices have the following meaning:
\begin{itemize}
\item The number of fermion \textit{flavors} is set by $N_{\mathrm{fl}}$.  After the Hubbard-Stratonovich transformation, the action will be block diagonal in the flavor index. 
\item The number of fermion \textit{colors} is set by $N_{\mathrm{col}}$.    The Hamiltonian is invariant under  SU($N_{\mathrm{col}}$)  rotations. Note that  in the code $ N_{\mathrm{col}} \equiv \texttt{N\_{SUN}} $. 
\item The indices $x,y$ label lattice sites where $x,y=1,\cdots, N_{\mathrm{dim}}$. 

$N_{\mathrm{dim}}$ is the total number of spacial vertices: $N_{\mathrm{dim}}=N_{\text{unit cell}} N_{\mathrm{orbital}}$, 
where $N_{\text{unit cell}}$ is the number of unit cells of the underlying Bravais lattice and $N_{\mathrm{orbital}}$ is the number of (spacial) orbitals per unit cell.
\item Therefore, the  matrices $\bm{T}^{(k s)}$, $\bm{V}^{(ks)}$  and $\bm{I}^{(ks)}$ are  of dimension $N_{\mathrm{dim}}\times N_{\mathrm{dim}}$
\item The number of interaction terms  is labelled by $M_V$   and $M_I$.   $M_T> 1 $ would allow for a checkerboard decomposition.
\end{itemize}
The Ising part of the general Hamiltonian (\ref{eqn:general_ham}) is $\hat{\mathcal{H}}_{0,I}+ \hat{\mathcal{H}}_{I}$ and  has the following properties:
\begin{itemize}
\item $\hat{Z}_k$ is an Ising spin operator which corresponds to the Pauli matrix $\hat{\sigma}_{z}$. It couples to a general one-body term. 
\item  The dynamics of the Ising spins is given by $\hat{\mathcal{H}}_{0,I}$. This term is not specified here; 
it has to be specified by the user and becomes relevant when the Monte Carlo update probability is computed in the code (see Sec.~\ref{sec:walk2} for an example).
\end{itemize}
Note that the matrices  $\bm{T}^{(ks)}$,  $\bm{V}^{(ks)}$ and  $\bm{I}^{(ks)}$ explicitly depend on the flavor index $s$ but not on the color index $\sigma$. 
The color index $\sigma$ only appears in  the  second quantized operators such that the Hamiltonian is manifestly SU($N_{\mathrm{col}}$)    symmetric.  We also require
the matrices $\bm{T}^{(ks)}$,  $\bm{V}^{(ks)}$ and  $\bm{I}^{(ks)}$  to be  Hermitian.

%------------------------------------------------------------
\subsection{Outline}
%------------------------------------------------------------

To use the code, a minimal understanding of the algorithm is necessary. 
In Sec.~\ref{sec:def}, we go very briefly through  the steps required  to formulate the many-body imaginary-time propagation in terms of a sum  over HS and Ising fields  of one-body  imaginary time-propagators.   
The user has to provide this one-body imaginary-time propagator for a given configuration of   HS and  Ising fields. 
We equally discuss the Monte Carlo updates as well as the strategies for numerical stabilization of the code. 

Section \ref{sec:imp} is devoted to the data structures that are needed to implement the model, as well as to the input and output file structure.   
The data structure includes  an \texttt{Operator} type to  optimally work with sparse Hermitian matrices, a \texttt{Lattice} type  to define one- and two-dimensional Bravais lattices, and   two   \texttt{Observable} types to handle site-dependent equal-time and  time-displaced observables, as well as scalar observables. 

The Monte Carlo run and the  data analysis  are separated: the QMC run  dumps the results of \textit{bins}  sequentially into files  which are then analyzed by  analysis programs. In Sec.~\ref{sec:analysis}, we provide a brief description of the analysis programs  for our three observable types.  The analysis programs allow for omitting a given number of initial bins in order to account for warmup times. Also, a rebinning analysis is included  to a posteriori take  account of long autocorrelation times.  Finally, Sec.~\ref{sec:running} provides all the necessary details  to compile and run the code. 


We  give explicit examples on how to use the code for  the  Hubbard model on square and honeycomb lattices,  for different choices of the Hubbard-Stratonovich transformation  (see Secs.~\ref{sec:walk1},~\ref{sec:walk1.1} and ~\ref{sec:walk1.2})  as well as for the Hubbard model on a square lattice coupled to a transverse Ising field (see Sec.~\ref{sec:walk2} ).   Our implementation is rather general such that  a variety of other models can be simulated. In Sec.~\ref{sec:misc}   we provide  some information on how to simulate the Kondo lattice as well as the SU(N) symmetric Hubbard-Heisenberg model. 

Finally, in Sec.~\ref{sec:con} we list a number of features that are considered for  future releases of the ALF program package.
