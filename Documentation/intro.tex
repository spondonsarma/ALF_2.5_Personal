% !TEX root = doc.tex
\section{Introduction}\label{sec:intro}


The auxiliary field quantum Monte Carlo (QMC) approach is the algorithm of choice to simulate a variety of correlated electron systems in the solid state and beyond \cite{Blankenbecler81,Assaad08_rev}.  The phenomena  one can investigate in detail include correlation effects in in the bulk and surfaces of topological insulators, quantum phase transitions between semimetals (Dirac fermions)  and insulators,  deconfined quantum critical points, topologically ordered phases, heavy fermion systems, nematic and magnetic quantum phase transitions in metals,   superconductivity in spin orbit split bands, SU(N) symmetric models,  etc.  This ever growing list of phenomena,  is based on  recent symmetry based insights that allow one to  find  sign free formulations of the  problem thus allowing solutions in polynomial time \cite{Wu04,Wei16}.   The aim of this project is to introduce a general formulation of the finite temperature  auxiliary field method  so as to quickly be able to play with different model Hamiltonians  at  minimal programming cost.      The reader is expected to be familiar with the auxiliary field QMC  approach. A detailed review containing all  the prerequisites for understanding  the code can be found in \cite{Assaad08_rev}.    In this documentation, we will briefly list the most important equations of the auxiliary field QMC and then show in all details how to implement a variety of models, run the code, and produce  results for  equal time and time displaced correlation functions. 
The program code is written in Fortran according to the 2003 standard. 

The first and most important  part is to define a general Hamiltonian  that  can  accommodate a large class of models  (see Sec.~\ref{sec:def}). Our approach is to express the model as a sum of one-body terms, a sum of two-body terms each written as a perfect square of a one one body term, as well as one-body  term  coupled to an Ising field with  dynamics to be specified by the user.   
The form of the interaction in terms of sums of perfect squares allows us to use generic forms of  discrete  approximations to the  Hubbard-Stratonovich (HS)  transformation. 	 Symmetry considerations  are  imperative to enhance the speed of the code.   We thereby include a {\it color} index  reflecting  an underlying  SU(N) color symmetry as  well as a flavor index  reflecting  the fact that  after  the HS  transformation,  the  fermionic determinant is block diagonal in this index.    To use the code, one will require a minimal understanding of the algorithm.  In Section~\ref{sec:def}, we very briefly show how to go through  the steps required  to formulated the many body imaginary time propagation in terms of a sum  over HS and Ising fields  of one body  imaginary time propagator.   The user will have to provide this one body imaginary time propagator for a given configuration of   HS and  Ising fields.   
	  
	   Section \ref{sec:imp} is devoted to the data structures which  need to implement the model.  This includes  an \texttt{Operator} type to  optimally work with sparse Hermitian matrices, a \texttt{Lattice} type  to define one and two dimensional Bravais lattices, and   two   \texttt{Observable} types to handle equal time, time displaced and scalar observables. 
	   
	    After a description of the file structure  in Sec~\ref{sec:files},  we will give explicit examples on how to use the code for  the  Hubbard model on square and honeycomb lattices  for different choices of the Hubbard  Stratonovich transformation  (See Secs.~\ref{sec:walk1},~\ref{sec:walk1.1} and ~\ref{sec:walk1.2})  as well as the Hubbard model on a square lattice coupled to a transverse Ising field (see Sec.~\ref{sec:walk2} ).
	   
      The Monte Carlo run and the  data analysis  are separate: the QMC run  dumps the results of {\it bins}  sequentially into files  which are then analyzed by  analysis programs In Sec.~\ref{sec:analysis}, we provide a brief description of the analysis programs  for our three observable types.  The analysis program allow for omitting a given number of initial bins so as to allow for warmup and to rebin  so as to a posteriori take into account long autocorrelation times.  Finally, Sec.~\ref{sec:running}  will provide all details required to compile and run the code. 
	
		
				
%               To define the action and thereby the model,  we will need a lattice, operators, as well as  observables  which we  wish to compute. The structures we have opted for are describes in Sec..~\ref{sec:def}	 The general Hamiltonian operator is written down in Sec.~\ref{sec:def}, followed by  a brief outline  of the quantum Monte Carlo algorithm.  In Sec.~\ref{sec:imp}, we discuss the implementation of a model, introducing the \texttt{Operator} data structure which is the building block of the Hamiltonian. And we discuss the implementation of the lattice and the observables. Section ~\ref{sec:io} is about actually running the code. We describe input and output files, the analysis protocol and the compilation procedure.  In Sec.~\ref{sec:walk1} and \ref{sec:walk2} two detailed walkthroughs are performed: the $SU(2)$-symmetric Hubbard  on a square lattice (Sec.~\ref{sec:walk1}) and the same model, but additionally coupled to a transverse field Ising model (Sec.~\ref{sec:walk2}).


