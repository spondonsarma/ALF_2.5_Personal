#!/usr/bin/env python3
"""Script for automatically parsing parameters of Hamiltonian.

Also stores generic (Hamiltonian independent) ALF parameters with default values.
"""
# pylint: disable=invalid-name
# pylint: disable=consider-using-f-string

__author__ = "Jonas Schwab"
__copyright__ = "Copyright 2022, The ALF Project"
__license__ = "GPL"

import sys
from collections import OrderedDict
# from pprint import pprint


def parse(filename):
    """Parse Fortran file for parameter lists.

    Each list has to start with a line containing '#PARAMETERS START#' and end
    with a line containing '#PARAMETERS END#'. The name written in the same
    line as '#PARAMETERS START#' is the namelist name."""
    parameters = {}
    with open(filename, 'r') as f:
        lines = f.readlines()

    do_parse = False
    for i, line in enumerate(lines):
        if '#PARAMETERS START#' in line:
            do_parse = True
            name_key = line.split('#PARAMETERS START#')[1].strip()
            if not name_key.isidentifier():
                raise Exception(
                    'In line {} of {}: '.format(i+1, filename) +
                    '"{}" is not a valid namelist name.'.format(name_key)
                    )
            namelist = {}
            parameters[name_key] = namelist
            continue
        if '#PARAMETERS END#' in line:
            do_parse = False
            continue
        if do_parse and '::' in line:
            par = parse_line(line)
            par_name = par.pop('name')
            namelist[par_name] = par
    return parameters


def parse_line(line):
    """Parse single line in Fortran file for parameter."""
    parameter = {}
    dtype, rest = line.split('::', maxsplit=1)
    dtype = dtype.strip().lower()
    if '!' in rest:
        assignment, comment = rest.strip().split('!', maxsplit=1)
        assignment = assignment.strip()
        parameter['comment'] = comment.strip(' !')
    else:
        assignment = rest.strip()
        parameter['comment'] = ''
    name, value = assignment.split('=')
    # parameter['name'] = name.split('(')[0].strip()
    parameter['name'] = name.strip()
    value = value.strip().replace('d0', '0')
    parameter['defined_in_base'] = dtype.startswith('!')
    if '[' in value:
        parameter['value'] = []
        for val in value.strip('[]').split(','):
            parameter['value'].append(_to_value(dtype, val))
    else:
        parameter['value'] = _to_value(dtype, value)

    return parameter


def _max_len(dictionary):
    return max([len(i) for i in dictionary])


def _dtype_name(parameter):
    if isinstance(parameter, list):
        return _dtype_name(parameter[0])
    if isinstance(parameter, bool):
        return 'logical'
    if isinstance(parameter, float):
        return 'real(dp)'
    if isinstance(parameter, int):
        return 'integer'
    if isinstance(parameter, str):
        return 'Character(len=64)'
    raise Exception('Error in "_dtype_name": unrecognized type')


def _convert_par_to_str(parameter):
    """Converts a given parameter value to a string that can be
    written into a parameter file.
    """
    if isinstance(parameter, list):
        pars = [_convert_par_to_str(p) for p in parameter]
        return '[{}]'.format(', '.join(pars))
    if isinstance(parameter, bool):
        if parameter:
            return '.true.'
        return '.false.'
    if isinstance(parameter, float):
        if 'e' in '{}'.format(parameter):
            return '{}'.format(parameter).replace('e', 'd')
        return '{}d0'.format(parameter)
    if isinstance(parameter, int):
        return '{}'.format(parameter)
    if isinstance(parameter, str):
        return '"{}"'.format(parameter)

    raise Exception('Error in "_convert_par_to_str": unrecognized type')


def create_read_write_par(filename, parameters, ham_name):
    INDENT = 9     # Number of indentation spaces
    LINE_MAX = 70  # Maximal line length
    TEMPLATE = """! This file is automatically generated by parse_ham.py
! Please note that all manual changes will be overwritten during compilation!
! Supplies subroutine for automatically reading and writing the parameters of "##HAM_NAME##"

      Subroutine read_parameters()
         use iso_fortran_env, only: error_unit
#ifdef MPI
         Use mpi
#endif
         Implicit none

         !Local variables
         integer            :: ierr, unit_para
         Character (len=64) :: file_info, file_para
         Integer, parameter :: dp = kind(0.d0)

         ##NAMELIST##

#ifdef MPI
         Integer        :: Isize, Irank, igroup, irank_g, isize_g
         Integer        :: STATUS(MPI_STATUS_SIZE)
         CALL MPI_COMM_SIZE(MPI_COMM_WORLD,ISIZE,IERR)
         CALL MPI_COMM_RANK(MPI_COMM_WORLD,IRANK,IERR)
         call MPI_Comm_rank(Group_Comm, irank_g, ierr)
         call MPI_Comm_size(Group_Comm, isize_g, ierr)
         IF (ierr /= 0) THEN
            WRITE(error_unit,*) 'read_parameters: Error in MPI', ierr
            error stop 1
         END IF
         igroup           = irank/isize_g
#endif

         ##PARAMETER_DEF##
#ifdef MPI
         If (Irank_g == 0 ) then
#endif
#ifdef TEMPERING
            write(file_para,'(A,I0,A)') "Temp_", igroup, "/parameters"
            write(file_info,'(A,I0,A)') "Temp_", igroup, "/info"
#else
            file_para = "parameters"
            file_info = "info"
#endif

            !Read in parameters
            OPEN(NEWUNIT=unit_para, FILE=file_para, STATUS='old', ACTION='read', IOSTAT=ierr)
            IF (ierr /= 0) THEN
               WRITE(error_unit,*) 'unable to open <parameters>', ierr
               error stop 1
            END IF
            ##READ_VAR##
            close(unit_para)

#ifdef MPI
         Endif
         !Broadcast parameters to all MPI tasks
         ##MPI_BCAST##
#endif

      end subroutine read_parameters


#ifdef HDF5
      Subroutine write_parameters_hdf5(filename)
         Use hdf5
         use alf_hdf5
         Implicit none

         Character (len=64), intent(in) :: filename

         Logical            :: link_exists
         INTEGER(HID_T)     :: file_id, group_id, group_id2
         INTEGER            :: ierr

         ! Open HDF5 file
         CALL h5fopen_f (filename, H5F_ACC_RDWR_F, file_id, ierr)

         CALL h5lexists_f(file_id, "parameters", link_exists, ierr)
         if ( .not. link_exists ) then
           ! Create parameters-group
           call h5gcreate_f(file_id, "parameters", group_id, ierr)
         else
           ! Open parameters-group
           call h5gopen_f (file_id, "parameters", group_id, ierr)
         endif

         ##TEST_ATTRS##

         call h5gclose_f(group_id, ierr)
         call h5fclose_f(file_id, ierr)

      end Subroutine write_parameters_hdf5
#endif
"""

    f = open(filename, 'w')
    for line in TEMPLATE.splitlines(keepends=True):
        if '##NAMELIST##' in line:
            for nlist_name, nlist in parameters.items():
                s = '{}NAMELIST /{}/  '.format(INDENT*' ', nlist_name)
                for par_name in nlist:
                    par_name = par_name.split('(')[0]
                    if len(s) < LINE_MAX:
                        s = '{}{}, '.format(s, par_name)
                    else:
                        f.write('{}&\n'.format(s))
                        s = '{}     &     {}, '.format(INDENT*' ', par_name)
                f.write(s[:-2]+'\n')
        elif '##PARAMETER_DEF##' in line:
            for nlist_name, nlist in parameters.items():
                f.write('{}!Parameters {}\n'.format(INDENT*' ', nlist_name))

                names_len = _max_len(nlist)
                # dtypes_str = [_dtype_name(par['value']) for
                #               par_name, par in nlist.items()]
                # dtypes_len = _max_len(dtypes_str)
                pars_str = [_convert_par_to_str(par['value']) for
                            par_name, par in nlist.items()]
                pars_len = _max_len(pars_str)
                # comments = [par[1] for par_name, par in nlist.items()]
                # for i in range(len(nlist)):

                for par_name, par in nlist.items():
                    # s = '{}{} :: {} = {} !'.format(
                    #     INDENT*' ',
                    #     _dtype_name(par['value']).ljust(dtypes_len),
                    #     par_name.ljust(names_len),
                    #     _convert_par_to_str(par['value']).ljust(pars_len)
                    #     )
                    s = '{}{} = {} !'.format(
                        INDENT*' ',
                        par_name.ljust(names_len),
                        _convert_par_to_str(par['value']).ljust(pars_len)
                        )
                    comment = par['comment'].split(' ')
                    comment_indent = min(40, len(s)-2)
                    for word in comment:
                        if len(s) < LINE_MAX:
                            s = '{} {}'.format(s, word)
                        else:
                            f.write('{} \n'.format(s))
                            s = '{} ! {}'.format(comment_indent*' ', word)
                    f.write(s)
                    f.write('\n')
        elif '##READ_VAR##' in line:
            for nlist_name, nlist in parameters.items():
                f.write('{}   REWIND(unit_para)\n'.format(INDENT*' '))
                s = '{}   READ(unit_para, NML={})\n'.format(
                    INDENT*' ', nlist_name)
                f.write(s)

        elif '##MPI_BCAST##' in line:
            fstring = '{}CALL MPI_BCAST({},{:>3},{},0,Group_Comm,ierr)\n'
            for nlist_name, nlist in parameters.items():
                names_len = _max_len(nlist)
                for par_name, par in nlist.items():
                    s = fstring.format(
                        INDENT*' ',
                        par_name.split('(')[0].ljust(names_len),
                        _get_mpi_len(par['value']),
                        _get_mpi_dtype(par['value']),
                        )
                    f.write(s)
        elif '##TEST_ATTRS##' in line:
            for nlist_name, nlist in parameters.items():
                s = """CALL h5lexists_f(group_id, "{}", link_exists, ierr)
                       if ( .not. link_exists ) then
                         call h5gcreate_f(group_id, "{}", group_id2, ierr)
                         call h5gclose_f(group_id2, ierr)
                       endif\n""".format(nlist_name.lower(), nlist_name.lower())
                f.write(s)
                for par_name, par in nlist.items():
                    s = '{}call test_attribute(group_id, "{}", "{}", {}, ierr)\n'.format(
                        INDENT*' ', nlist_name.lower(), par_name.lower(), par_name
                        )
                    f.write(s)
        else:
            f.write(line.replace('##HAM_NAME##', ham_name))
    f.close()


def _to_value(dtype, value):
    if 'real' in dtype:
        return float(value)
    if 'integer' in dtype:
        return int(value)
    if 'character' in dtype:
        return value.strip('"\'')
    if 'logical' in dtype:
        if 't' in value or 'T' in value:
            return True
        if 'f' in value or 'F' in value:
            return False

        raise Exception(
            '"{}" can not be mapped to bool.'.format(value))

    raise Exception('"{}" can not be mapped to a type'.format(dtype))


def _get_mpi_dtype(parameter):
    if isinstance(parameter, list):
        return _get_mpi_dtype(parameter[0])
    if isinstance(parameter, bool):
        return 'MPI_LOGICAL  '
    if isinstance(parameter, float):
        return 'MPI_REAL8    '
    if isinstance(parameter, int):
        return 'MPI_INTEGER  '
    if isinstance(parameter, str):
        return 'MPI_CHARACTER'
    raise Exception('Error in "_get_mpi_dtype": unrecognized type')


def _get_mpi_len(parameter):
    if isinstance(parameter, list):
        return _get_mpi_len(parameter[0]) * len(parameter)
    if isinstance(parameter, (bool, float, int)):
        return 1
    if isinstance(parameter, str):
        return 64
    raise Exception('Error in "_get_mpi_len": unrecognized type')


def parse_list(ham_names_file):
    """."""
    with open(ham_names_file, 'r') as f:
        ham_names = f.read().splitlines()

    for ham_name in ham_names:
        filename = 'Hamiltonians/Hamiltonian_{}_smod.F90'.format(ham_name)
        print('filename:', filename)

        parameters = parse(filename)
        # pprint(parameters)
        filename = 'Hamiltonians/' + \
            'Hamiltonian_{}_read_write_parameters.F90'.format(ham_name)
        create_read_write_par(filename, parameters, ham_name)


if __name__ == '__main__':
    parse_list(sys.argv[1])


# Generic (Hamiltonian independent) ALF parameters with default values.
_PARAMS_GENERIC = OrderedDict([
    ('VAR_QMC',
        {'CPU_MAX': {'comment': 'Code stops after CPU_MAX hours, if 0 or '
                                'not specified, the code stops after '
                                'Nbin bins',
                     'value': 0.0},
         'Delta_t_Langevin_HMC': {'comment': 'Time step for Langevin or '
                                             'HMC',
                                  'value': 0.01},
         'Global_moves': {'comment': 'Allows for global moves in space '
                                     'and time.',
                          'value': False},
         'Global_tau_moves': {'comment': 'Allows for global moves on a '
                                         'single time slice.',
                              'value': False},
         'HMC': {'comment': 'HMC update', 'value': False},
         'LOBS_EN': {'comment': 'End measurements at time slice LOBS_EN',
                     'value': 0},
         'LOBS_ST': {'comment': 'Start measurements at time slice '
                                'LOBS_ST',
                     'value': 0},
         'Langevin': {'comment': 'Langevin update', 'value': False},
         'Leapfrog_steps': {'comment': 'Number of leapfrog steps',
                            'value': 0},
         'Ltau': {'comment': '1 to calculate time-displaced Green '
                             'functions; 0 otherwise.',
                  'value': 1},
         'Max_Force': {'comment': 'Max Force for Langevin', 'value': 1.5},
         'N_global': {'comment': 'Number of global moves per sweep.',
                      'value': 1},
         'N_global_tau': {'comment': 'Number of global moves that will '
                                     'be carried out on a single time '
                                     'slice.',
                          'value': 1},
         'Nbin': {'comment': 'Number of bins.', 'value': 5},
         'Nsweep': {'comment': 'Number of sweeps per bin.', 'value': 100},
         'Nt_sequential_end': {'comment': '', 'value': -1},
         'Nt_sequential_start': {'comment': '', 'value': 0},
         'Nwrap': {'comment': 'Stabilization. Green functions will be '
                              'computed from scratch after each time '
                              'interval Nwrap*Dtau.',
                   'value': 10},
         'Propose_S0': {'comment': 'Proposes single spin flip moves with '
                                   'probability exp(-S0).',
                        'value': False}}),
    ('VAR_errors',
        {'N_Back': {'comment': 'If set to 1, substract background in '
                               'correlation functions.',
                    'value': 1},
         'N_Cov': {'comment': 'If set to 1, covariance computed for '
                              'time-displaced correlation functions.',
                   'value': 0},
         'N_auto': {'comment': 'If > 0, calculate autocorrelation.',
                    'value': 0},
         'N_rebin': {'comment': 'Rebinning: Number of bins to combine '
                                'into one.',
                     'value': 1},
         'N_skip': {'comment': 'Number of bins to be skipped.',
                    'value': 1}}),
    ('VAR_TEMP',
        {'N_Tempering_frequency': {'comment': 'The frequency, in units '
                                              'of sweeps, at which the '
                                              'exchange moves are '
                                              'carried out.',
                                   'value': 10},
         'N_exchange_steps': {'comment': 'Number of exchange moves.',
                              'value': 6},
         'Tempering_calc_det': {'comment': 'Specifies whether the '
                                           'fermion weight has to be '
                                           'taken into account while '
                                           'tempering. Can be set to '
                                           '.F. if the parameters '
                                           'that get varied only '
                                           'enter the Ising action S_0',
                                'value': True},
         'mpi_per_parameter_set': {'comment': 'Number of mpi-processes '
                                              'per parameter set.',
                                   'value': 2}}),
    ('VAR_Max_Stoch',
        {'Checkpoint': {'comment': '', 'value': False},
         'NBins': {'comment': 'Number of bins for Monte Carlo.',
                   'value': 250},
         'NSweeps': {'comment': 'Number of sweeps per bin.', 'value': 70},
         'N_alpha': {'comment': 'Number of temperatures.', 'value': 14},
         'Ndis': {'comment': 'Number of boxes for histogram.',
                  'value': 2000},
         'Ngamma': {'comment': 'Number of Dirac delta-functions for '
                               'parametrization.',
                    'value': 400},
         'Nwarm': {'comment': 'The Nwarm first bins will be ommitted.',
                   'value': 20},
         'Om_en': {'comment': 'Frequency range upper bound.',
                   'value': 10.0},
         'Om_st': {'comment': 'Frequency range lower bound.',
                   'value': -10.0},
         'R': {'comment': '', 'value': 1.2},
         'Tolerance': {'comment': '', 'value': 0.1},
         'alpha_st': {'comment': '', 'value': 1.0}})
    ])
