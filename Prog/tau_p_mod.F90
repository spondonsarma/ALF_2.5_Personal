!  Copyright (C) 2016 - 2018 The ALF project
!
!     The ALF project is free software: you can redistribute it and/or modify
!     it under the terms of the GNU General Public License as published by
!     the Free Software Foundation, either version 3 of the License, or
!     (at your option) any later version.
!
!     The ALF project is distributed in the hope that it will be useful,
!     but WITHOUT ANY WARRANTY; without even the implied warranty of
!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!     GNU General Public License for more details.
!
!     You should have received a copy of the GNU General Public License
!     along with Foobar.  If not, see http://www.gnu.org/licenses/.
!
!     Under Section 7 of GPL version 3 we require you to fulfill the following additional terms:
!
!     - It is our hope that this program makes a contribution to the scientific community. Being
!       part of that community we feel that it is reasonable to require you to give an attribution
!       back to the original authors if you have benefitted from this program.
!       Guidelines for a proper citation can be found on the project's homepage
!       http://alf.physik.uni-wuerzburg.de .
!
!     - We require the preservation of the above copyright notice and this license in all original files.
!
!     - We prohibit the misrepresentation of the origin of the original source files. To obtain
!       the original source files please visit the homepage http://alf.physik.uni-wuerzburg.de .
!
!     - If you make substantial changes to the program we require you to either consider contributing
!       to the ALF project or to mark your material in a reasonable way as different from the original version.

!--------------------------------------------------------------------
!> @author
!> ALF-project
!
!> @brief 
!> This module handles calculation of imaginary-time-displaced Green functions and  
!> calls the routine ObserT.F90 in the Hamiltonian module, so as to compute  user
!> defined time-displaced correlations functions. This module is for the projector code.
!--------------------------------------------------------------------

     Module Tau_p_mod
       Use Hamiltonian
       Use Operator_mod
       Use Control
       Use Hop_mod
       Use UDV_State_mod
       Use tau_m_mod  !, only propr, proprm1

     Contains

!--------------------------------------------------------------------
!> @author
!> ALF-project
!
!> @brief      This routine computes the time displaced  zero termperature Green functions and call  obserT. 
!> On input:   a) GR,  the equal time Green function,  as  well as udvl, udvr are on time slice 
!>                nt_in= stab_nt(nst)   with   stab_nt(NST) <= THTROT+1  and  stab_nt( NST +1 )  > THTROT+1.
!>             b) The storage, udvst, is full with left propagations from  Ltrot to    stab_nt( NST +1 ).                    
!> On_input    a) GR,  the equal time Green function,  as  well as udvl, udvr are on time slice 
!>                nt_in = = Stab_nt(NST_IN)  with nt_in <= THTROT+1.
!>             b) The storage is full with left propagations for all n's with stab_nt(n) > nt_in.
!>             c) udvl and udvr are on time slice nt_in  such that  a call to CGR with udvl and udvr will
!>                produce Gr.
!>
!> On_output   a) The time displaced Green functions have been computed and measurements carried out.
!>             b) If Langevin then 1)  nt_in = 0, 2) forces are computes  3)  time displaced and equal time
!>                observables are  measured.      
!--------------------------------------------------------------------

       SUBROUTINE Tau_p(udvl, udvr, udvst, GR, PHASE, NSTM, STAB_NT, NST_IN)

         Implicit none

         Interface
            SUBROUTINE CGRP(PHASE, GRUP, udvr, udvl)
              Use UDV_State_mod
              use MyMats
              CLASS(UDV_State), INTENT(IN) :: udvl, udvr
              COMPLEX (Kind=Kind(0.d0)), Dimension(:,:), Intent(INOUT) :: GRUP
              COMPLEX (Kind=Kind(0.d0)), Intent(INOUT) :: PHASE
            End Subroutine CGRP
            SUBROUTINE WRAPUR(NTAU, NTAU1, UDVR)
              Use Hamiltonian
              Use UDV_Wrap_mod
              Use UDV_State_mod
              Implicit None
              CLASS(UDV_State), intent(inout) :: UDVR(N_FL)
              Integer :: NTAU1, NTAU
            END SUBROUTINE WRAPUR
         End Interface

        ! Storage is full with U^{<} (left)  propagations.


        Integer, Intent(In) :: NSTM, NST_IN
        CLASS(UDV_State), Dimension(:), ALLOCATABLE, INTENT(IN) :: udvl, udvr
        CLASS(UDV_State), Dimension(:,:), ALLOCATABLE, INTENT(IN) :: udvst
        Complex (Kind=Kind(0.d0)), Intent(in) :: GR(NDIM,NDIM,N_FL),  Phase
        Integer, Intent(In) :: STAB_NT(0:NSTM)

!       Local.
        CLASS(UDV_State), Dimension(:), ALLOCATABLE :: udvr_local
        Complex (Kind=Kind(0.d0)) :: DETZ, ZK, DET1(2)
        Complex (Kind=Kind(0.d0)), Dimension(:,:,:), Allocatable  ::  GRUPB, GRUP
        Complex (Kind=Kind(0.d0)), Dimension(:,:,:), Allocatable  ::  G00UP, G0TUP, GT0UP,  GTTUP
        Complex (Kind=Kind(0.d0)), Dimension(:,:,:), Allocatable  ::  G00UP_T, G0TUP_T, GT0UP_T,  GTTUP_T

        Complex (Kind=Kind(0.d0)), allocatable  :: TEMP(:,:), TMPUP(:,:)

        Real    (Kind=kind(0.d0))  :: XMEAN_DYN, XMAX_DYN

        Integer :: NTAUIN,  NTDM,  LFAM, NFAM, N_Part,  LQ , I, NCON, NF, NFLAG, NL, NT1, NT_ST, NT, NTAU, NTAU1,n

        Real (Kind=Kind(0.d0)):: XMEAN, XMAX

        LQ = ndim

        ALLOCATE (  GRUPB(LQ,LQ,N_FL), GRUP(LQ,LQ,N_FL), G00UP(LQ,LQ,N_FL), G0TUP(LQ,LQ,N_FL), &
             &      GT0UP(LQ,LQ,N_FL),  GTTUP(LQ,LQ,N_FL), TEMP(LQ,LQ), udvr_local(N_FL) )

        If (Symm) Then
           Allocate ( G00UP_T(LQ,LQ,N_FL), G0TUP_T(LQ,LQ,N_FL), GT0UP_T(LQ,LQ,N_FL),  GTTUP_T(LQ,LQ,N_FL) )
        endif

        do nf=1,N_FL
           call udvr_local(nf)%alloc(ndim,udvr(nf)%N_part)
           udvr_local(nf)=udvr(nf)
        enddo

        GTTUP = GR ! On time slice Stab_nt(NST_IN)
        NT_ST = NST_IN
        do NT = Stab_nt(NT_ST)+1, Thtrot + 1
           CALL PROPRM1(GTTUP,NT)
           CALL PROPR  (GTTUP,NT)
           IF ( NT .EQ. STAB_NT(NT_ST+1) ) THEN
              Call Wrapur(STAB_NT(NT_ST), STAB_NT(NT_ST+1), UDVR_local)
              do nf=1,N_FL
                 CALL CGRP(DetZ, GRUP(:,:,nf), udvr_local(nf), udvst(nt_st + 1,nf))
              enddo
              Do nf = 1,N_FL
                 Call Control_Precision_tau(GTTUP(:,:,nf), GRUP(:,:,nf), Ndim)
              enddo
              GTTUP = GRUP
              NT_ST = NT_ST+1
           endif
        enddo

        GRUPB = GTTUP
        do nf=1,N_FL
           do I=1,Ndim
              GRUPB(I,I,nf)=GRUPB(I,I,nf)-1.d0
           enddo
        enddo

        G00UP = GTTUP
        !GTTUP = GTTUP
        GT0UP = GTTUP
        G0TUP = GRUPB
        NTAU   = 0
        If (Symm) then
           Call Hop_mod_Symm(G00UP_T,G00UP)
           Call Hop_mod_Symm(GTTUP_T,GTTUP)
           Call Hop_mod_Symm(G0TUP_T,G0TUP)
           Call Hop_mod_Symm(GT0UP_T,GT0UP)
           CALL OBSERT (NTAU,GT0UP_T,G0TUP_T,G00UP_T,GTTUP_T,PHASE)
        else
           CALL OBSERT (NTAU,GT0UP,G0TUP,G00UP,GTTUP,PHASE)
        endif
        DO NT = THTROT+1, Ltrot-THTROT
           ! UR is on time slice NT
           NTAU = NT - THTROT -1
           IF ( NT .EQ. STAB_NT(NT_ST+1) .and. NTAU /= 0) THEN
              Call Wrapur(STAB_NT(NT_ST), STAB_NT(NT_ST+1), UDVR_local)
              do nf=1,N_FL
                 CALL CGRP(DetZ, GRUP(:,:,nf), udvr_local(nf), udvst(nt_st + 1,nf))
              enddo
              NT_ST = NT_ST+1

              Do nf = 1,N_FL
                 Call Control_Precision_tau(GTTUP(:,:,nf), GRUP(:,:,nf), Ndim)
              enddo
              GTTUP = GRUP

              GRUPB = -GRUP
              do nf=1,N_FL
                 do I=1,Ndim
                    GRUPB(I,I,nf)=GRUPB(I,I,nf)+1.d0
                 enddo
              enddo
              do nf=1,N_FL
                 CALL MMULT(TEMP,GRUP(:,:,nf),GT0UP(:,:,nf))
                 GT0UP(:,:,nf) = TEMP
                 CALL MMULT(TEMP,G0TUP(:,:,nf),GRUPB(:,:,nf))
                 G0TUP(:,:,nf) = TEMP
              enddo
           ENDIF
           NT1 = NT + 1
           CALL PROPR  (GT0UP,NT1)
           CALL PROPRM1(G0TUP,NT1)
           CALL PROPRM1(GTTUP,NT1)
           CALL PROPR  (GTTUP,NT1)


           NTAU1 = NTAU + 1
           If (Symm) then
              Call Hop_mod_Symm(G00UP_T,G00UP)
              Call Hop_mod_Symm(GTTUP_T,GTTUP)
              Call Hop_mod_Symm(G0TUP_T,G0TUP)
              Call Hop_mod_Symm(GT0UP_T,GT0UP)
              Call OBSERT (NTAU1,GT0UP_T,G0TUP_T,G00UP_T,GTTUP_T,PHASE)
           else
              Call OBSERT (NTAU1,GT0UP,G0TUP,G00UP,GTTUP,PHASE)
           endif

        ENDDO

        Do nf=1,N_FL
           call udvr_local(nf)%dealloc
        enddo
        DEALLOCATE (GRUPB, GRUP, G00UP, G0TUP, GT0UP,  GTTUP, TEMP, udvr_local)
        If (Symm) Then
           Deallocate ( G00UP_T, G0TUP_T, GT0UP_T,  GTTUP_T )
        endif
        
      END SUBROUTINE Tau_p
      
    End Module Tau_p_mod
